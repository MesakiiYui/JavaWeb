[
  {
    "category": "javaBasic",
    "qes": "重载overload和重写override的区别",
    "ans": "<div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h1>Java 重写(Override)与重载(Overload)</h1>\n<hr>\n<h2>重写(Override)</h2>\n<p> 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong>\n</p>\n\n<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。\n也就是说子类能够根据需要实现父类的方法。</p>\n<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如：\n父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n</p>\n<p>\n在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Animal 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 执行 Animal 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div>\n<p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">动物可以移动</span><span class=\"pln\">\n</span><span class=\"pun\">狗可以跑和走</span></pre>\n<p>在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。</p><p>\n这是由于在编译阶段，只是检查参数的引用类型。</p><p>\n然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。</p><p>\n因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。</p><p>\n思考以下例子：</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">bark</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以吠叫</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Animal 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 执行 Animal 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">bark</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div><p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">TestDog</span><span class=\"pun\">.</span><span class=\"pln\">java</span><span class=\"pun\">:</span><span class=\"lit\">30</span><span class=\"pun\">:</span><span class=\"pln\"> cannot find symbol\nsymbol  </span><span class=\"pun\">:</span><span class=\"pln\"> method bark</span><span class=\"pun\">()</span><span class=\"pln\">\nlocation</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Animal</span><span class=\"pln\">\n                b</span><span class=\"pun\">.</span><span class=\"pln\">bark</span><span class=\"pun\">();</span><span class=\"pln\">\n                 </span><span class=\"pun\">^</span></pre>\n<p>该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。</p>\n<hr>\n<h2>方法的重写规则</h2>\n<ul>\n\t<li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li>\n\t<li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li>\n\t<li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li>\n\t<li><p>父类的成员方法只能被它的子类重写。</p></li>\n\t<li><p>声明为 final 的方法不能被重写。</p></li>\n\t<li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li>\n\t\n\t<li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li>\n\t<li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li>\n\t<li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li>\n\t<li><p>构造方法不能被重写。</p></li>\n\t<li><p>如果不能继承一个类，则不能重写该类的方法。</p></li>\n</ul>\n<hr><h2>Super 关键字的使用</h2>\n<p>\n当需要在子类中调用父类的被重写方法时，要使用 super 关键字。\n</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-reserved\">super</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 应用super类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div><p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">动物可以移动</span><span class=\"pln\">\n</span><span class=\"pun\">狗可以跑和走</span></pre>\n\n<h2>重载(Overload)</h2>\n<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>\n<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>\n<p>最常用的地方就是构造器的重载。</p>\n<p><strong>重载规则:</strong></p>\n<ul>\n<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>\n<li>被重载的方法可以改变返回类型；</li>\n<li>被重载的方法可以改变访问修饰符；</li>\n<li>被重载的方法可以声明新的或更广的检查异常；</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n<li>无法以返回值类型作为重载函数的区分标准。\n</li>\n</ul>\n<h3>实例</h3>\n<div class=\"example\">\n<h2 class=\"example\">Overloading.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-code\"> </span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test1</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-number\">1</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test2</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">以下两个参数类型顺序不同</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">,</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">s</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">returntest3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">s</span><span class=\"hl-code\">,</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">returntest4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">o</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-number\">1</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-number\">1</span><span class=\"hl-code\">,</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">,</span><span class=\"hl-number\">1</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div>\n<hr><h2>重写与重载之间的区别</h2>\n<table class=\"reference\">\n<tbody>\n<tr>\n<th width=\"72\">\n区别点\n</th>\n<th width=\"80\">\n重载方法  \n</th>\n<th width=\"340\">\n重写方法\n</th>\n</tr>\n<tr>\n<td width=\"72\">\n参数列表\n</td>\n<td width=\"80\">\n必须修改\n</td>\n<td width=\"340\">\n一定不能修改\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n返回类型\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n一定不能修改\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n异常\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n可以减少或删除，一定不能抛出新的或者更广的异常\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n访问\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n一定不能做更严格的限制（可以降低限制）\n</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>总结</h2>\n<p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>\n<ul><li>\n(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li><li>\n(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li><li>\n(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2013/12/overloading-vs-overriding.png\"></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.png\"></p>\n\t\t\t<!-- 其他扩展 -->\n\t\t\t\t\t\t\n\t\t\t</div>\n\t\t\t\n\t\t</div>"
  },
  {
    "category": "javaBasic",
    "qes": "java中接口（interface）和虚基类（abstract class）的区别",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <p>在<a class=\"replace_word\" title=\"Java SE知识库\" href=\"http://lib.csdn.net/base/javase\" target=\"_blank\">Java</a>语言中，abstract class和interface是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p>\n<p>&nbsp;</p>\n<div>\n<table style=\"width: 100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"7%\">\n<p align=\"left\">&nbsp;</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">Abstract class</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">Interface</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">实例化</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">不能</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不能</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">类</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">一种继承关系，一个类只能使用一次继承关系。可以通过继承多个接口实现多重继承</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">一个类可以实现多个interface</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">数据成员</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可有自己的</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">静态的不能被修改即必须是static final，一般不在此定义</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">方法</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可以私有的，非abstract方法，必须实现</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不可有私有的，默认是public，abstract&nbsp;类型</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">变量</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可有私有的，默认是friendly&nbsp;型，其值可以在子类中重新定义，也可以重新赋值</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不可有私有的，默认是public static final&nbsp;型，且必须给其初值，实现类中不能重新定义，不能改变其值。</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">设计理念</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">表示的是“is-a”关系</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">表示的是“like-a”关系</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">实现</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">需要继承，要用extends</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">要用implements</p>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>abstract class和interface在Java语言中都是用来进行抽象类（本文中的抽象类并非从abstract class翻译而来，它表示的是一个抽象体，而abstract class为Java语言中用于定义抽象类的一种方法）定义的，那么什么是抽象类，使用抽象类能为我们带来什么好处呢？</p>\n<p>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</p>\n<p>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现 这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。 然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到 接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>\n<p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数。接口更关注“能实现什么功能”，而不管“怎么实现的”。</p>\n<p><strong>1.相同点</strong><br>&nbsp; A. 两者都是抽象类，都不能实例化。<br>&nbsp; B. interface实现类及abstrct class的子类都必须要实现已经声明的抽象方法。</p>\n<p><strong>2. 不同点</strong><br>&nbsp; A. interface需要实现，要用implements，而abstract class需要继承，要用extends。<br>&nbsp; B. 一个类可以实现多个interface，但一个类只能继承一个abstract class。<br>&nbsp; C. interface强调特定功能的实现，而abstract class强调所属关系。&nbsp;<br>&nbsp; D. 尽管interface实现类及abstrct class的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstract class的子类可以有选择地实现。<br>&nbsp;&nbsp;这个选择有两点含义：<br>&nbsp;&nbsp;&nbsp; 一是Abastract class中并非所有的方法都是抽象的，只有那些冠有abstract的方法才是抽象的，子类必须实现。那些没有abstract的方法，在Abstrct class中必须定义方法体。<br>&nbsp;&nbsp;&nbsp; 二是abstract class的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以通过再次声明其方法为抽象的方式，无需实现，留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。<br>&nbsp; E. abstract class是interface与Class的中介。<br>&nbsp; interface是完全抽象的，只能声明方法，而且只能声明pulic的方法，不能声明private及protected的方法，不能定义方法体，也 不能声明实例变量。然而，interface却可以声明常量变量，并且在JDK中不难找出这种例子。但将常量变量放在interface中违背了其作为接 口的作用而存在的宗旨，也混淆了interface与类的不同价值。如果的确需要，可以将其放在相应的abstract class或Class中。<br>&nbsp; abstract class在interface及Class中起到了承上启下的作用。一方面，abstract class是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己 的实例变量，以供子类通过继承来使用。</p>\n<p><strong>3. interface的应用场合</strong><br>&nbsp; A. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。<br>&nbsp; B. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。<br>&nbsp; C. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。<br>&nbsp; D. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。</p>\n<p><strong>4. abstract class的应用场合</strong><br>&nbsp; 一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：<br>&nbsp; A. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。<br>&nbsp; B. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。<br>&nbsp; C. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能。</p>\n<p>&nbsp;</p>\n<p>&nbsp; 注： 本文原作网址：http://blog.csdn.net/b271737818/article/details/3950245&nbsp;</p>\n<p>&nbsp; 原作者：<a class=\"user_name\" href=\"http://my.csdn.net/b271737818\" target=\"_blank\">moolf</a>&nbsp;&nbsp;</p>\n</div>"
  },
  {
    "category": "javaBasic",
    "qes": "Java 内部类详解",
    "ans": "<div class=\"article-body note-body\">\n\t\t\t\t<div class=\"article-intro\">\n\t\t\t\t\t<h2>一.内部类基础</h2>\n<p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p>\n\n<h3>1.成员内部类</h3>\n\n<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"drawshape\"</span><span class=\"pun\">);</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> count </span><span class=\"pun\">=</span><span class=\"lit\">1</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">radius</span><span class=\"pun\">);</span><span class=\"pln\">  </span><span class=\"com\">//外部类的private成员</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">count</span><span class=\"pun\">);</span><span class=\"pln\">   </span><span class=\"com\">//外部类的静态成员</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">外部类.</span><span class=\"kwd\">this</span><span class=\"pun\">.成员变量</span><span class=\"pln\">\n</span><span class=\"pun\">外部类.</span><span class=\"kwd\">this</span><span class=\"pun\">.成员方法</span></pre><p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n        getDrawInstance</span><span class=\"pun\">().</span><span class=\"pln\">drawSahpe</span><span class=\"pun\">();</span><span class=\"pln\">   </span><span class=\"com\">//必须先创建成员内部类的对象，再进行访问</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> getDrawInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">radius</span><span class=\"pun\">);</span><span class=\"pln\">  </span><span class=\"com\">//外部类的private成员</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">//第一种方式：</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pln\"> outter </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> outter</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">  </span><span class=\"com\">//必须通过Outter对象来创建</span><span class=\"pln\">\n         \n        </span><span class=\"com\">//第二种方式：</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner1 </span><span class=\"pun\">=</span><span class=\"pln\"> outter</span><span class=\"pun\">.</span><span class=\"pln\">getInnerInstance</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> getInnerInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">if</span><span class=\"pun\">(</span><span class=\"pln\">inner </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\">\n            inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> inner</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n      \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>\n<h3>2.局部内部类</h3>\n<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Man</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Man</span><span class=\"pun\">(){</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pln\"> getWoman</span><span class=\"pun\">(){</span><span class=\"pln\">\n        </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Woman</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">{</span><span class=\"pln\">   </span><span class=\"com\">//局部内部类</span><span class=\"pln\">\n            </span><span class=\"kwd\">int</span><span class=\"pln\"> age </span><span class=\"pun\">=</span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Woman</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>　<p><strong>注意</strong>: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p><h3>3.匿名内部类</h3>\n\n<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段 Android 事件监听代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">scan_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">});</span><span class=\"pln\">\n \nhistory_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n     \n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">});</span></pre><p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> setListener</span><span class=\"pun\">()</span><span class=\"pln\">\n</span><span class=\"pun\">{</span><span class=\"pln\">\n    scan_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Listener1</span><span class=\"pun\">());</span><span class=\"pln\">       \n    history_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Listener2</span><span class=\"pun\">());</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Listener1</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">View</span><span class=\"pun\">.</span><span class=\"typ\">OnClickListener</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n             \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Listener2</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">View</span><span class=\"pun\">.</span><span class=\"typ\">OnClickListener</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n             \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和 static 修饰符的。</p>\n\n<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>\n<h3>4.静态内部类</h3>\n<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p><img src=\"/wp-content/uploads/2018/04/021558444183591.jpg\"></p><hr>\n<h2>二.深入理解内部类</h2>\n<p><strong>1.为什么成员内部类可以无条件访问外部类的成员？</strong></p>\n\n<p>在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是 Outter.java 的代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> getInnerInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">if</span><span class=\"pun\">(</span><span class=\"pln\">inner </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\">\n            inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> inner</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n      \n    </span><span class=\"kwd\">protected</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>编译之后，出现了两个字节码文件：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021630063402064.jpg\"></p>\n<p>反编译 Outter$Inner.class 文件得到下面信息：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">E</span><span class=\"pun\">:</span><span class=\"pln\">\\Workspace\\Test\\b</span><span class=\"kwd\">in</span><span class=\"pln\">\\com\\cxh\\test2</span><span class=\"pun\">&gt;</span><span class=\"pln\">javap </span><span class=\"pun\">-</span><span class=\"pln\">v </span><span class=\"typ\">Outter$Inner</span><span class=\"pln\">\n</span><span class=\"typ\">Compiled</span><span class=\"pln\"> </span><span class=\"kwd\">from</span><span class=\"pln\"> </span><span class=\"str\">\"Outter.java\"</span><span class=\"pln\">\n</span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter$Inner</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> java</span><span class=\"pun\">.</span><span class=\"pln\">lang</span><span class=\"pun\">.</span><span class=\"typ\">Object</span><span class=\"pln\">\n  </span><span class=\"typ\">SourceFile</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"str\">\"Outter.java\"</span><span class=\"pln\">\n  </span><span class=\"typ\">InnerClass</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"com\">#24= #1 of #22; //Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes</span><span class=\"pln\">\nt2</span><span class=\"pun\">/</span><span class=\"typ\">Outter</span><span class=\"pln\">\n  minor version</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pln\">\n  major version</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">50</span><span class=\"pln\">\n  </span><span class=\"typ\">Constant</span><span class=\"pln\"> pool</span><span class=\"pun\">:</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#1 = class        #2;     //  com/cxh/test2/Outter$Inner</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#2 = Asciz        com/cxh/test2/Outter$Inner;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#3 = class        #4;     //  java/lang/Object</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#4 = Asciz        java/lang/Object;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#5 = Asciz        this$0;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#6 = Asciz        Lcom/cxh/test2/Outter;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#7 = Asciz        &lt;init&gt;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#8 = Asciz        (Lcom/cxh/test2/Outter;)V;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#9 = Asciz        Code;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#10 = Field       #1.#11; //  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t</span><span class=\"pln\">\nest2</span><span class=\"pun\">/</span><span class=\"typ\">Outter</span><span class=\"pun\">;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#11 = NameAndType #5:#6;//  this$0:Lcom/cxh/test2/Outter;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#12 = Method      #3.#13; //  java/lang/Object.\"&lt;init&gt;\":()V</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#13 = NameAndType #7:#14;//  \"&lt;init&gt;\":()V</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#14 = Asciz       ()V;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#15 = Asciz       LineNumberTable;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#16 = Asciz       LocalVariableTable;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#17 = Asciz       this;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#18 = Asciz       Lcom/cxh/test2/Outter$Inner;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#19 = Asciz       SourceFile;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#20 = Asciz       Outter.java;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#21 = Asciz       InnerClasses;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#22 = class       #23;    //  com/cxh/test2/Outter</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#23 = Asciz       com/cxh/test2/Outter;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#24 = Asciz       Inner;</span><span class=\"pln\">\n \n</span><span class=\"pun\">{</span><span class=\"pln\">\n</span><span class=\"kwd\">final</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pln\">$0</span><span class=\"pun\">;</span><span class=\"pln\">\n \n</span><span class=\"kwd\">public</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter$Inner</span><span class=\"pun\">(</span><span class=\"pln\">com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pun\">);</span><span class=\"pln\">\n  </span><span class=\"typ\">Code</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"typ\">Stack</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pun\">,</span><span class=\"pln\"> </span><span class=\"typ\">Locals</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pun\">,</span><span class=\"pln\"> </span><span class=\"typ\">Args_size</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pln\">\n   </span><span class=\"lit\">0</span><span class=\"pun\">:</span><span class=\"pln\">   aload_0\n   </span><span class=\"lit\">1</span><span class=\"pun\">:</span><span class=\"pln\">   aload_1\n   </span><span class=\"lit\">2</span><span class=\"pun\">:</span><span class=\"pln\">   putfield        </span><span class=\"com\">#10; //Field this$0:Lcom/cxh/test2/Outter;</span><span class=\"pln\">\n   </span><span class=\"lit\">5</span><span class=\"pun\">:</span><span class=\"pln\">   aload_0\n   </span><span class=\"lit\">6</span><span class=\"pun\">:</span><span class=\"pln\">   invokespecial   </span><span class=\"com\">#12; //Method java/lang/Object.\"&lt;init&gt;\":()V</span><span class=\"pln\">\n   </span><span class=\"lit\">9</span><span class=\"pun\">:</span><span class=\"pln\">   </span><span class=\"kwd\">return</span><span class=\"pln\">\n  </span><span class=\"typ\">LineNumberTable</span><span class=\"pun\">:</span><span class=\"pln\">\n   line </span><span class=\"lit\">16</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pln\">\n   line </span><span class=\"lit\">18</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">9</span><span class=\"pln\">\n \n  </span><span class=\"typ\">LocalVariableTable</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"typ\">Start</span><span class=\"pln\">  </span><span class=\"typ\">Length</span><span class=\"pln\">  </span><span class=\"typ\">Slot</span><span class=\"pln\">  </span><span class=\"typ\">Name</span><span class=\"pln\">   </span><span class=\"typ\">Signature</span><span class=\"pln\">\n   </span><span class=\"lit\">0</span><span class=\"pln\">      </span><span class=\"lit\">10</span><span class=\"pln\">      </span><span class=\"lit\">0</span><span class=\"pln\">    </span><span class=\"kwd\">this</span><span class=\"pln\">       </span><span class=\"typ\">Lcom</span><span class=\"pun\">/</span><span class=\"pln\">cxh</span><span class=\"pun\">/</span><span class=\"pln\">test2</span><span class=\"pun\">/</span><span class=\"typ\">Outter$Inner</span><span class=\"pun\">;</span><span class=\"pln\">\n \n \n</span><span class=\"pun\">}</span></pre><p>第11行到35行是常量池的内容，下面逐一第38行的内容：</p><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">final</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pln\">$0</span><span class=\"pun\">;</span></pre>\n<p>这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：</p><p>public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</p>\n\n<p>从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的 Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对 Outter this&amp;0 引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>\n\n<p><strong>2.为什么局部内部类和匿名内部类只能访问局部final变量？</strong></p>\n\n<p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> test</span><span class=\"pun\">(</span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> b</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">10</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Thread</span><span class=\"pun\">(){</span><span class=\"pln\">\n            </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> run</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">b</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"pun\">};</span><span class=\"pln\">\n        </span><span class=\"pun\">}.</span><span class=\"pln\">start</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>　<p>这段代码会被编译成两个class文件：Test.class和Test1.class。<strong>默认情况下，编译器会为匿名内部类和局部内部类起名为<span class=\"marked\">Outterx.class</span>（x为正整数）</strong>。</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021900556994393.jpg\"></p>\n<p>根据上图可知，test 方法中的匿名内部类的名字被起为 Test$1。</p>\n\n<p>上段代码中，如果把变量 a 和 b 前面的任一个 final 去掉，这段代码都编译不过。我们先考虑这样一个问题：</p>\n\n<p>当 test 方法执行完毕之后，变量a的生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束，那么在 Thread 的 run 方法中继续访问变量 a 就变成不可能了，但是又要实现这样的效果，怎么办呢？Java 采用了复制的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021939271846598.jpg\"></p>\n<p>我们看到在 run 方法中有一条指令：</p><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">bipush </span><span class=\"lit\">10</span></pre><p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p><p>下面再看一个例子：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> test</span><span class=\"pun\">(</span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Thread</span><span class=\"pun\">(){</span><span class=\"pln\">\n            </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> run</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"pun\">};</span><span class=\"pln\">\n        </span><span class=\"pun\">}.</span><span class=\"pln\">start</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>反编译得到：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021950384493440.jpg\"></p>\n<p>我们看到匿名内部类 Test$1 的构造器含有两个参数，一个是指向外部类对象的引用，一个是 int 型变量，很显然，这里是将变量 test 方法中的形参 a 以参数的形式传进来对匿名内部类中的拷贝（变量 a 的拷贝）进行赋值初始化。</p>\n\n<p>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p>\n\n<p>从上面可以看出，在 run 方法中访问的变量 a 根本就不是 test 方法中的局部变量 a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在 run 方法中访问的变量 a 和 test 方法中的变量 a 不是同一个变量，当在 run 方法中改变变量 a 的值的话，会出现什么情况？</p>\n\n<p>对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java 编译器就限定必须将变量 a 限制为 final 变量，不允许对变量 a 进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>\n\n<p>到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用 final 进行限定了。</p>\n<p><strong>3.静态内部类有特殊的地方吗？</strong></p><p>从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译 class 文件看一下就知道了，是没有 <span class=\"marked\">Outter this&amp;0</span> 引用的。</p>\n<hr>\n<h2>三.内部类的使用场景和好处</h2><p>为什么在 Java 中需要内部类？总结一下主要有以下四点：</p>\n<ul><li>\n1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整。\n</li><li>2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。\n</li><li>3.方便编写事件驱动程序。\n</li><li>4.方便编写线程代码。</li></ul><p>个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p>\n<p><strong>四.常见的与内部类相关的笔试面试题</strong></p>\n <p>1.根据注释填写(1)，(2)，(3)处的代码</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">){</span><span class=\"pln\">\n           </span><span class=\"com\">// 初始化Bean1</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean1</span><span class=\"pun\">.</span><span class=\"pln\">I</span><span class=\"pun\">++;</span><span class=\"pln\">\n           </span><span class=\"com\">// 初始化Bean2</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">2</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean2</span><span class=\"pun\">.</span><span class=\"pln\">J</span><span class=\"pun\">++;</span><span class=\"pln\">\n           </span><span class=\"com\">//初始化Bean3</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">3</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean3</span><span class=\"pun\">.</span><span class=\"pln\">k</span><span class=\"pun\">++;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean1</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> I </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n \n    </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean2</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> J </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean3</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> k </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>\n\n<p>创建静态内部类对象的一般形式为：  <span class=\"marked\">外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</span></p>\n\n<p>创建成员内部类对象的一般形式为：  <span class=\"marked\">外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</span></p>\n<p>因此，（1），（2），（3）处的代码分别为：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Test</span><span class=\"pln\"> test </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">();</span><span class=\"pln\">    \n</span><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean1</span><span class=\"pln\"> bean1 </span><span class=\"pun\">=</span><span class=\"pln\"> test</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean1</span><span class=\"pun\">();</span></pre>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean2</span><span class=\"pln\"> b2 </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean2</span><span class=\"pun\">();</span></pre>  \n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Bean</span><span class=\"pln\"> bean </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean</span><span class=\"pun\">();</span><span class=\"pln\">     \n\n</span><span class=\"typ\">Bean</span><span class=\"pun\">.</span><span class=\"typ\">Bean3</span><span class=\"pln\"> bean3 </span><span class=\"pun\">=</span><span class=\"pln\">  bean</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean3</span><span class=\"pun\">();</span></pre>\n<p>2.下面这段代码的输出结果是什么？</p> \n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pln\"> outter </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">();</span><span class=\"pln\">\n        outter</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">().</span><span class=\"kwd\">print</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\">\n</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">1</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> </span><span class=\"kwd\">print</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"局部变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"内部类变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"外部类变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"lit\">3</span><span class=\"pln\">\n</span><span class=\"lit\">2</span><span class=\"pln\">\n</span><span class=\"lit\">1</span></pre><p>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>\n\n<ul><li>1）成员内部类的引用方式必须为 Outter.Inner \n</li><li>2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》    </li></ul>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">InheritInner</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n      \n    </span><span class=\"com\">// InheritInner() 是不能通过编译的，一定要加上形参</span><span class=\"pln\">\n    </span><span class=\"typ\">InheritInner</span><span class=\"pun\">(</span><span class=\"typ\">WithInner</span><span class=\"pln\"> wi</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        wi</span><span class=\"pun\">.</span><span class=\"kwd\">super</span><span class=\"pun\">();</span><span class=\"pln\"> </span><span class=\"com\">//必须有这句调用</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n  \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">WithInner</span><span class=\"pln\"> wi </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"typ\">InheritInner</span><span class=\"pln\"> obj </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">InheritInner</span><span class=\"pun\">(</span><span class=\"pln\">wi</span><span class=\"pun\">);</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n\n\n<blockquote><p>原文出处：https://www.cnblogs.com/dolphin0520/p/3811445.html</p></blockquote>\n\n\t\t\t\t</div>\n\t\t\t</div>"
  },
  {
    "category": "javaBasic",
    "qes": "内部类和静态内部类的区别",
    "ans": "<div class=\"RichText ztext Post-RichText\"><p><b>内部类和静态内部类的区别</b></p><p><b>内部类：</b></p><p>1、内部类中的变量和方法不能声明为静态的。<br>2、内部类实例化：B是A的内部类，实例化B：A.B b = new A().new B()。<br>3、内部类可以引用外部类的静态或者非静态属性及方法。</p><p><b>静态内部类：</b></p><p>1、静态内部类属性和方法可以声明为静态的或者非静态的。<br>2、实例化静态内部类：B是A的静态内部类，A.B b = new A.B()。<br>3、静态内部类只能引用外部类的静态的属性及方法。</p><blockquote>inner classes——内部类<br>static nested classes——静态嵌套类</blockquote><p>其实人家不叫静态内部类，只是叫习惯了，从字面就很容易理解了。</p><p>内部类依靠外部类的存在为前提，而静态嵌套类则可以完全独立，明白了这点就很好理解了。</p><p><b>非静态内部类中的变量和方法不能声明为静态的原因</b></p><p>静态类型的属性和方法，在类加载的时候就会存在于内存中。使用某个类的静态属性和方法，那么这个类必须要加载到虚拟机中。但是非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。</p><p>我们设想一个场景：在外部类并没有实例化，内部类还没有加载的时候如果调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内部类的静态成员，就会产生冲突。所以非静态内部类不能有静态成员变量或静态方法。</p><p><b>String，StringBuilder，StringBuffer的区别</b></p><ul><li>String 字符串常量</li><li>StringBuffer 字符串变量（线程安全）</li><li>StringBuilder 字符串变量（非线程安全）</li></ul><p>性能上通常StringBuilder &gt; StringBuffer &gt; String。</p><p>String是不可变对象，每次对String类型进行改变的时候都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以性能最差，对于要经常改变内容的字符串不用String。</p><p>StringBuffer是字符串变量，对它操作时，并不会生成新的对象，而是直接对该对象进行更改，所以性能较好。</p><p>StringBuilder和StringBuffer一样，是字符串变量，但是他不带有synchronized关键字，不保证线程安全，所以性能最好。在单线程的情况下，建议使用StringBuilder。</p><p><b>总体来说：</b></p><ul><li>String：适用于少量的字符串操作的情况。</li><li>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况。</li><li>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。</li></ul><p><b>来一些问题：</b></p><p>下面这段代码的输出结果是什么？</p><div class=\"highlight\"><pre><code class=\"language-text\">String a = \"helloworld\";\nString b = \"hello\" + \"world\";\nSystem.out.println((a == b));\njava中高端架构师交流群：603619042</code></pre></div><p><b>输出结果为：True。</b></p><p>原因是String对字符串的直接相加，会在编译期进行优化。即hello+world在编译时期，被优化为helloworld，所以在运行时期，他们指向了同一个对象。我们也可以推理，对于直接字符串的相加，String不一定比其余两个慢。</p><p>下面这段代码的输出结果是什么？</p><div class=\"highlight\"><pre><code class=\"language-text\">String a = \"helloworld\";\nString b = \"hello\";      \nString c = b + \"world\";      \nSystem.out.println((a == c));</code></pre></div><p><b>输出结果为：False。</b></p><p>原因是c并非两个字符串直接相加，包含了一个字符串引用，这时不会做编译期的优化。所以a、c最终生成了两个对象，这时他的效率低。</p><p>集合和数组之间的相互转换</p><p><b>数组变集合：</b></p><p>通常我们会回答的是以下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;String&gt; list = Arrays.asList(array);</code></pre></div><p>但这并不是很好的答案，此时组合成的list是Arrays里面的一个静态内部类，该类并未实现add、remove方法，因此在使用时存在问题。</p><p><b>可以这样：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">String array[]= {\"hello\",\"world\",\"java\",\"zhiyin\"};\nList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array));</code></pre></div><p>集合变数组：</p><div class=\"highlight\"><pre><code class=\"language-text\">String[] array=list.toArray(new String[list.size()]);</code></pre></div><p><b>面向对象的特征有哪些方面?</b></p><p><b>抽象</b>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p><b>继承</b>：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类；得到继承信息的类被称为子类。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p><p><b>封装</b>：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</p><p><b>多态性</b>：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载实现的是编译时的多态性，而方法重写实现的是运行时的多态性。</p><p><b>概括的解释下线程的几种状态</b></p><p>1.就绪(Runnable):线程准备运行，不一定立马就能开始执行。</p><p>2.运行中(Running)：进程正在执行线程的代码。</p><p>3.等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。</p><p>4.睡眠中(Sleeping)：线程被强制睡眠。</p><p>5.I/O阻塞(Blocked on I/O)：等待I/O操作完成。</p><p>6.同步阻塞(Blocked on Synchronization)：等待获取锁。</p><p>7.死亡(Dead)：线程完成了执行。</p><p><b>Java集合类里面基本的接口有哪些</b></p><p>1.Collection：代表一组对象，每一个对象都是它的子元素。</p><p>2.Set：不包含重复元素的Collection。</p><p>3.List：有顺序的collection，并且可以包含重复元素。</p><p>4.Map：可以把键(key)映射到值(value)的对象，键不能重复。</p><p><b>Iterator和ListIterator的区别</b></p><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向遍历也可以后向遍历。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加、替换元素，获取前一个和后一个元素的索引等等。</li></ul><p><b>Enumeration和Iterator的区别</b></p><ul><li>java中的集合类都提供了返回Iterator的方法，就是迭代器，它和Enumeration（枚举）的主要区别其实就是Iterator可以删除元素，但是Enumration却不能。</li><li>使用Iterator来遍历集合时，应使用Iterator的remove()方法来删除集合中的元素，使用集合的remove()方法将抛出ConcurrentModificationException异常。</li><li>Enumeration接口的功能和Iterator接口的功能是重复的。此外，Iterator 接口添加了一个可选的移除操作，并使用较短的方法名。新的实现应该优先考虑使用Iterator接口而不是Enumeration接口。</li><li>Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。</li></ul><p><b>介绍一下HTTP的响应结构</b></p><ul><li>请求报文的组成：</li><li>请求方法。</li><li>请求的资源的URI。</li><li>协议版本。</li><li>可选的请求首部字段。</li><li>内容实体。</li></ul><p><b>响应报文的组成：</b></p><ul><li>协议版本。</li><li>状态码。</li><li>用于解释状态码的原因短语。</li><li>可选的响应首部字段。</li><li>实体主体。</li></ul><p>**响应: **</p><ul><li>响应码：回应客户端此次响应是否成功。如：404(找不到请求的资源)，500(服务器内部错误)，200(成功响应)等。</li><li>消息头：服务器与客户端通信的暗码，告诉客户端该怎么执行某些操作。</li><li>响应正文：传递服务器响应给客户端要显示的内容，可以是下载文件或者显示界面。</li></ul><p><b>final、finalize和finally各自的作用</b></p><ul><li>final是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。</li><li>finalize方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。</li><li>finally是一个关键字，与try和catch一起用于异常的处理。finally块一定会被执行，无论在try块中是否有发生异常。</li></ul><p><b>说一下你了解的几种进程间的通信方式</b></p><p>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>高级管道popen：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><p>有名管道named pipe ：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><p>信号sinal： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></div>"
  },
  {
    "category": "javaBasic",
    "qes": "谨用ArrayList中的subList方法",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <h3><a name=\"t0\"></a><a name=\"t0\"></a>0、subList方法api：</h3> \n<p>Parameters:</p> \n<ul><li>fromIndex low endpoint (inclusive) of the subList</li><li>toIndex high endpoint (exclusive) of the subList</li></ul>\n<p>Returns:</p> \n<ul><li>a view of the specified range within this list</li></ul>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a>1、规范一：</h3> \n<p>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs php\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">static</span> <span class=\"hljs-keyword\">void</span> test7() {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList = <span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList);<span class=\"hljs-comment\">//2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tArrayList&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList1 = (ArrayList&lt;<span class=\"hljs-keyword\">Integer</span>&gt;)<span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-comment\">//java.lang.ClassCastException: java.util.ArrayList$SubList cannot be cast to java.util.ArrayList</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList1);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>分析：</p> \n<ol><li>SubList 继承 AbstractList ，所以具有List接口的所有方法。</li><li><span style=\"color:#f33b45;\">SubList 是ArrayList 的一个内部类。SubList并没有重新创建一个List,而是直接引用原有的List，只不过对原来List做截取而已</span>。</li><li>ArrayList 也是继承AbstractList，但是 SubList 和 ArrayList 没有继承关系，所以不能强转换。</li></ol>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a>2、规范二：</h3> \n<p>在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs php\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">static</span> <span class=\"hljs-keyword\">void</span> test8() {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList = <span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">4</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-comment\">//java.util.ConcurrentModificationException</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>&nbsp;分析：</p> \n<p>1）调用subList方法返回的集合保存了ArrayList的modCount</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143247490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<p>2）当对原list进行add/remove时，导致modCount++；</p> \n<p>3）访问子集合时，加了checkForComodification();校验</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143314312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<h3><a name=\"t3\"></a><a name=\"t3\"></a>3、对subList返回的子集合进行add/remove操作会如何？</h3> \n<p>我们来看一段代码</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs csharp\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test9</span>(<span class=\"hljs-params\"></span>)</span> {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tList&lt;Integer&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tList&lt;Integer&gt; subList = list.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"------------------------\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tsubList.<span class=\"hljs-keyword\">remove</span>(<span class=\"hljs-number\">0</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"------------------------\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tsubList.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">4</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,3,4</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"17\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//3,4</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"18\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>运行正常，分析：</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143158727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<p>subList返回的集合在调用add/remove方法时，会将modCount进行更新。注：更新操作只更新原集合，因为subList不会重新创建新集合。</p> \n<p><strong>总结：</strong></p> \n<p>1、subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p> \n<p>2、在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p> \n<p>&nbsp;</p> \n<p></p> \n<p></p> \n<p></p> \n<p></p> \n<p></p>\n                </div><div><div></div></div>\n        </div>"
  },
  {
    "category": "javaBasic",
    "qes": "详解Map集合体系及方法entrySet、keySet、values",
    "ans": "<div class=\"postBody\">\n                \n<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <h3>简单回顾Map集合：</h3>\n<p>&nbsp;</p>\n<p>Map表示映射关系，以键值对的方式来保存数据。key和value一一对应。key是唯一的，不可重复，而value是可重复的，可以被多个key关联。虽然Map是放入两个数据，但是却以key作为操作对象，value只是作为key的关联值。</p>\n<p>通过查看，会发现Set与Map的实现类很相似，Set实现类的底层操作就是用Map来实现的，Set集的特性就来自于Map。唯一不同的就是Map表示一种映射关系，一次存储2个数据，Set只能存储单一数据。</p>\n<h3>Map体系中的主要类：</h3>\n<ul>\n<li>HashMap：Map的典型实现，元素是无序且不可重复，这里的元素指的是key。</li>\n<li>LinkedHashMap：以插入的次序作为排序状态，其他的和HashMap一致。</li>\n<li>TreeMap：元素处于排序状态，可以使用自然排序也可以使用自定义排序，但key的类型必须一致，不然无法进行比较。</li>\n<li>Properties：Key-Value都是String类型，用于加载属性文件。后续会说到。</li>\n</ul>\n<div>\n<h3>Map的重要方法和特点：</h3>\n<div>常用方法就不概述，关于Map中方法的使用细节，例如replace()和remove()方法，如果返回值是Object，则会返回以前的value，返回值boolean，代表是否执行成功。重点需要了解entrySet()、keySet()&nbsp;和values()的使用。</div>\n<div>\n<ul>\n<li>entrySet()___返回一个包含所有映射关系的Set集合，该Set集合的类型为Map.Entry，一般用于迭代键值对。Map.Entry是一个内部接口。</li>\n<li>keySet()__..._返回该映射中所有key组成的Set集合。通过key获取键值对。</li>\n<li>values()___._返回该映射中所有value值。</li>\n<li>这三个方法主要用于遍历键值对或直接获取value值，非常方便。但使用返回对象的方法时，会引发错误。代码示例和解析在最下面。</li>\n</ul>\n</div>\n</div>\n<h3>HashMap的代码示例</h3>\n<div>\n<pre name=\"code\" class=\"java\">\t\tHashMap hm = new HashMap();\n\t\t//放入键值对\n\t\thm.put(\"cn\", \"中国\");\n\t\thm.put(1, 100);\t\t\n\t\thm.put(\"us\", \"美国\");\n\t\thm.put(\"Ja\", \"日本\");\n\t\thm.put(\"时间\", new Date());\n\t\thm.put(1, 200);//用同一个key关联别的value\n\t\tSystem.out.println(hm);\t//等同于hm.toString()\n\t\t\n\t\tSystem.out.println(\"----根据key获取关联的值------\");\n\t\tSystem.out.println(hm.get(\"Ja\"));\n\t\tSystem.out.println(hm.get(1));\n\t\t\t\n\t\tSystem.out.println(\"----替换指定的键值对-------\");\n\t\tSystem.out.println(hm.replace(1, \"100\"));//返回被替换的value\n\t\tSystem.out.println(hm.replace(\"us\", \"美国\",\"FuckYou\"));//返回boolean，表示是否替换成功\n\t\t\n\t\tSystem.out.println(\"----删除指定键值对----\");\n\t\tSystem.out.println(hm.remove(\"Ja\"));//返回被删除的value\n\t\tSystem.out.println(hm.remove(\"Ja\",\"日本\"));//返回是否成功删除</pre>\n<div>典型的Map实现，查看打印结果：元素是无序且不可重复的。在代码中放入两个相同的键值对，key只能有一个，如果value也不同，后来添加的value会覆盖原来的value。</div>\n<div>&nbsp;</div>\n<h3>LinkedHashMap简单示例</h3>\n</div>\n<div>\n<pre name=\"code\" class=\"java\">\t\tLinkedHashMap lhm = new LinkedHashMap();\n\t\tlhm.put(1,\"B\");\n\t\tlhm.put(4,\"A\");\n\t\tlhm.put(3,\"C\");\n\t\tlhm.put(2,\"D\");\n\t\tSystem.out.println(lhm);\n\t\t//输出：{1=B, 4=A, 3=C, 2=D}</pre>\nLinkedHashMap就是以插入次序作为排序状态，别的和HashMap一致。非常类似于HashSet与LinkedHashSet的关系。</div>\n<div>&nbsp;</div>\n<h2>entrySet() 和 keySet()&nbsp;和 values()的代码示例</h2>\n<h4>以TreeMap为例，演示entrySet()</h4>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\t\n\t\t//使用迭代器来遍历元素\n\t\tSet entrys = tm.entrySet();\n\t\tIterator it = entrys.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry)it.next();//转换成Map.Entry类型\n\t\t\tSystem.out.println(entry.getKey() +\"-\" + entry.getValue());\t\t\t\n\t\t}</pre>\n</div>\n<h4>以TreeMap为例，演示keySet()</h4>\n<div>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\t\n\t\tSet k = tm.keySet();\n\t\tIterator it = k.iterator();\n\t\t//mode 1\n\t\twhile(it.hasNext()) {\n\t\t\tObject key = it.next();//获取key\n\t\t\tSystem.out.println(key + \"-&gt;\" + tm.get(key));\n\t\t}\n\t\t//mode 2\n\t\tfor(Object key : k) {\n\t\t\tSystem.out.println(key +\"-&gt;\" + tm.get(key));\n\t\t}</pre>\n</div>\n<div>\n<h4>以TreeMap为例，演示values()</h4>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\tCollection value = tm.values();\t\n\t\tfor(Object v : value) {\n\t\t\tSystem.out.println(v);\n\t\t}</pre>\n<div>&nbsp;</div>\n<h3>entrySet() keySet() 和 values()返回对象中的操作方法</h3>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\tSet entry = tm.entrySet();\t\n\t\tSet key = tm.keySet();\n\t\tCollection value = tm.values();\t\t\n\n//\t\tentry.add(\"A\");引发不支持的操作异常\n\t\tSystem.out.println(entry.remove(1));//false\n\t\tSystem.out.println(entry.contains(3));//false\n\t\t\n\t\tSystem.out.println(key.remove(1));//true\n\t\tSystem.out.println(key.contains(3));//true\n\t\t\n\t\tSystem.out.println(value.remove(\"壹\"));//false</pre>\n上面代码中，可以看出无论是返回Set对象还是Collection，添加元素都会引发不支持的操作异常。这是因为返回的集合对象本质上依然是对键值对操作。它们的不同之处：</div>\n<div>entrySet()中有key和value，所以直接加入元素或者删除元素的方法都是无效的。keySet()中有key，可以对key进行操作，所以能使用remove()和equals()，所以返回true。</div>\nvalues()中只有value值，没有key，value值是没什么用的，所以values()方法也仅仅是获取所有value值方便。</div>\n<div>相同之处：<br>方法中如果没有参数，不涉及到对键值对进行的操作，都是可以使用的。例如Iterator()、clear()、size()和isEmpty()等。</div>\n\n</div>\n<div>&nbsp;</div>\n<h3>entrySet() 和 keySet()&nbsp;和 values()的使用总结：</h3>\n<div>\n<ul>\n<li>一般只使用它们的迭代器，用于获取所有键值对。</li>\n<li>除了迭代器，对元素进行操作的方法不建议使用，容易出错。</li>\n<li>如果要高效遍历key-value，建议使用entrySet()，keySet()也可以做到，但需要通过key来获取value，多增加了一步。</li>\n<li>获取所有key就使用keySet()，获取所有value就使用values()</li>\n\n</ul>\n\n</div>\n\n</div>\n</div>\n<div id=\"MySignature\"></div>\n<div class=\"clear\"></div>\n<div id=\"blog_post_info_block\"><div id=\"BlogPostCategory\">\n    分类: \n            <a href=\"https://www.cnblogs.com/fwnboke/category/977503.html\" target=\"_blank\">Java基础总结</a></div>\n\n\n    <div id=\"blog_post_info\">\n<div id=\"green_channel\">\n        <a href=\"javascript:void(0);\" id=\"green_channel_digg\" onclick=\"DiggIt(8529656,cb_blogId,1);green_channel_success(this,'谢谢推荐！');\">好文要顶</a>\n        <a id=\"green_channel_follow\" onclick=\"follow('5c46ef51-7228-e611-9fc1-ac853d9f53cc');\" href=\"javascript:void(0);\">关注我</a>\n    <a id=\"green_channel_favorite\" onclick=\"AddToWz(cb_entryId);return false;\" href=\"javascript:void(0);\">收藏该文</a>\n    <a id=\"green_channel_weibo\" href=\"javascript:void(0);\" title=\"分享至新浪微博\" onclick=\"ShareToTsina()\"><img src=\"https://common.cnblogs.com/images/icon_weibo_24.png\" alt=\"\"></a>\n    <a id=\"green_channel_wechat\" href=\"javascript:void(0);\" title=\"分享至微信\" onclick=\"shareOnWechat()\"><img src=\"https://common.cnblogs.com/images/wechat.png\" alt=\"\"></a>\n</div>\n<div id=\"author_profile\">\n    <div id=\"author_profile_info\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/fwnboke/\" target=\"_blank\"><img src=\"https://pic.cnblogs.com/face/969690/20170402132941.png\" class=\"author_avatar\" alt=\"\"></a>\n        <div id=\"author_profile_detail\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/fwnboke/\">乘风起</a><br>\n            <a href=\"https://home.cnblogs.com/u/fwnboke/followees/\">关注 - 0</a><br>\n            <a href=\"https://home.cnblogs.com/u/fwnboke/followers/\">粉丝 - 21</a>\n        </div>\n    </div>\n    <div class=\"clear\"></div>\n    <div id=\"author_profile_honor\"></div>\n    <div id=\"author_profile_follow\">\n                <a href=\"javascript:void(0);\" onclick=\"follow('5c46ef51-7228-e611-9fc1-ac853d9f53cc');return false;\">+加关注</a>\n    </div>\n</div>\n<div id=\"div_digg\">\n    <div class=\"diggit\" onclick=\"votePost(8529656,'Digg')\">\n        <span class=\"diggnum\" id=\"digg_count\">1</span>\n    </div>\n    <div class=\"buryit\" onclick=\"votePost(8529656,'Bury')\">\n        <span class=\"burynum\" id=\"bury_count\">0</span>\n    </div>\n    <div class=\"clear\"></div>\n    <div class=\"diggword\" id=\"digg_tips\">\n    </div>\n</div>\n\n<script type=\"text/javascript\">\n    currentDiggType = 0;\n</script></div>\n    <div class=\"clear\"></div>\n    <div id=\"post_next_prev\">\n\n    <a href=\"https://www.cnblogs.com/fwnboke/p/8529647.html\" class=\"p_n_p_prefix\">« </a> 上一篇：    <a href=\"https://www.cnblogs.com/fwnboke/p/8529647.html\" title=\"发布于 2018-03-08 17:19\">Java集合框架体系</a>\n    <br>\n    <a href=\"https://www.cnblogs.com/fwnboke/p/8529670.html\" class=\"p_n_p_prefix\">» </a> 下一篇：    <a href=\"https://www.cnblogs.com/fwnboke/p/8529670.html\" title=\"发布于 2018-03-08 17:23\">泛型的定义、用法与类型通配符的使用方式</a>\n\n</div>\n</div>\n            </div>"
  },
  {
    "category": "javaBasic",
    "qes": "String类为什么是final的。",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<p><strong>最佳答案：</strong></p>\n<p>主要是为了“效率”&nbsp;和&nbsp;“安全性”&nbsp;的缘故。若&nbsp;String允许被继承,&nbsp;由于它的高度被使用率,&nbsp;可能会降低程序的性能，所以String被定义成final。</p>\n<p><strong>其它答案一：</strong></p>\n<p align=\"left\">String和其他基本类型不同,他是个对象类型.既然是对象类型,如果是在静态方法下是必须调用静态方法或值的,如果是非静态的方法,就必须要实例化.&nbsp;<br>main函数是个static的.所以String要能像其他的基本类型一样直接被调用.这也是为什么在main函数下使用String类型不会报告错误的原因..&nbsp;<br>一下就解释了两个心里的疑问..&nbsp;<br>以前一直觉得奇怪,为什么String是对象类型在main函数下却是不需要实例化的.再次佩服java设计人员想得真周到.</p>\n<p>&nbsp;</p>\n<p><strong>其它答案二：</strong></p>\n<p>当定义String类型的静态字段（也成类字段），可以用静态变量（非final）代替常量（final）加快程序速度。反之，对于原始数据类型，例如int，也成立。&nbsp;<br><br>例如，你可能创建一个如下的String对象：&nbsp;<br><br>private static final String x = \"example\";&nbsp;<br><br>对于这个静态常量（由final关键字标识），你使用常量的每个时候都会创建一个临时的String对象。在字节代码中，编译器去掉”x”，代替它的是字符串“example”,以致每次引用”x”时VM都会进行一次哈希表查询。&nbsp;<br><br>相比之下，度于静态变量(非final关键字)，字符串只创建一次。仅当初始化“x”时，VM才进行哈希表查询。&nbsp;<br><br>还有另一个解释:&nbsp;<br>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了人们覆盖length()方法。&nbsp;<br><br>　　另外，如果指定一个类为final，则该类所有的方法都是final。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>\n<p><strong>示例：</strong></p>\n<p>public class Test {&nbsp;<br>public static void main(String[] args)&nbsp; {&nbsp;<br>//&nbsp;&nbsp;<br>}&nbsp;<br>}&nbsp;<br><br>如果String&nbsp;不是final&nbsp;那么就可以继承&nbsp;<br>public class String2 extends String{&nbsp;<br>&nbsp;&nbsp; // ..&nbsp;<br>&nbsp;&nbsp; // ...&nbsp;<br>}&nbsp;<br><br>那我们的&nbsp;main也就可以写成&nbsp;<br>public class Test {&nbsp;<br>public static void main(String2[] args)&nbsp; { //&nbsp;注意此处&nbsp;<br>//&nbsp;&nbsp;<br>}&nbsp;<br>}</p>\n<p><strong>英文参考：</strong><a href=\"http://forums.sun.com/thread.jspa?threadID=636414\">http://forums.sun.com/thread.jspa?threadID=636414</a></p>\n<p>=============================================================</p>\n<p>另外补充一点：</p>\n<p>引用：<a href=\"http://zhidao.baidu.com/question/94324055.html\">http://zhidao.baidu.com/question/94324055.html</a><br>作用就是 final的类不能被继承，不能让别人继承有什么好处?&nbsp;<br>意义就在于，安全性，如此这般：&nbsp;<br>Java自出生那天起就是“为人民服务”，这也就是为什么Java做不了病毒，也不一定非得是病毒，反正总之就是为了安全，人家Java的开发者目的就是不想让Java干这类危险的事儿，Java并不是操作系统本地语言，换句话说Java必须借助操作系统本身的力量才能做事，JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是Java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的，和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的，这不就成了核心病毒了么？&nbsp;<br>---&nbsp;<br>上面所述是最重要的，另外一个方面，上面2位老兄说的也都很对，就是不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了，就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性，如果随便能改了，那么Java编写的程序肯定就很不稳定，你可以保证自己不乱改，但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的，所以这个安全性是很重要的，Java和C++相比，优点之一就包括这一点；<br>---<br>原因绝对不只有这么多，因为如果这些个核心的类都能被随便操作的话，那是很恐怖的，会出现好多好多未知的错误，莫名其妙的错误....&nbsp;</p>\n<p>【转载】<a href=\"http://blog.csdn.net/fenglibing/article/details/5486449\">http://blog.csdn.net/fenglibing/article/details/5486449</a></p>\n</div>"
  },
  {
    "category": "javaBasic",
    "qes": "HashMap合集",
    "ans": "<div class=\"RichText ztext Post-RichText\"><h2><b>HashMap面试小抄</b></h2><blockquote> 本篇内容：4500+字<br> 建议阅读时间：9分钟<br> </blockquote><p>对于JAVA求职者来说，HashMap 可谓是重中之重，是面试必考点。然而 HashMap 的知识点非常多，复习起来花费精力很大，库森当年校招面试时就经历过这种痛苦，结合自己的面试经验，斗胆写一篇关于 HashMap 的面试专题文章，希望对小伙伴有所帮助!</p><h2><b>1. 存储结构</b> </h2><blockquote> HashMap的底层数据结构是什么？<br> </blockquote><p>在JDK1.7 和JDK1.8 中有所差别：</p><p>在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>在JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：</p><ul><li>当链表超过 8 且数据总量超过 64 才会转红黑树。<br> </li><li>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。<br> </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-acb81d194c6f522f26e4e798e776bda4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"815\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb\" width=\"815\" data-original=\"https://pic1.zhimg.com/v2-acb81d194c6f522f26e4e798e776bda4_r.jpg\"/></noscript><img src=\"https://pic1.zhimg.com/80/v2-acb81d194c6f522f26e4e798e776bda4_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"815\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"815\" data-original=\"https://pic1.zhimg.com/v2-acb81d194c6f522f26e4e798e776bda4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-acb81d194c6f522f26e4e798e776bda4_b.jpg\" data-lazy-status=\"ok\"></figure><p>更深入的面试问题，</p><blockquote> 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?<br> </blockquote><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p><p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p><blockquote><i>不用红黑树，用二叉查找树可以么?</i><br> </blockquote><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><blockquote> 为什么链表改为红黑树的阈值是 8?<br> </blockquote><p>是因为泊松分布，我们来看作者在源码中的注释：</p><div class=\"highlight\"><pre><code class=\"language-text\"> Because TreeNodes are about twice the size of regular nodes, we\n use them only when bins contain enough nodes to warrant use\n (see TREEIFY_THRESHOLD). And when they become too small (due to\n removal or resizing) they are converted back to plain bins.  In\n usages with well-distributed user hashCodes, tree bins are\n rarely used.  Ideally, under random hashCodes, the frequency of\n nodes in bins follows a Poisson distribution\n (http://en.wikipedia.org/wiki/Poisson_distribution) with a\n parameter of about 0.5 on average for the default resizing\n threshold of 0.75, although with a large variance because of\n resizing granularity. Ignoring variance, the expected\n occurrences of list size k are (exp(-0.5) pow(0.5, k) /\n factorial(k)). The first values are:\n 0:    0.60653066\n 1:    0.30326533\n 2:    0.07581633\n 3:    0.01263606\n 4:    0.00157952\n 5:    0.00015795\n 6:    0.00001316\n 7:    0.00000094\n 8:    0.00000006\n more: less than 1 in ten million\n</code></pre></div><p>翻译过来大概的意思是：理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循<b><a href=\"https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Poisson_distribution\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">泊松分布</a></b>，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为 8 时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了 8，是根据概率统计而选择的。</p><h3><b>字段结构</b></h3><blockquote> 默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？<br> </blockquote><p>回答这个问题前，我们来先看下HashMap的默认构造函数：</p><div class=\"highlight\"><pre><code class=\"language-text\">     int threshold;             // 容纳键值对的最大值\n     final float loadFactor;    // 负载因子\n     int modCount;  \n     int size;  \n</code></pre></div><p>Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：</p><ul><li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。<br> </li><li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。<br> </li></ul><p>我们来追溯下作者在源码中的注释（JDK1.7）：</p><div class=\"highlight\"><pre><code class=\"language-text\">As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.\n</code></pre></div><p>翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p><h2><b>2. 索引计算</b> </h2><blockquote> HashMap 中  key 的存储索引是怎么计算的？<br> </blockquote><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&amp;（length-1）计算得到存储的位置。看看源码的实现：</p><div class=\"highlight\"><pre><code class=\"language-text\">// jdk1.7\n方法一：\nstatic int hash(int h) {\n    int h = hashSeed;\n        if (0 != h &amp;&amp; k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n    h ^= k.hashCode(); // 为第一步：取hashCode值\n    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); \n    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n}\n方法二：\nstatic int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样\n     return h &amp; (length-1);  //第三步：取模运算\n}\n\n// jdk1.8\nstatic final int hash(Object key) {   \n     int h;\n     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    /* \n     h = key.hashCode() 为第一步：取hashCode值\n     h ^ (h &gt;&gt;&gt; 16)  为第二步：高位参与运算\n    */\n}\n\n</code></pre></div><p>这里的 Hash 算法本质上就是三步：<b>取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标</b>。其中，JDK1.7和1.8的不同之处，就在于第二步。我们来看下详细过程，以JDK1.8为例，n为table的长度。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1198\" data-rawheight=\"684\" class=\"origin_image zh-lightbox-thumb\" width=\"1198\" data-original=\"https://pic2.zhimg.com/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_r.jpg\"/></noscript><img src=\"https://pic2.zhimg.com/80/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1198\" data-rawheight=\"684\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1198\" data-original=\"https://pic2.zhimg.com/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_b.jpg\" data-lazy-status=\"ok\"></figure><p>扩展出以下几个问题，</p><blockquote> JDK1.8 为什么要 hashcode 异或其右移十六位的值？<br> </blockquote><p>因为在JDK 1.7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。 从速度、功效、质量来考虑，JDK1.8 优化了高位运算的算法，通过hashCode()的高16位异或低16位实现：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)。这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><blockquote> 为什么 hash 值要与length-1相与？<br> </blockquote><ul><li>把 hash 值对数组长度取模运算，模运算的消耗很大，没有位运算快。</li><li>当 length 总是 2 的n次方时，h&amp; (length-1) 运算等价于对length取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。</li></ul><blockquote> HashMap数组的长度为什么是 2 的幂次方？<br> </blockquote><p>这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外，2 的 N 次幂有助于减少碰撞的几率。如果 length 为2的幂次方，则 length-1 转化为二进制必定是11111……的形式，在与h的二进制与操作效率会非常的快，而且空间不浪费。我们来举个例子，看下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b30292aac94653d2b89cad181ca074e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"383\" data-rawheight=\"425\" class=\"content_image\" width=\"383\"/></noscript><img src=\"https://pic1.zhimg.com/80/v2-b30292aac94653d2b89cad181ca074e0_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"383\" data-rawheight=\"425\" class=\"content_image lazy\" width=\"383\" data-actualsrc=\"https://pic1.zhimg.com/v2-b30292aac94653d2b89cad181ca074e0_b.jpg\" data-lazy-status=\"ok\"></figure><p>当 length =15时，6 和 7 的结果一样，这样表示他们在 table 存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，4和5的结果也是一样，这样就会导致查询速度降低。</p><p>如果我们进一步分析，还会发现空间浪费非常大，以 length=15 为例，在 1、3、5、7、9、11、13、15 这八处没有存放数据。因为hash值在与14（即 1110）进行&amp;运算时，得到的结果最后一位永远都是0，即 0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的。</p><p><b>补充数组容量计算的小奥秘</b></p><p>HashMap 构造函数允许用户传入的容量不是  2  的  n  次方，因为它可以自动地将传入的容量转换为  2  的  n 次方。会取大于或等于这个数的 且最近的2次幂作为 table 数组的初始容量，使用<code>tableSizeFor(int)</code>方法，如 tableSizeFor(10) = 16（2 的 4 次幂），tableSizeFor(20) = 32（2 的 5 次幂），也就是说 table 数组的长度总是 2 的次幂。JDK1.8 源码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n &gt;&gt;&gt; 1;\n        n |= n &gt;&gt;&gt; 2;\n        n |= n &gt;&gt;&gt; 4;\n        n |= n &gt;&gt;&gt; 8;\n        n |= n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n/*\n解释：位或( | )\nint n = cap - 1; 让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。\n*/\n</code></pre></div><h2><b>3. put方法</b> </h2><blockquote> HashMap 的put方法流程？<br> </blockquote><p>简要流程如下：</p><ol><li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；<br> </li><li>如果数组是空的，则调用 resize 进行初始化；<br> </li><li>如果没有哈希冲突直接放在对应的数组下标里；<br> </li><li>如果冲突了，且 key 已经存在，就覆盖掉 value；<br> </li><li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；<br> </li><li>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。<br> </li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-22ad271660f124de749950ca1916fbb5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"695\" class=\"origin_image zh-lightbox-thumb\" width=\"665\" data-original=\"https://pic2.zhimg.com/v2-22ad271660f124de749950ca1916fbb5_r.jpg\"/></noscript><img src=\"https://pic2.zhimg.com/80/v2-22ad271660f124de749950ca1916fbb5_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"695\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"665\" data-original=\"https://pic2.zhimg.com/v2-22ad271660f124de749950ca1916fbb5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-22ad271660f124de749950ca1916fbb5_b.jpg\" data-lazy-status=\"ok\"></figure><p>详细分析，见JDK1.8HashMap 的 put 方法源码:</p><div class=\"highlight\"><pre><code class=\"language-text\"> public V put(K key, V value) {\n     // 对key的hashCode()做hash\n        return putVal(hash(key), key, value, false, true);\n    }\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n     // 步骤1：tab为空则创建\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n     // 步骤2：计算index，并对null做处理 \n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node&lt;K,V&gt; e; K k;\n            // 步骤3：节点key存在，直接覆盖value\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            // 步骤4：判断该链为红黑树\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            // 步骤5：该链为链表\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        //链表长度大于8转换为红黑树进行处理\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    // key已经存在直接覆盖value\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n     // 步骤6：超过最大容量 就扩容\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n// 第31行treeifyBin方法部分代码\nfinal void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {\n        int n, index; Node&lt;K,V&gt; e;\n     // static final int MIN_TREEIFY_CAPACITY = 64;\n     // 如果大于8但是数组容量小于64，就进行扩容\n        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)\n            resize();\n    \n }\n        \n        \n\n</code></pre></div><h3><b>扩展的问题</b></h3><blockquote> JDK1.7 和1.8 的put方法区别是什么？<br> </blockquote><p>区别在两处：</p><p>解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定条件，链表会转换为红黑树。</p><p>链表插入元素时，JDK1.7 使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是线程不安全的，具体原因会在另一篇文章分析。</p><h2><b>4. 扩容机制</b> </h2><blockquote> HashMap 的扩容方式？<br> </blockquote><p>Hashmap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 Hashmap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。</p><p>那扩容的具体步骤是什么？让我们看看源码。</p><p>先来看下JDK1.7 的代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">void resize(int newCapacity) {   //传入新的容量\n        Entry[] oldTable = table;    //引用扩容前的Entry数组\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {  //扩容前的数组大小如果已经达到最大(2^30)了\n            threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了\n            return;\n        }\n\n        Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组\n        transfer(newTable);                         //！！将数据转移到新的Entry数组里\n        table = newTable;                           //HashMap的table属性引用新的Entry数组\n        threshold = (int)(newCapacity * loadFactor);//修改阈值\n    }\n</code></pre></div><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><div class=\"highlight\"><pre><code class=\"language-text\">void transfer(Entry[] newTable) {\n        Entry[] src = table;                   //src引用了旧的Entry数组\n        int newCapacity = newTable.length;\n        for (int j = 0; j &lt; src.length; j++) { //遍历旧的Entry数组\n            Entry&lt;K,V&gt; e = src[j];             //取得旧Entry数组的每个元素\n            if (e != null) {\n                src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）\n                do {\n                    Entry&lt;K,V&gt; next = e.next;\n                    int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置\n                    e.next = newTable[i]; //标记[1]\n                    newTable[i] = e;      //将元素放在数组上\n                    e = next;             //访问下一个Entry链上的元素\n                } while (e != null);\n            }\n        }\n    }\n</code></pre></div><p>newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。</p><h3><b>JDK1.8的优化</b></h3><blockquote> 扩容在JDK1.8中有什么不一样？<br> </blockquote><p>JDK1.8做了两处优化：</p><ol><li>resize 之后，元素的位置在原来的位置，或者原来的位置 +oldCap (原来哈希表的长度）。不需要像 JDK1.7 的实现那样重新计算hash ，只需要看看原来的 hash 值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引 + oldCap ”。这个设计非常的巧妙，省去了重新计算 hash 值的时间。<br> 如下图所示，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。<br> </li></ol><p class=\"ztext-empty-paragraph\"><br></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c3b1ff00a544dc87d5b1be3acc8381db_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1632\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb\" width=\"1632\" data-original=\"https://pic4.zhimg.com/v2-c3b1ff00a544dc87d5b1be3acc8381db_r.jpg\"/></noscript><img src=\"https://pic4.zhimg.com/80/v2-c3b1ff00a544dc87d5b1be3acc8381db_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1632\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1632\" data-original=\"https://pic4.zhimg.com/v2-c3b1ff00a544dc87d5b1be3acc8381db_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c3b1ff00a544dc87d5b1be3acc8381db_b.jpg\" data-lazy-status=\"ok\"></figure><p>元素在重新计算 hash 之后，因为 n 变为 2倍，那么 n-1 的 mask 范围在高位多 1 bit(红色)，因此新的index就会发生这样的变化：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-832a4b53734c40500304945f2d8f6b85_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1064\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb\" width=\"1064\" data-original=\"https://pic2.zhimg.com/v2-832a4b53734c40500304945f2d8f6b85_r.jpg\"/></noscript><img src=\"https://pic2.zhimg.com/80/v2-832a4b53734c40500304945f2d8f6b85_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1064\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1064\" data-original=\"https://pic2.zhimg.com/v2-832a4b53734c40500304945f2d8f6b85_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-832a4b53734c40500304945f2d8f6b85_b.jpg\" data-lazy-status=\"ok\"></figure><ol><li>JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置（头插法）。JDK1.8 不会倒置，使用尾插法。</li></ol><p>下图为 16扩充为 32 的 resize 示意图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-42064a0899ee6ccf20e57880ab9b7592_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1268\" data-rawheight=\"730\" class=\"origin_image zh-lightbox-thumb\" width=\"1268\" data-original=\"https://pic3.zhimg.com/v2-42064a0899ee6ccf20e57880ab9b7592_r.jpg\"/></noscript><img src=\"https://pic3.zhimg.com/80/v2-42064a0899ee6ccf20e57880ab9b7592_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1268\" data-rawheight=\"730\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1268\" data-original=\"https://pic3.zhimg.com/v2-42064a0899ee6ccf20e57880ab9b7592_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-42064a0899ee6ccf20e57880ab9b7592_b.jpg\" data-lazy-status=\"ok\"></figure><p>感兴趣的小伙伴可以看下 JDK1.8 的 resize 源码：</p><div class=\"highlight\"><pre><code class=\"language-text\">final Node&lt;K,V&gt;[] resize() {\n        Node&lt;K,V&gt;[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap &gt; 0) {\n   // 超过最大值就不再扩充了，就只好随你碰撞去吧\n            if (oldCap &gt;= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n   // 没超过最大值，就扩充为原来的2倍\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1; // double threshold\n        }\n        else if (oldThr &gt; 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n  // 计算新的resize上限\n        if (newThr == 0) {\n\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                    (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\"，\"unchecked\"})\n        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n   // 把每个bucket都移动到新的buckets中\n            for (int j = 0; j &lt; oldCap; ++j) {\n                Node&lt;K,V&gt; e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else { // 链表优化重hash的代码块\n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do {\n                            next = e.next;\n       // 原索引\n                            if ((e.hash &amp; oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n       // 原索引+oldCap\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n      // 原索引放到bucket里\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n      // 原索引+oldCap放到bucket里\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n</code></pre></div><h2><b>5. 其他</b> </h2><blockquote> 还知道哪些hash算法？<br> </blockquote><p>Hash函数是指把一个大范围映射到一个小范围，目的往往是为了节省空间，使得数据容易保存。 比较出名的有MurmurHash、MD4、MD5等等。</p><blockquote> key 可以为 Null 吗?<br> </blockquote><p>可以，key 为 Null 的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</p><blockquote> 一般用什么作为HashMap的key?<br> </blockquote><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p><ul><li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</li><li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li></ul><blockquote> 用可变类当 HashMap 的 key 有什么问题?<br> </blockquote><p>hashcode 可能发生改变，导致 put 进去的值，无法 get 出。如下所示</p><div class=\"highlight\"><pre><code class=\"language-text\">HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = new HashMap&lt;&gt;();\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"hello\");\nObject objectValue = new Object();\nchangeMap.put(list, objectValue);\nSystem.out.println(changeMap.get(list));\nlist.add(\"hello world\");//hashcode发生了改变\nSystem.out.println(changeMap.get(list));\n</code></pre></div><p>输出值如下</p><div class=\"highlight\"><pre><code class=\"language-text\">java.lang.Object@74a14482\nnull\n</code></pre></div><h2><b>最后</b> </h2><p>以上便是 HashMap 的核心面试题了，限于篇幅原因，本文并没有讲到 HashMap 的线程不安全问题，后面会专门写一篇文章讲解，敬请期待呦！</p><h2><b>参考</b> </h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/2016/06/24/java-hashmap.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">Java 8系列之重新认识HashMap</a></b></p><p><b><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/64f6de3ffcc1\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">HashMap的loadFactor为什么是0.75？</a></b></p><p><b><a href=\"https://link.zhihu.com/?target=https%3A//juejin.cn/post/6844903588779524110\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">HashMap扩容拾遗</a></b></p><p>[<b><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chenssy/p/3521565.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">HashMap</a></b>](<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chenssy/p/3521565.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\"><span class=\"invisible\">https://www.</span><span class=\"visible\">cnblogs.com/chenssy/p/3</span><span class=\"invisible\">521565.html</span><span class=\"ellipsis\"></span></a>)</p><p><b><a href=\"https://zhuanlan.zhihu.com/p/76735726\" class=\"internal\" data-za-detail-view-id=\"1043\">HashMap面试指南</a></b></p></div>"
  },
  {
    "category": "javaBasic",
    "qes": "hashcode与equals的关系，是否会引发内存泄露",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <p><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>&nbsp; &nbsp;最近去面试了几家公司，被问到hashCode的作用，虽然回答出来了，但是自己还是对hashCode和equals的作用一知半解的，所以决定把它们研究一下。</span></p> \n<p><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>以前写程序一直没有注意hashCode的作用，一般都是覆盖了equals，缺没有覆盖hashCode，现在发现这是埋下了很多潜在的Bug！今天就来说一说hashCode和equals的作用。</span></p> \n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;先来试想一个场景，如果你想查找一个集合中是否包含某个对象，那么程序应该怎么写呢？通常的做法是逐一取出每个元素与要查找的对象一一比较，当发现两者进行equals比较结果相等时，则停止查找并返回true，否则，返回false。但是这个做法的一个缺点是当集合中的元素很多时，譬如有一万个元素，那么逐一的比较效率势必下降很快。于是有人发明了一种哈希算法来提高从该集合中查找元素的效率，这种方式将集合分成若干个存储区域（可以看成一个个桶），每个对象可以计算出一个哈希码，可以根据哈希码分组，每组分别对应某个存储区域，这样一个对象根据它的哈希码就可以分到不同的存储区域（不同的桶中）。如下图所示：<span style=\"white-space:pre\"></span></span></p> \n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <img src=\"https://img-blog.csdn.net/20140428143219703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlqaWVjYW8wMjI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src=\"\" alt=\"\"><br> </span></p> \n<p><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>实际的使用中，一个对象一般有key和value，可以根据key来计算它的hashCode。假设现在全部的对象都已经根据自己的hashCode值存储在不同的存储区域中了，那么现在查找某个对象（根据对象的key来查找），不需要遍历整个集合了，现在只需要计算要查找对象的key的hashCode，然后找到该hashCode对应的存储区域，在该存储区域中来查找就可以了，这样效率也就提升了很多。说了这么多相信你对hashCode的作用有了一定的了解，下面就来看看hashCode和equals的区别和联系。</span></p> \n<p><span style=\"font-size:18px\"><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"color:rgb(51,51,51); white-space:pre\"></span>在研究这个问题之前，首先说明一下JDK对equals(Object obj)和hashCode()这两个方法的定义和规范：</span><span style=\"font-family:Arial; line-height:25.694442749023438px\">在Java中任何一个对象都具备equals(Object obj)和hashCode()这两个方法，因为他们是在Object类中定义的。&nbsp;</span><span style=\"font-family:Arial; line-height:25.694442749023438px\">equals(Object obj)方法用来判断两个对象是否“相同”，如果“相同”则返回true，否则返回false。&nbsp;</span><span style=\"font-family:Arial; line-height:25.694442749023438px\">hashCode()方法返回一个int数，在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。&nbsp;</span></span></p> \n<p><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>下面是官方文档给出的一些说明：</span></span></p> \n<p><span style=\"font-size:18px\"><span style=\"font-family:Arial; line-height:25.694442749023438px\"></span></span></p> \n<pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\" style=\"width:1684px\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\">hashCode 的常规协定是：   </span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。   </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。   </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。   </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）   </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">  </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre>\n<span style=\"font-size:18px\"><br> <span style=\"white-space:pre\"></span>下面是我查阅了相关资料之后对以上的说明做的归纳总结：</span> \n<p></p> \n<p><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>1.若重写了equals(Object obj)方法，则有必要重写hashCode()方法。</span></span></p> \n<p><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>2.若两个对象equals(Object obj)返回true，则hashCode（）有必要也返回相同的int数。</span></span></p> \n<p><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>3.若<span style=\"font-family:Arial; line-height:25px\">两个对象equals(Object obj)返回false，则hashCode（）不一定返回不同的int数。</span></span></span></p> \n<p><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-family:Arial; line-height:25px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>4.若两个对象hashCode（）返回相同int数，则equals（Object obj）不一定返回true。</span></span></span></p> \n<p><span style=\"font-size:18px\"><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-family:Arial; line-height:25px\"><span style=\"white-space:pre\"></span>5.若</span></span><span style=\"font-family:Arial; line-height:25.694442749023438px\">两个对象hashCode（）返回不同int数，则equals（Object obj）一定返回false。</span></span></p> \n<p><span style=\"font-size:18px\"><span style=\"font-family:Arial\"><span style=\"line-height:25px\"><span style=\"white-space:pre\"></span>6.同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。<br> </span></span><span style=\"font-family:Arial; line-height:25.694442749023438px\"></span></span></p> \n<div>\n <span style=\"font-size:18px\"><br> </span>\n</div> \n<div>\n <span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>想要弄清楚以上六点，先要知道什么时候需要重写equals和hashCode。一般来说涉及到对象之间的比较大小就需要重写equals方法，但是为什么第一点说重写了equals就需要重写hashCode呢？实际上这只是一条规范，如果不这样做程序也可以执行，只不过会隐藏bug。一般一个类的对象如果会存储在HashTable，HashSet,HashMap等散列存储结构中，那么重写equals后最好也重写hashCode，否则会导致存储数据的不唯一性（存储了两个equals相等的数据）。而如果确定不会存储在这些散列结构中，则可以不重写hashCode。但是个人觉得还是重写比较好一点，谁能保证后期不会存储在这些结构中呢，况且重写了hashCode也不会降低性能，因为在线性结构（如ArrayList）中是不会调用hashCode，所以重写了也不要紧，也为后期的修改打了补丁。</span>\n</div> \n<div>\n <span style=\"font-size:18px\"><br> </span>\n</div> \n<div>\n <span style=\"font-size:18px\"><span style=\"white-space:pre\"></span>下面来看一张对象放入散列集合的流程图：</span>\n</div> \n<div> \n <p style=\"margin-top:0px; margin-bottom:0px; font-family:Helvetica\"><span style=\"font-size:18px\"><img src=\"\" alt=\"\"><br> </span></p> \n <p style=\"margin-top:0px; margin-bottom:0px; font-family:Helvetica\"><span style=\"font-size:18px\"><img src=\"https://img-blog.csdn.net/20140428143548328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlqaWVjYW8wMjI2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br> </span></p> \n <p style=\"margin-top:0px; margin-bottom:0px; font-family:Helvetica\"><span style=\"font-size:18px\">从上面的图中可以清晰地看到在存储一个对象时，先进行hashCode值的比较，然后进行equals的比较。可能现在你已经对上面的6点归纳有了一些认识。我们还可以通过JDK中得源码来认识一下具体hashCode和equals在代码中是如何调用的。</span></p> \n <p style=\"margin-top:0px; margin-bottom:0px; font-family:Helvetica\"><span style=\"font-size:18px\">HashSet.java&nbsp;</span></p> \n <p style=\"margin-top:0px; margin-bottom:0px; font-family:Helvetica\"></p> \n <pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(E e)</span> </span>{</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">return</span> map.put(e, PRESENT)==<span class=\"hljs-keyword\">null</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">    }</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre>\n <span style=\"font-size:18px\"><br> HashMap.java</span> \n <p style=\"margin-top:0px; margin-bottom:0px; font-family:Monaco\"></p> \n <pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> V <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(K key, V value)</span> </span>{</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        <span class=\"hljs-keyword\">if</span> (key == <span class=\"hljs-keyword\">null</span>)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">            <span class=\"hljs-keyword\">return</span> putForNullKey(value);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        <span class=\"hljs-keyword\">int</span> hash = hash(key.hashCode());</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        <span class=\"hljs-keyword\">int</span> i = indexFor(hash, table.length);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        <span class=\"hljs-keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"hljs-keyword\">null</span>; e = e.next) {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">            Object k;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">            <span class=\"hljs-keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">                V oldValue = e.value;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">                e.value = value;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">                e.recordAccess(<span class=\"hljs-keyword\">this</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">                <span class=\"hljs-keyword\">return</span> oldValue;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">            }</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        }</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        modCount++;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"17\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        addEntry(hash, key, value, i);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"18\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"19\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">    }</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre>\n <span style=\"font-size:18px\"><br> <br> </span> \n <p></p> \n</div> \n<p></p> \n<p><span style=\"font-size:18px\">最后再来看几个测试的例子吧：</span></p> \n<p><span style=\"font-size:18px\"><strong>测试一：</strong>覆盖equals（Object obj）但不覆盖hashCode（）,导致数据不唯一性</span></p> \n<p></p> \n<pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HashCodeTest</span> </span>{</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tCollection set = <span class=\"hljs-keyword\">new</span> HashSet();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tPoint p1 = <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tPoint p2 = <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(p1.equals(p2));</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tset.add(p1);   <span class=\"hljs-comment\">//(1)</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tset.add(p2);   <span class=\"hljs-comment\">//(2)</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tset.add(p1);   <span class=\"hljs-comment\">//(3)</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tIterator iterator = set.iterator();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">while</span> (iterator.hasNext()) {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\tObject object = iterator.next();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\tSystem.out.println(object);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"17\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"18\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"19\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"20\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Point</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"21\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"22\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"23\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"24\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Point</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"25\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">super</span>();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"26\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">this</span>.x = x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"27\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">this</span>.y = y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"28\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"29\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"30\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-meta\">@Override</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"31\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">equals</span><span class=\"hljs-params\">(Object obj)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"32\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == obj)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"33\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"34\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (obj == <span class=\"hljs-keyword\">null</span>)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"35\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"36\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (getClass() != obj.getClass())</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"37\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"38\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tPoint other = (Point) obj;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"39\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (x != other.x)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"40\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"41\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (y != other.y)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"42\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"43\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"44\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"45\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"46\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-meta\">@Override</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"47\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"48\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"x:\"</span> + x + <span class=\"hljs-string\">\",y:\"</span> + y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"49\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"50\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"51\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"52\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"></div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre>\n<span style=\"font-size:18px\"><br> <br> </span> \n<p></p> \n<p><span style=\"font-size:18px\">输出结果：</span></p> \n<p></p> \n<pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\"><span class=\"hljs-keyword\">true</span></span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">x:<span class=\"hljs-number\">1</span>,y:<span class=\"hljs-number\">1</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">x:<span class=\"hljs-number\">1</span>,y:<span class=\"hljs-number\">1</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"></div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre>\n<span style=\"font-size:18px\"><br> 原因分析：</span> \n<p></p> \n<p><span style=\"font-size:18px\">（1）当执行set.add(p1)时（1），集合为空，直接存入集合；</span></p> \n<p><span style=\"font-size:18px\">（2）当执行set.add(p2)时（2），首先判断该对象（p2）的hashCode值所在的存储区域是否有相同的hashCode，因为没有覆盖hashCode方法，所以jdk使用默认Object的hashCode方法，返回内存地址转换后的整数，因为不同对象的地址值不同，所以这里不存在与p2相同hashCode值的对象，因此jdk默认不同hashCode值，equals一定返回false，所以直接存入集合。</span></p> \n<p><span style=\"font-size:18px\">&nbsp;（3）当执行set.add(p1)时（3），时，因为p1已经存入集合，同一对象返回的hashCode值是一样的，继续判断equals是否返回true，因为是同一对象所以返回true。此时jdk认为该对象已经存在于集合中，所以舍弃。</span></p> \n<p><span style=\"font-size:18px\"><br> </span></p> \n<p><span style=\"font-size:18px\"><strong>测试二：</strong>覆盖hashCode方法，但不覆盖equals方法，仍然会导致数据的不唯一性</span></p> \n<p><span style=\"font-size:18px\">修改Point类：</span></p> \n<pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Point</span> </span>{</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Point</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">super</span>();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">this</span>.x = x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">this</span>.y = y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-meta\">@Override</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hashCode</span><span class=\"hljs-params\">()</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> prime = <span class=\"hljs-number\">31</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">1</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tresult = prime * result + x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tresult = prime * result + y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"17\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> result;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"18\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"19\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"20\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-meta\">@Override</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"21\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"22\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"x:\"</span> + x + <span class=\"hljs-string\">\",y:\"</span> + y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"23\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"24\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"25\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"26\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"></div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre>\n<span style=\"font-size:18px\"><br> 输出结果：</span>\n<pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\"><span class=\"hljs-keyword\">false</span></span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">x:<span class=\"hljs-number\">1</span>,y:<span class=\"hljs-number\">1</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">x:<span class=\"hljs-number\">1</span>,y:<span class=\"hljs-number\">1</span></div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre>\n<span style=\"font-size:18px\"><br> </span> \n<p></p> \n<p><span style=\"font-size:18px\">原因分析：</span></p> \n<p><span style=\"font-size:18px\">（1）当执行set.add(p1)时（1），集合为空，直接存入集合；</span></p> \n<p><span style=\"font-size:18px\">（2）当执行set.add(p2)时（2），首先判断该对象（p2）的hashCode值所在的存储区域是否有相同的hashCode，这里覆盖了hashCode方法，p1和p2的hashCode相等，所以继续判断equals是否相等，因为这里没有覆盖equals，默认使用'=='来判断，所以这里equals返回false，jdk认为是不同的对象，所以将p2存入集合。</span></p> \n<p><span style=\"font-size:18px\">&nbsp;（3）当执行set.add(p1)时（3），时，因为p1已经存入集合，同一对象返回的hashCode值是一样的，并且equals返回true。此时jdk认为该对象已经存在于集合中，所以舍弃。</span></p> \n<p><span style=\"font-size:18px\"><br> </span></p> \n<div>\n <strong><span style=\"font-size:18px\">综合上述两个测试，要想保证元素的唯一性，必须同时覆盖hashCode和equals才行。</span></strong>\n</div> \n<div>\n <span style=\"font-size:18px\">（注意：在HashSet中插入同一个元素（hashCode和equals均相等）时，会被舍弃，而在HashMap中插入同一个Key（Value 不同）时，原来的元素会被覆盖。）</span>\n</div> \n<div>\n <span style=\"font-size:18px\"><br> </span>\n</div> \n<div>\n <span style=\"font-size:18px\">测试三：在内存泄露问题</span>\n</div> \n<div>\n <pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HashCodeTest</span> </span>{</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tCollection set = <span class=\"hljs-keyword\">new</span> HashSet();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tPoint p1 = <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tPoint p2 = <span class=\"hljs-keyword\">new</span> Point(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tset.add(p1);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tset.add(p2);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tp2.setX(<span class=\"hljs-number\">10</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tp2.setY(<span class=\"hljs-number\">10</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tset.remove(p2);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tIterator iterator = set.iterator();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">while</span> (iterator.hasNext()) {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"17\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\tObject object = iterator.next();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"18\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\tSystem.out.println(object);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"19\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"20\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"21\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"22\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"23\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Point</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"24\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"25\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"26\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"27\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Point</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"28\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">super</span>();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"29\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">this</span>.x = x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"30\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">this</span>.y = y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"31\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"32\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"33\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"34\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getX</span><span class=\"hljs-params\">()</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"35\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"36\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"37\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"38\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"39\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setX</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"40\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">this</span>.x = x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"41\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"42\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"43\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"44\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getY</span><span class=\"hljs-params\">()</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"45\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"46\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"47\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"48\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"49\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setY</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> y)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"50\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">this</span>.y = y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"51\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"52\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"53\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"54\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-meta\">@Override</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"55\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hashCode</span><span class=\"hljs-params\">()</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"56\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> prime = <span class=\"hljs-number\">31</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"57\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">1</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"58\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tresult = prime * result + x;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"59\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tresult = prime * result + y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"60\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> result;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"61\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"62\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"63\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"64\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-meta\">@Override</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"65\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">equals</span><span class=\"hljs-params\">(Object obj)</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"66\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == obj)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"67\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"68\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (obj == <span class=\"hljs-keyword\">null</span>)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"69\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"70\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (getClass() != obj.getClass())</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"71\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"72\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tPoint other = (Point) obj;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"73\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (x != other.x)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"74\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"75\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">if</span> (y != other.y)</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"76\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"77\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"78\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"79\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"80\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"81\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-meta\">@Override</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"82\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"83\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"x:\"</span> + x + <span class=\"hljs-string\">\",y:\"</span> + y;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"84\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"85\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"86\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"87\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"></div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n <div>\n  <span style=\"font-size:18px\"><br> </span>\n </div> \n <span style=\"font-size:18px\">运行结果：<br> </span>\n <pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span style=\"font-size:18px;\">x:<span class=\"hljs-number\">1</span>,y:<span class=\"hljs-number\">1</span></span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">x:<span class=\"hljs-number\">10</span>,y:<span class=\"hljs-number\">10</span></div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n <div>\n  <span style=\"font-size:18px\"><br> </span>\n </div> \n <span style=\"font-size:18px\">原因分析：</span>\n</div> \n<div>\n <span style=\"font-size:18px\">&nbsp; &nbsp; 假设p1的hashCode为1，p2的hashCode为2，在存储时p1被分配在1号桶中，p2被分配在2号筒中。这时修改了p2中与计算hashCode有关的信息（x和y）,当调用remove(Object obj)时，首先会查找该hashCode值得对象是否在集合中。假设修改后的hashCode值为10（仍存在2号桶中）,这时查找结果空，jdk认为该对象不在集合中，所以不会进行删除操作。然而用户以为该对象已经被删除，导致该对象长时间不能被释放，造成内存泄露。解决该问题的办法是不要在执行期间修改与hashCode值有关的对象信息，如果非要修改，则必须先从集合中删除，更新信息后再加入集合中。</span>\n</div> \n<div>\n <span style=\"font-size:18px\"><br> </span>\n</div> \n<div>\n <span style=\"font-size:18px\">总结：</span>\n</div> \n<div>\n <span style=\"font-size:18px\">&nbsp; &nbsp;1.hashCode是为了提高在散列结构存储中查找的效率，在线性表中没有作用。</span>\n</div> \n<div>\n <span style=\"font-size:18px\">&nbsp; &nbsp;2.equals和hashCode需要同时覆盖。</span>\n</div> \n<div>\n <span style=\"font-size:18px\">&nbsp; &nbsp;3.<span style=\"font-family:Arial; line-height:25px\">若两个对象equals返回true，则hashCode有必要也返回相同的int数。</span></span>\n</div> \n<div> \n <p><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\">4</span>.若两个对象equals返回false，则hashCode不一定返回不同的int数,但为不相等的对象生成不同hashCode值可以提高<span style=\"white-space:pre\"> </span>哈希表的性能。</span></span></p> \n <p><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-size:18px\"><span style=\"white-space:pre\">5.</span>若两个对象hashCode返回相同int数，则equals不一定返回true。</span></span></p> \n <p><span style=\"font-size:18px\"><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"white-space:pre\">6</span>.若</span><span style=\"font-family:Arial; line-height:25.694442749023438px\">两个对象hashCode返回不同int数，则equals一定返回false。</span></span></p> \n <p><span style=\"font-family:Arial; line-height:25.694442749023438px\"><span style=\"font-size:18px\">&nbsp; &nbsp;7.<span style=\"font-family:Arial; line-height:25px\">同一对象在执行期间若已经存储在集合中，则不能修改影响hashCode值的相关信息，否则会导致内存泄露问题。</span></span></span></p> \n <span style=\"font-size:18px\"><br> </span>\n</div> \n<div>\n <br> \n</div>\n                </div><div><div></div></div>\n        </div>"
  },
  {
    "category": "javaBasic",
    "qes": "hashmap中的loadfactory为什么是0.75",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <p>轉自：&nbsp;<a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor\">http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor</a></p> \n<h1><a name=\"t0\"></a><a name=\"t0\"></a><a href=\"https://www.cnblogs.com/TravisGrady/p/10433462.html\" id=\"cb_post_title_url\">JDK1.8中的HashMap.HashTable, ConcurrentHashMap有什么区别？</a></h1> \n<p>JDK1.8中的HashMap，HashTable，ConcurrentHashMap有什么区别？</p> \n<p>答：HashMap是线程不安全的，底层采用数组+链表+红黑树的结构</p> \n<p>　　HashTable是线程安全的，因为使用了Synchronized锁住了整个table，底层采用了数组+链表</p> \n<p>　　ConcurrentHashMap是线程安全的，采用了CAS+同步锁Synchronized对链表头节点进行锁定，底层使用数组+链表+红黑树</p> \n<p>　　HashMap的key和value可以是null，其他两个不行。</p> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<p>在Java基础中，集合类是很关键的一块知识点，也是日常开发的时候经常会用到的。比如List、Map这些在代码中也是很常见的。</p> \n<p>个人认为，关于HashMap的实现，JDK的工程师其实是做了很多优化的，要说所有的JDK源码中，哪个类埋的彩蛋最多，那我想HashMap至少可以排前五。</p> \n<p>也正是因为如此，很多细节都容易被忽视，今天我们就来关注其中一个问题，那就是：</p> \n<p>为什么HashMap的负载因子设置成0.75，而不是1也不是0.5？这背后到底有什么考虑？</p> \n<p>大家千万不要小看这个问题，因为负载因子是HashMap中很重要的一个概念，也是高端面试的一个常考点。</p> \n<p>另外，这个值得设置，有些人会用错的，比如前几天我的《阿里巴巴Java开发手册建议创建HashMap时设置初始化容量，但是多少合适呢？》这篇文章中，就有读者这样回复：</p> \n<p><img alt=\"-w356\" src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5ob2xsaXNjaHVhbmcuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIwLzAyLzE1ODIzNDM0NDgxNDQ0LmpwZw?x-oss-process=image/format,png\">￼</p> \n<p><img alt=\"-w375\" src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5ob2xsaXNjaHVhbmcuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIwLzAyLzE1ODIzNDM0Nzg0NTcwLmpwZw?x-oss-process=image/format,png\">￼</p> \n<p>既然有人会尝试着去修改负载因子，那么到底改成1是不是合适呢？为什么HashMap不使用1作为负载因子的默认值呢？</p> \n<h3 id=\"什么是loadfactory\"><a name=\"t1\"></a><a name=\"t1\"></a><a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor?id=%E4%BB%80%E4%B9%88%E6%98%AFloadfactory\">什么是loadFactory</a></h3> \n<p>首先我们来介绍下什么是负载因子（loadFactory），如果读者对这部分已经有了解，那么可以直接跨过这一段。</p> \n<p>我们知道，第一次创建HashMap的时候，就会指定其容量（如果未显示制定，默认是16，详见<a href=\"http://www.hollischuang.com/archives/4320\">为啥HashMap的默认容量是16？</a>），那随着我们不断的向HashMap中put元素的时候，就有可能会超过其容量，那么就需要有一个扩容机制。</p> \n<p>所谓扩容，就是扩大HashMap的容量:</p> \n<pre><code class=\"hljs csharp\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addEntry</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">int</span> hash, K key, V <span class=\"hljs-keyword\">value</span>, <span class=\"hljs-keyword\">int</span> bucketIndex</span>)</span> {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">    <span class=\"hljs-keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"hljs-literal\">null</span> != table[bucketIndex])) {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        resize(<span class=\"hljs-number\">2</span> * table.length);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        hash = (<span class=\"hljs-literal\">null</span> != key) ? hash(key) : <span class=\"hljs-number\">0</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">        bucketIndex = indexFor(hash, table.length);        }</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">    createEntry(hash, key, <span class=\"hljs-keyword\">value</span>, bucketIndex);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li></ol></code>复制ErrorOK!<div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>从代码中我们可以看到，在向HashMap中添加元素过程中，如果&nbsp;<code>元素个数（size）超过临界值（threshold）</code>&nbsp;的时候，就会进行自动扩容（resize），并且，在扩容之后，还需要对HashMap中原有元素进行rehash，即将原来通中的元素重新分配到新的桶中。</p> \n<p>在HashMap中，临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）。</p> \n<p>loadFactor是装载因子，表示HashMap满的程度，默认值为0.75f，也就是说默认情况下，当HashMap中元素个数达到了容量的3/4的时候就会进行自动扩容。（相见<a href=\"http://www.hollischuang.com/archives/2416\">HashMap中傻傻分不清楚的那些概念</a>）</p> \n<h3 id=\"为什么要扩容\"><a name=\"t2\"></a><a name=\"t2\"></a><a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor?id=%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%A9%E5%AE%B9\">为什么要扩容</a></h3> \n<p>还记得前面我们说过，HashMap在扩容到过程中不仅要对其容量进行扩充，还需要进行rehash！所以，这个过程其实是很耗时的，并且Map中元素越多越耗时。</p> \n<p>rehash的过程相当于对其中所有的元素重新做一遍hash，重新计算要分配到那个桶中。</p> \n<p>那么，有没有人想过一个问题，既然这么麻烦，为啥要扩容？HashMap不是一个数组链表吗？不扩容的话，也是可以无限存储的呀。为啥要扩容？</p> \n<p>这其实和哈希碰撞有关。</p> \n<p><a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor?id=%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E\">哈希碰撞</a></p> \n<p>我们知道，HashMap其实是底层基于哈希函数实现的，但是哈希函数都有如下一个基本特性：根据同一哈希函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</p> \n<p>两个不同的输入值，根据同一散列函数计算出的散列值相同的现象叫做碰撞。</p> \n<p>衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。</p> \n<p>而为了解决哈希碰撞，有很多办法，其中比较常见的就是链地址法，这也是HashMap采用的方法。详见<a href=\"http://www.hollischuang.com/archives/2091\">全网把Map中的hash()分析的最透彻的文章，别无二家。</a></p> \n<p>HashMap将数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。</p> \n<p><img alt=\"-w648\" src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5ob2xsaXNjaHVhbmcuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIwLzAyLzE1ODIzNDQ3OTE2NjY2LmpwZw?x-oss-process=image/format,png\">￼</p> \n<p>HashMap基于链表的数组的数据结构实现的</p> \n<p>我们在向HashMap中put元素的时候，就需要先定外到是数组中的哪条链表，然后把这个元素挂在这个链表的后面。</p> \n<p>当我们从HashMap中get元素的时候，也是需要定位到是数组中的哪条链表，然后再逐一遍历链表中的元素，直到查找到需要的元素为止。</p> \n<p>可见，HashMap通过链表的数组这种结构，解决了hash冲突的问题。</p> \n<p>但是，如果一个HashMap中冲突太高，那么数组的链表就会退化为链表。这时候查询速度会大大降低。</p> \n<p><img alt=\"-w773\" src=\"https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5ob2xsaXNjaHVhbmcuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIwLzAyLzE1ODIzNDU5MTI4ODU3LmpwZw?x-oss-process=image/format,png\">￼</p> \n<p>所以，为了保证HashMap的读取的速度，我们需要想办法尽量保证HashMap的冲突不要太高。</p> \n<p><a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor?id=%E6%89%A9%E5%AE%B9%E9%81%BF%E5%85%8D%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E\">扩容避免哈希碰撞</a></p> \n<p>那么如何能有效的避免哈希碰撞呢？</p> \n<p>我们先反向思维一下，你认为什么情况会导致HashMap的哈希碰撞比较多？</p> \n<p>无外乎两种情况：</p> \n<p>1、容量太小。容量小，碰撞的概率就高了。狼多肉少，就会发生争强。</p> \n<p>2、hash算法不够好。算法不合理，就可能都分到同一个或几个桶中。分配不均，也会发生争强。</p> \n<p>所以，解决HashMap中的哈希碰撞也是从这两方面入手。</p> \n<p>这两点在HashMap中都有很好的提现。两种方法相结合，<strong>在合适的时候扩大数组容量，再通过一个合适的hash算法计算元素分配到哪个数组中，就可以大大的减少冲突的概率。就能避免查询效率低下的问题。</strong></p> \n<h3 id=\"为什么默认loadfactory是075\"><a name=\"t3\"></a><a name=\"t3\"></a><a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor?id=%E4%B8%BA%E4%BB%80%E4%B9%88%E9%BB%98%E8%AE%A4loadfactory%E6%98%AF075\">为什么默认loadFactory是0.75</a></h3> \n<p>至此，我们知道了loadFactory是HashMap中的一个重要概念，他表示这个HashMap最大的满的程度。</p> \n<p>为了避免哈希碰撞，HashMap需要在合适的时候进行扩容。那就是当其中的元素个数达到临界值的时候，而这个临界值前面说过和loadFactory有关，换句话说，设置一个合理的loadFactory，可以有效的避免&#8203;哈希冲突。</p> \n<p>那么，到底loadFactory设置成多少算合适呢？</p> \n<p>这个值现在在JDK的源码中是0.75:</p> \n<pre><code class=\"hljs php\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-comment\"><span class=\"hljs-comment\">/**</span></span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-comment\"> * The load factor used when none specified in constructor.</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-comment\"> */</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-built_in\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"hljs-number\">0.75</span>f;</div></div></li></ol></code>复制ErrorOK!<div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>那么，为什么选择0.75呢？背后有什么考虑？为什么不是1，不是0.8？不是0.5，而是0.75呢？</p> \n<p>在JDK的官方文档中，有这样一段描述描述：</p> \n<blockquote> \n <p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put).</p> \n</blockquote> \n<p>大概意思是：一般来说，默认的负载因子(0.75)在时间和空间成本之间提供了很好的权衡。更高的值减少了空间开销，但增加了查找成本(反映在HashMap类的大多数操作中，包括get和put)。</p> \n<p>试想一下，如果我们把负载因子设置成1，容量使用默认初始值16，那么表示一个HashMap需要在\"满了\"之后才会进行扩容。</p> \n<p>那么在HashMap中，最好的情况是这16个元素通过hash算法之后分别落到了16个不同的桶中，否则就必然发生哈希碰撞。而且随着元素越多，哈希碰撞的概率越大，查找速度也会越低。</p> \n<p><a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor?id=_075%E7%9A%84%E6%95%B0%E5%AD%A6%E4%BE%9D%E6%8D%AE\">0.75的数学依据</a></p> \n<p>另外，我们可以通过一种数学思维来计算下这个值是多少合适。&#8203;</p> \n<p>我们假设一个bucket空和非空的概率为0.5，我们用s表示容量，n表示已添加元素个数。</p> \n<p>用s表示添加的键的大小和n个键的数目。根据二项式定理，桶为空的概率为:</p> \n<pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">P</span>(<span class=\"hljs-number\">0</span>) = C(n, <span class=\"hljs-number\">0</span>) * (<span class=\"hljs-number\">1</span>/s)^<span class=\"hljs-number\">0</span> * (<span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">1</span>/s)^(n - <span class=\"hljs-number\">0</span>)</code>复制ErrorOK!<div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>因此，如果桶中元素个数小于以下数值，则桶可能是空的：</p> \n<pre><code class=\"hljs lisp\">log(<span class=\"hljs-number\">2</span>)/log(<span class=\"hljs-name\">s/</span>(<span class=\"hljs-name\">s</span> - <span class=\"hljs-number\">1</span>))</code>复制ErrorOK!<div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>当s趋于无穷大时，如果增加的键的数量使P(0) = 0.5，那么n/s很快趋近于log(2):</p> \n<pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">log</span>(<span class=\"hljs-number\">2</span>) ~ <span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">693</span>...</code>复制ErrorOK!<div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>所以，合理值大概在0.7左右。</p> \n<p>当然，这个数学计算方法，并不是在Java的官方文档中提现的，我们也无从考察到底有没有这层考虑，就像我们根本不知道鲁迅写文章时候怎么想的一样，只能推测。这个推测来源于Stack Overflor（<a href=\"https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap%EF%BC%89\">https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap）</a></p> \n<p><a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor?id=_075%E7%9A%84%E5%BF%85%E7%84%B6%E5%9B%A0%E7%B4%A0\">0.75的必然因素</a></p> \n<p>理论上我们认为负载因子不能太大，不然会导致大量的哈希冲突，也不能太小，那样会浪费空间。</p> \n<p>通过一个数学推理，测算出这个数值在0.7左右是比较合理的。</p> \n<p>那么，为什么最终选定了0.75呢？</p> \n<p>还记得前面我们提到过一个公式吗，就是<code>临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）</code>。</p> \n<p>我们在《<a href=\"http://www.hollischuang.com/archives/4320\">为啥HashMap的默认容量是16？</a>》中介绍过，根据HashMap的扩容机制，他会保证capacity的值永远都是2的幂。</p> \n<p>那么，为了保证<code>负载因子（loadFactor） * 容量（capacity）</code>的结果是一个整数，这个值是0.75(3/4)比较合理，因为这个数和任何2的幂乘积结果都是整数。</p> \n<h3 id=\"总结\"><a name=\"t4\"></a><a name=\"t4\"></a><a href=\"http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/hashmap-default-loadfactor?id=%E6%80%BB%E7%BB%93\">总结</a></h3> \n<p>HashMap是一种K-V结构，为了提升其查询及插入的速度，底层采用了链表的数组这种数据结构实现的。</p> \n<p>但是因为在计算元素所在的位置的时候，需要使用hash算法，而HashMap采用的hash算法就是链地址法。这种方法有两个极端。</p> \n<p>如果HashMap中哈希冲突概率高，那么HashMap就会退化成链表（不是真的退化，而是操作上像是直接操作链表），而我们知道，链表最大的缺点就是查询速度比较慢，他需要从表头开始逐一遍历。</p> \n<p>所以，为了避免HashMap发生大量的哈希冲突，所以需要在适当的时候对其进行扩容。</p> \n<p>而扩容的条件是元素个数达到临界值时。HashMap中临界值的计算方法：</p> \n<pre><code class=\"hljs\">临界值（threshold） = 负载因子（loadFactor） * 容量（capacity）</code>复制ErrorOK!<div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>其中负载因子表示一个数组可以达到的最大的满的程度。这个值不宜太大，也不宜太小。</p> \n<p>loadFactory太大，比如等于1，那么就会有很高的哈希冲突的概率，会大大降低查询速度。</p> \n<p>loadFactory太小，比如等于0.5，那么频繁扩容没，就会大大浪费空间。</p> \n<p>所以，这个值需要介于0.5和1之间。根据数学公式推算。这个值在log(2)的时候比较合理。</p> \n<p>另外，为了提升扩容效率，HashMap的容量（capacity）有一个固定的要求，那就是一定是2的幂。</p> \n<p>所以，如果loadFactor是3/4的话，那么和capacity的乘积结果就可以是一个整数。</p> \n<p>所以，一般情况下，我们不建议修改loadFactory的值，除非特殊原因。</p> \n<p>比如我明确的知道我的Map只存5个kv，并且永远不会改变，那么可以考虑指定loadFactory。</p> \n<p>但是其实我也不建议这样用。我们完全可以通过指定capacity达到这样的目的。详见<a href=\"http://www.hollischuang.com/archives/4320\">为啥HashMap的默认容量是16？</a></p> \n<p>参考资料：</p> \n<p><a href=\"https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap\">https://stackoverflow.com/questions/10901752/what-is-the-significance-of-load-factor-in-hashmap</a></p> \n<p><a href=\"https://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html\">https://docs.oracle.com/javase/6/docs/api/java/util/HashMap.html</a></p> \n<p><a href=\"https://preshing.com/20110504/hash-collision-probabilities/\">https://preshing.com/20110504/hash-collision-probabilities/</a></p>\n                </div><div><div></div></div>\n        </div>"
  },
  {
    "category": "javaBasic",
    "qes": "定义java实体类时为什么继承Serializable接口",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <p>&nbsp; &nbsp; &nbsp; &nbsp;首先我们要明确到底什么是Serializable接口：一个对象序列化的接口，一个类只有实现了Serializable接口，他的对象才能够被序列化</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp;那么什么是序列化？序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp;为什么要序列化对象：1、把对象转换为字节序列的过程称为对象的序列化2、把字节序列恢复为对象的过程称为对象的反序列化</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp;什么情况下需要序列化：当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化。</p> \n<p>&nbsp; &nbsp; &nbsp; 为什么要继承Serialilzable。因为存储对象在存储介质中，以便在下次使用的时候，可以很快捷的重建一个副本。</p> \n<p>&nbsp; &nbsp; &nbsp;我们日常将数据存储在mysq等数据库中，为什么非要序列化才能存储？因为Serializable接口实际上就是一个标识的接口。在java中起到传递信息给jvm的，通知jvm，这个类我就不做序列化了，由jvm来帮我序列化</p> \n<p>&nbsp; &nbsp; &nbsp; Serializable接口就是java提供用来进行高效率的异地共享实例对象的机制，实现这个接口即可。</p> \n<p>&nbsp; &nbsp; &nbsp; 序列化和反序列化的操作过程十分简单。只需要将实体类写入到文件中，然后从文件中进行恢复，恢复后得到的内容和之前完全一样。其中有一个起到很大作用的变量叫做SerialVersionUID。这个serialVersionUID的详细的工作机制是：在序列化的时候系统将serialVersionUID写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的serialVersionUID是否跟当前的文件的serialVersionUID是否一致，如果一直则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会发生crash，并且回报出错误。</p>\n  <p><div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<p>　　工作中我们经常在进行持久化操作和返回数据时都会使用到javabean来统一封装参数，方便操作，一般我们也都会实现Serializable接口，那么问题来了，首先：为什么要进行序列化；其次：每个实体bean都必须实现serializabel接口吗？最后：我做一些项目的时候，没有实现序列化，同样没什么影响，到底什么时候应该进行序列化操作呢？</p>\n<p>　　网上找了很多资料，但是感觉大都没有说的很清楚，所以结合自己的理解做一下总结。</p>\n<p>　　首先第一个问题，实现序列化的两个原因：1、将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；2、按值将对象从一个应用程序域发送至另一个应用程序域。实现serializabel接口的作用是就是可以把对象存到字节流，然后可以恢复，所以你想如果你的对象没实现序列化怎么才能进行持久化和网络传输呢，要持久化和网络传输就得转为字节流，所以在分布式应用中及设计数据持久化的场景中，你就得实现序列化。</p>\n<p>　　第二个问题，是不是每个实体bean都要实现序列化，答案其实还要回归到第一个问题，那就是你的bean是否需要持久化存储媒体中以及是否需要传输给另一个应用，没有的话就不需要，例如我们利用fastjson将实体类转化成json字符串时，并不涉及到转化为字节流，所以其实跟序列化没有关系。</p>\n<p>　　第三个问题，有的时候并没有实现序列化，依然可以持久化到数据库。这个其实我们可以看看实体类中常用的数据类型，例如Date、String等等，它们已经实现了序列化，而一些基本类型，数据库里面有与之对应的数据结构，从我们的类声明来看，我们没有实现serializabel接口，其实是在声明的各个不同变量的时候，由具体的数据类型帮助我们实现了序列化操作。</p>\n<p>　　另外需要注意的是，在NoSql数据库中，并没有与我们java基本类型对应的数据结构，所以在往nosql数据库中存储时，我们就必须将对象进行序列化，同时在网络传输中我们要注意到两个应用中javabean的serialVersionUID要保持一致，不然就不能正常的进行反序列化。</p>\n</div></p>              </div><div><div></div></div>\n        </div>"
  },
  {
    "category": "javaBasic",
    "qes": "Java基础之接口与抽象类的区别",
    "ans": "<div class=\"RichText ztext Post-RichText\"><h3>1、基本语法区别</h3><p>Java中接口和抽象类的定义语法分别为interface与abstract关键字。</p><p><b>抽象类</b>：在Java中被abstract关键字修饰的类称为抽象类，被abstract关键字修饰的方法称为抽象方法，抽象方法只有方法的声明，没有方法体。抽象类的特点：</p><p>a、抽象类不能被实例化只能被继承；</p><p>b、包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法；</p><p>c、抽象类中的抽象方法的修饰符只能为public或者protected，默认为public；</p><p>d、一个子类继承一个抽象类，则子类必须实现父类抽象方法，否则子类也必须定义为抽象类；</p><p>e、抽象类可以包含属性、方法、构造方法，但是构造方法不能用于实例化，主要用途是被子类调用。</p><p><b><i>接口</i>：</b>Java中接口使用interface关键字修饰，特点为:</p><p>a、接口可以包含变量、方法；变量被隐士指定为public static final，方法被隐士指定为public abstract（JDK1.8之前）；</p><p>b、接口支持多继承，即一个接口可以extends多个接口，间接的解决了Java中类的单继承问题；</p><p>c、一个类可以实现多个接口；</p><p>d、JDK1.8中对接口增加了新的特性：（1）、默认方法（default method）：JDK 1.8允许给接口添加非抽象的方法实现，但必须使用default关键字修饰；定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用；如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法；（2）、静态方法（static method）：JDK 1.8中允许使用static关键字修饰一个方法，并提供实现，称为接口静态方法。接口静态方法只能通过接口调用（接口名.静态方法名）。</p><p><b>如下例子所示：</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">Person</span><span class=\"o\">{</span>\n  <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">=</span><span class=\"n\">10</span><span class=\"o\">;</span>\n  <span class=\"c1\">//JDK1.8\n</span><span class=\"c1\"></span>    <span class=\"k\">default</span> <span class=\"kt\">void</span> <span class=\"nf\">sayHello</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">\"Hello World\"</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">say</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">Person</span><span class=\"o\">{</span>\n  <span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kt\">void</span> <span class=\"nf\">say</span><span class=\"o\">();</span>\n  <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">eat</span><span class=\"o\">(){};</span>\n<span class=\"o\">}</span></code></pre></div><p>如上述代码所示：</p><p>接口只能是功能的定义，而抽象类既可以为功能的定义也可以为功能的实现。 </p><h3>2、面试题：接口与抽象类的区别</h3><p><b>相同点</b></p><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><p><b>不同点</b></p><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><p>（4）接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</p></div>"
  },
  {
    "category": "javaBasic",
    "qes": "Java中什么时候使用extends，什么时候使用implements",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <span style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\">我一直有个误区，认为extends是专门给类用的，implement是专门给interface用的。近日在coding是发现项目框架中有如下代码，感到有些奇怪，所以今天调查了一下。</span> \n<div class=\"dp-highlighter bg_java\" style=\"font-family:Consolas,'Courier New',Courier,mono,serif; background-color:rgb(231,229,220); width:687.04541015625px; overflow:auto; padding-top:1px; margin:18px 0px!important; color:rgb(51,51,51); line-height:26px\"> \n <div class=\"bar\" style=\"padding-left:45px\"> \n  <div class=\"tools\" style=\"padding:3px 8px 10px 10px; font-size:9px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left-width:3px; border-left-style:solid; border-left-color:rgb(108,226,108)\"> \n   <strong>[java]</strong>&nbsp;\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"ViewSource\" title=\"view plain\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">view plain</a>\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"CopyToClipboard\" title=\"copy\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">copy</a> \n   <div style=\"position:absolute; left:498px; top:433px; width:19px; height:19px; z-index:99\"> \n   </div> \n  <div style=\"position: absolute; left: 613px; top: 272px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_1\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_1\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=1&amp;width=16&amp;height=16\" wmode=\"transparent\"></div><div style=\"position: absolute; left: 613px; top: 272px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_7\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_7\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=7&amp;width=16&amp;height=16\" wmode=\"transparent\"></div></div> \n </div> \n <ol start=\"1\" class=\"dp-j\" style=\"margin:0px 0px 1px 45px!important; padding:0px; border:none; list-style-position:initial; background-color:rgb(255,255,255); color:rgb(92,92,92)\"><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">public</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;</span><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">interface</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;Interface1&nbsp;</span><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">extends</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;Interface2，...，InterfaceN{&nbsp;&nbsp;</span></span></li><li style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span class=\"comment\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit\">//&nbsp;TODO</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;&nbsp;</span></span></li><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\">}&nbsp;&nbsp;</span></li></ol> \n</div> \n<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> 调查发现，有如下几种规则：</p> \n<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> 1.&nbsp;<span style=\"font-family:arial,宋体,sans-serif\"><span style=\"line-height:24px\">&nbsp;</span></span><span style=\"white-space:pre-wrap\">类继承类时，只能是单继承：使用 extends ，例如：</span></p> \n<div class=\"dp-highlighter bg_java\" style=\"font-family:Consolas,'Courier New',Courier,mono,serif; background-color:rgb(231,229,220); width:687.04541015625px; overflow:auto; padding-top:1px; margin:18px 0px!important; color:rgb(51,51,51); line-height:26px\"> \n <div class=\"bar\" style=\"padding-left:45px\"> \n  <div class=\"tools\" style=\"padding:3px 8px 10px 10px; font-size:9px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left-width:3px; border-left-style:solid; border-left-color:rgb(108,226,108)\"> \n   <strong>[java]</strong>&nbsp;\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"ViewSource\" title=\"view plain\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">view plain</a>\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"CopyToClipboard\" title=\"copy\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">copy</a> \n   <div style=\"position:absolute; left:498px; top:617px; width:19px; height:19px; z-index:99\"> \n   </div> \n  <div style=\"position: absolute; left: 613px; top: 458px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_2\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_2\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=2&amp;width=16&amp;height=16\" wmode=\"transparent\"></div><div style=\"position: absolute; left: 613px; top: 458px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_8\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_8\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=8&amp;width=16&amp;height=16\" wmode=\"transparent\"></div></div> \n </div> \n <ol start=\"1\" class=\"dp-j\" style=\"margin:0px 0px 1px 45px!important; padding:0px; border:none; list-style-position:initial; background-color:rgb(255,255,255); color:rgb(92,92,92)\"><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">public</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;</span><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">class</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;A&nbsp;</span><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">extends</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;B{&nbsp;&nbsp;</span></span></li><li style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span class=\"comment\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit\">//&nbsp;TODO</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;&nbsp;</span></span></li><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\">}&nbsp;&nbsp;</span></li></ol> \n</div> \n<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> </p> \n<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> 2. 类实现接口，<span style=\"white-space:pre-wrap\">多实现： 使用 implements <span style=\"font-family:Arial,Verdana,sans-serif; white-space:normal\"> ，<span style=\"font-family:Arial; white-space:pre-wrap\">例如：</span></span></span></p> \n<div class=\"dp-highlighter bg_html\" style=\"font-family:Consolas,'Courier New',Courier,mono,serif; background-color:rgb(231,229,220); width:687.04541015625px; overflow:auto; padding-top:1px; margin:18px 0px!important; color:rgb(51,51,51); line-height:26px\"> \n <div class=\"bar\" style=\"padding-left:45px\"> \n  <div class=\"tools\" style=\"padding:3px 8px 10px 10px; font-size:9px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left-width:3px; border-left-style:solid; border-left-color:rgb(108,226,108)\"> \n   <strong>[html]</strong>&nbsp;\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"ViewSource\" title=\"view plain\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">view plain</a>\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"CopyToClipboard\" title=\"copy\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">copy</a> \n   <div style=\"position:absolute; left:498px; top:767px; width:19px; height:19px; z-index:99\"> \n   </div> \n  <div style=\"position: absolute; left: 616px; top: 618px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_3\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_3\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=3&amp;width=16&amp;height=16\" wmode=\"transparent\"></div><div style=\"position: absolute; left: 616px; top: 618px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_9\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_9\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=9&amp;width=16&amp;height=16\" wmode=\"transparent\"></div></div> \n </div> \n <ol start=\"1\" class=\"dp-xml\" style=\"margin:0px 0px 1px 45px!important; padding:0px; border:none; list-style-position:initial; background-color:rgb(255,255,255); color:rgb(92,92,92)\"><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">public&nbsp;class&nbsp;A&nbsp;implements&nbsp;Interface1，...，InterfaceN{&nbsp;&nbsp;</span></span></li><li style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\">//&nbsp;TODO&nbsp;&nbsp;</span></li><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\">}&nbsp;&nbsp;</span></li></ol> \n</div> \n<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> 3. 类继承类并且实现接口，可以实现一个类和多个接口，同时使用<span style=\"white-space:pre-wrap\">extends 和implement，例如：</span></p> \n<div class=\"dp-highlighter bg_html\" style=\"font-family:Consolas,'Courier New',Courier,mono,serif; background-color:rgb(231,229,220); width:687.04541015625px; overflow:auto; padding-top:1px; margin:18px 0px!important; color:rgb(51,51,51); line-height:26px\"> \n <div class=\"bar\" style=\"padding-left:45px\"> \n  <div class=\"tools\" style=\"padding:3px 8px 10px 10px; font-size:9px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left-width:3px; border-left-style:solid; border-left-color:rgb(108,226,108)\"> \n   <strong>[html]</strong>&nbsp;\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"ViewSource\" title=\"view plain\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">view plain</a>\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"CopyToClipboard\" title=\"copy\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">copy</a> \n   <div style=\"position:absolute; left:498px; top:913px; width:19px; height:19px; z-index:99\"> \n   </div> \n  <div style=\"position: absolute; left: 616px; top: 762px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_4\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_4\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=4&amp;width=16&amp;height=16\" wmode=\"transparent\"></div><div style=\"position: absolute; left: 616px; top: 762px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_10\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_10\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=10&amp;width=16&amp;height=16\" wmode=\"transparent\"></div></div> \n </div> \n <ol start=\"1\" class=\"dp-xml\" style=\"margin:0px 0px 1px 45px!important; padding:0px; border:none; list-style-position:initial; background-color:rgb(255,255,255); color:rgb(92,92,92)\"><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">public&nbsp;class&nbsp;A&nbsp;extends&nbsp;B&nbsp;implements&nbsp;Interface1，...，InterfaceN{&nbsp;&nbsp;</span></span></li><li style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\">//&nbsp;TODO&nbsp;&nbsp;</span></li><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\">}&nbsp;&nbsp;</span></li></ol> \n</div> \n<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> </p> \n<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> 4.<span style=\"white-space:pre-wrap\"></span><span style=\"white-space:pre-wrap\">接口继承接口时，多继承：使用 extends ，例如：</span></p> \n<div class=\"dp-highlighter bg_java\" style=\"font-family:Consolas,'Courier New',Courier,mono,serif; background-color:rgb(231,229,220); width:687.04541015625px; overflow:auto; padding-top:1px; margin:18px 0px!important; color:rgb(51,51,51); line-height:26px\"> \n <div class=\"bar\" style=\"padding-left:45px\"> \n  <div class=\"tools\" style=\"padding:3px 8px 10px 10px; font-size:9px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left-width:3px; border-left-style:solid; border-left-color:rgb(108,226,108)\"> \n   <strong>[java]</strong>&nbsp;\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"ViewSource\" title=\"view plain\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">view plain</a>\n   <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"CopyToClipboard\" title=\"copy\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">copy</a> \n   <div style=\"position:absolute; left:498px; top:1070px; width:19px; height:19px; z-index:99\"> \n   </div> \n  <div style=\"position: absolute; left: 613px; top: 922px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_5\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_5\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=5&amp;width=16&amp;height=16\" wmode=\"transparent\"></div><div style=\"position: absolute; left: 613px; top: 922px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_11\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_11\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=11&amp;width=16&amp;height=16\" wmode=\"transparent\"></div></div> \n </div> \n <ol start=\"1\" class=\"dp-j\" style=\"margin:0px 0px 1px 45px!important; padding:0px; border:none; list-style-position:initial; background-color:rgb(255,255,255); color:rgb(92,92,92)\"><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">public</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;</span><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">interface</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;Interface1&nbsp;</span><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">extends</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;Interface2，...，InterfaceN{&nbsp;&nbsp;</span></span></li><li style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span class=\"comment\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit\">//&nbsp;TODO</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;&nbsp;</span></span></li><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\">}&nbsp;&nbsp;</span></li></ol> \n</div> \n<div style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> \n <br> \n</div> \n<div style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\">\n  最后要说明的是，接口是不能implements接口的，否则会出现语法错误，例如：\n</div> \n<div style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> \n <br> \n <div class=\"dp-highlighter bg_java\" style=\"font-family:Consolas,'Courier New',Courier,mono,serif; font-size:12px; background-color:rgb(231,229,220); width:687.04541015625px; overflow:auto; padding-top:1px; margin:18px 0px!important\"> \n  <div class=\"bar\" style=\"padding-left:45px\"> \n   <div class=\"tools\" style=\"padding:3px 8px 10px 10px; font-size:9px; line-height:normal; font-family:Verdana,Geneva,Arial,Helvetica,sans-serif; color:silver; background-color:rgb(248,248,248); border-left-width:3px; border-left-style:solid; border-left-color:rgb(108,226,108)\"> \n    <strong>[java]</strong>&nbsp;\n    <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"ViewSource\" title=\"view plain\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">view plain</a>\n    <a href=\"http://blog.csdn.net/zwy9002/article/details/6610532#\" class=\"CopyToClipboard\" title=\"copy\" style=\"color:rgb(160,160,160); text-decoration:none; background-color:inherit; border:none; padding:1px; margin:0px 10px 0px 0px; font-size:9px; display:inline-block; width:16px; height:16px; text-indent:-2000px\">copy</a> \n    <div style=\"position:absolute; left:498px; top:1266px; width:19px; height:19px; z-index:99\"> \n    </div> \n   <div style=\"position: absolute; left: 613px; top: 1118px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_6\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_6\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=6&amp;width=16&amp;height=16\" wmode=\"transparent\"></div><div style=\"position: absolute; left: 613px; top: 1118px; width: 16px; height: 16px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_12\" src=\"https://csdnimg.cn/public/highlighter/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"16\" height=\"16\" name=\"ZeroClipboardMovie_12\" align=\"middle\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=12&amp;width=16&amp;height=16\" wmode=\"transparent\"></div></div> \n  </div> \n  <ol start=\"1\" class=\"dp-j\" style=\"margin:0px 0px 1px 45px!important; padding:0px; border:none; list-style-position:initial; background-color:rgb(255,255,255); color:rgb(92,92,92)\"><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">public</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;</span><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">interface</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;Interface1&nbsp;</span><span class=\"keyword\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,102,153); background-color:inherit; font-weight:bold\">implements</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;Interface2，...，InterfaceN{&nbsp;&nbsp;</span></span></li><li style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; background-color:rgb(248,248,248); line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\"><span class=\"comment\" style=\"margin:0px; padding:0px; border:none; color:rgb(0,130,0); background-color:inherit\">//&nbsp;TODO</span><span style=\"margin:0px; padding:0px; border:none; background-color:inherit\">&nbsp;&nbsp;</span></span></li><li class=\"alt\" style=\"margin:0px!important; padding:0px 3px 0px 10px!important; border-style:none none none solid; border-left-width:3px; border-left-color:rgb(108,226,108); list-style:decimal-leading-zero outside; color:inherit; line-height:17.27272605895996px\"> <span style=\"margin:0px; padding:0px; border:none; color:black; background-color:inherit\">}&nbsp;&nbsp;</span></li></ol> \n </div> \n</div> \n<p style=\"color:rgb(51,51,51); font-family:Arial; font-size:13.63636302947998px; line-height:26px\"> <span style=\"font-family:monospace; white-space:pre\"></span></p> \n<p><span style=\"font-family:Arial; font-size:13.63636302947998px; line-height:26px; color:rgb(255,0,0)\">Error：Syntax error on token \"implements\", extends expected</span></p> \n<p><span style=\"font-family:Arial; color:#ff0000\"><span style=\"font-size:14px; line-height:26px\">入门级选手，积累一下，转自：<a href=\"http://blog.csdn.net/zwy9002/article/details/6610532\">http://blog.csdn.net/zwy9002/article/details/6610532</a></span></span></p>\n                </div><div><div></div></div>\n        </div>"
  },
  {
    "category": "javaBasic",
    "qes": "JAVA集合类汇总",
    "ans": "<div class=\"postBody\">\n\t\t\t<div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<p><strong>一、集合与数组</strong></p>\n<p>数组（可以存储<span style=\"background-color: rgba(255, 255, 0, 1)\">基本数据类型</span>）是用来存现对象的一种容器，但是数组的<span style=\"background-color: rgba(255, 255, 0, 1)\">长度固定</span>，不适合在对象数量未知的情况下使用。</p>\n<p>集合（只能存储<span style=\"background-color: rgba(255, 255, 0, 1)\">对象</span>，对象类型可以不一样）的<span style=\"background-color: rgba(255, 255, 0, 1)\">长度可变</span>，可在多数情况下使用。</p>\n<p><strong>二、层次关系</strong></p>\n<p>如图所示：图中，实线边框的是实现类，折线边框的是抽象类，而点线边框的是接口</p>\n<p><img src=\"https://images2015.cnblogs.com/blog/875181/201609/875181-20160921100733106-1187286566.png\" alt=\"\"></p>\n<p><span style=\"background-color: rgba(255, 0, 0, 1)\">Collection</span>接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是<span style=\"background-color: rgba(255, 0, 0, 1)\">Set和List</span>。<span style=\"background-color: rgba(255, 255, 0, 1)\">Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式</span>。</p>\n<p><span style=\"background-color: rgba(255, 0, 0, 1)\">Map</span>是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。<span style=\"background-color: rgba(255, 255, 0, 1)\">Map不能包含重复的key，但是可以包含相同的value</span>。</p>\n<p><span style=\"background-color: rgba(255, 0, 0, 1)\">Iterator</span>，所有的集合类，都实现了Iterator接口，这是一个用于遍历集合中元素的接口，主要包含以下三种方法：<br>1.hasNext()是否还有下一个元素。<br>2.next()返回下一个元素。<br>3.remove()删除当前元素。</p>\n<p><strong>三、几种重要的接口和类简介</strong></p>\n<p>1、<span style=\"background-color: rgba(255, 204, 153, 1)\">List（有序、可重复）</span><br>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</p>\n<p>2、<span style=\"background-color: rgba(255, 204, 153, 1)\">Set（无序、不能重复）</span><br>Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。</p>\n<p>3、<span style=\"background-color: rgba(255, 204, 153, 1)\">Map（键值对、键唯一、值不唯一）</span><br>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。</p>\n<p>对比如下：</p>\n<div class=\"table-wrapper\"><table>\n<tbody>\n<tr>\n<td valign=\"center\" width=\"93\">\n<p>　</p>\n\n\n</td>\n<td valign=\"center\" width=\"102\">\n<p>　</p>\n\n\n</td>\n<td valign=\"center\" width=\"154\">\n<p>是否有序</p>\n\n\n</td>\n<td valign=\"center\" width=\"166\">\n<p>是否允许元素重复</p>\n\n\n</td>\n\n\n</tr>\n<tr>\n<td colspan=\"2\" valign=\"center\" width=\"195\">\n<p>Collection</p>\n\n\n</td>\n<td valign=\"center\" width=\"154\">\n<p>&nbsp;</p>\n\n\n</td>\n<td valign=\"center\" width=\"166\">\n<p>&nbsp;</p>\n\n\n</td>\n\n\n</tr>\n<tr>\n<td colspan=\"2\" valign=\"center\" width=\"195\">\n<p>List</p>\n\n\n</td>\n<td valign=\"center\" width=\"154\">\n<p>是</p>\n\n\n</td>\n<td valign=\"center\" width=\"166\">\n<p>是</p>\n\n\n</td>\n\n\n</tr>\n<tr>\n<td valign=\"center\" width=\"93\">\n<p>Set</p>\n\n\n</td>\n<td valign=\"center\" width=\"102\">\n<p>AbstractSet</p>\n\n\n</td>\n<td rowspan=\"2\" valign=\"center\" width=\"154\">\n<p>否</p>\n\n\n</td>\n<td rowspan=\"3\" valign=\"center\" width=\"166\">\n<p>否</p>\n\n\n</td>\n\n\n</tr>\n<tr>\n<td valign=\"center\" width=\"93\">\n<p>　</p>\n\n\n</td>\n<td valign=\"center\" width=\"102\">\n<p>HashSet</p>\n\n\n</td>\n\n\n</tr>\n<tr>\n<td valign=\"center\" width=\"93\">\n<p>　</p>\n\n\n</td>\n<td valign=\"center\" width=\"102\">\n<p>TreeSet</p>\n\n\n</td>\n<td valign=\"center\" width=\"154\">\n<p>是（用二叉排序树）</p>\n\n\n</td>\n\n\n</tr>\n<tr>\n<td valign=\"center\" width=\"93\">\n<p>Map</p>\n\n\n</td>\n<td valign=\"center\" width=\"102\">\n<p>AbstractMap</p>\n\n\n</td>\n<td rowspan=\"2\" valign=\"center\" width=\"154\">\n<p>否</p>\n\n\n</td>\n<td rowspan=\"3\" valign=\"center\" width=\"166\">\n<p>使用<span style=\"font-family: Verdana\">key-value</span><span style=\"font-family: 宋体\">来映射和存储数据，</span><span style=\"font-family: Verdana\">key</span><span style=\"font-family: 宋体\">必须唯一，</span><span style=\"font-family: Verdana\">value</span><span style=\"font-family: 宋体\">可以重复</span></p>\n\n\n</td>\n\n\n</tr>\n<tr>\n<td valign=\"center\" width=\"93\">\n<p>　</p>\n\n\n</td>\n<td valign=\"center\" width=\"102\">\n<p>HashMap</p>\n\n\n</td>\n\n\n</tr>\n<tr>\n<td valign=\"center\" width=\"93\">\n<p>　</p>\n\n\n</td>\n<td valign=\"center\" width=\"102\">\n<p>TreeMap</p>\n\n\n</td>\n<td valign=\"center\" width=\"154\">\n<p>是（用二叉排序树）</p>\n\n\n</td>\n\n\n</tr>\n\n\n</tbody>\n\n\n</table></div>\n<p class=\"NewStyle15\">&nbsp;</p>\n<p><strong>四、遍历</strong></p>\n<p class=\"NewStyle15\">&nbsp;在类集中提供了以下四种的常见输出方式：</p>\n<p class=\"NewStyle15\">1）<span style=\"background-color: rgba(255, 204, 153, 1)\">Iterator</span>：迭代输出，是使用最多的输出方式。</p>\n<p class=\"NewStyle15\">2）<span style=\"background-color: rgba(255, 204, 153, 1)\">ListIterator</span>：是Iterator的子接口，专门用于输出List中的内容。</p>\n<p class=\"NewStyle15\">3）<span style=\"background-color: rgba(255, 204, 153, 1)\">foreach</span>输出：JDK1.5之后提供的新功能，可以输出数组或集合。</p>\n<p class=\"NewStyle15\">4）<span style=\"background-color: rgba(255, 204, 153, 1)\">for循环</span></p>\n<p class=\"NewStyle15\"><span style=\"background-color: rgba(255, 255, 255, 1)\">代码示例如下：</span></p>\n<p>&nbsp;for<span style=\"font-family: 宋体\">的形式：</span><span style=\"line-height: 1.5\">for</span><span style=\"line-height: 1.5\">（</span><span style=\"font-family: Calibri\">int&nbsp;i=0;i&lt;arr.size();i++</span><span style=\"line-height: 1.5\">）</span><span style=\"font-family: Calibri\">{...}</span></p>\n<p>&nbsp;foreach<span style=\"font-family: 宋体\">的形式：</span><span style=\"line-height: 1.5\">&nbsp;for</span><span style=\"font-family: 宋体\">（</span><span style=\"font-family: Calibri\">int</span><span style=\"font-family: 宋体\">　</span><span style=\"font-family: Calibri\">i</span><span style=\"font-family: 宋体\">：</span><span style=\"font-family: Calibri\">arr</span><span style=\"font-family: 宋体\">）</span><span style=\"font-family: Calibri\">{...}</span></p>\n<p>&nbsp;iterator的形式：<br>Iterator it = arr.iterator();<br>while(it.hasNext()){ object o =it.next(); ...}</p>\n<p><strong>五、ArrayList和LinkedList</strong></p>\n<p><span style=\"background-color: rgba(255, 0, 0, 1)\">ArrayList和LinkedList</span>在用法上没有区别，但是在功能上还是有区别的。<span style=\"background-color: rgba(255, 255, 0, 1)\">LinkedList经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反。</span></p>\n<p><span style=\"background-color: rgba(255, 255, 255, 1)\"><strong>六、Map集合</strong></span></p>\n<p><span style=\"background-color: rgba(255, 255, 255, 1)\">实现类：HashMap、Hashtable、LinkedHashMap和TreeMap</span></p>\n<p><span style=\"background-color: rgba(255, 0, 0, 1)\">HashMap&nbsp;</span></p>\n<p>HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度，遍历时，<span style=\"background-color: rgba(255, 255, 0, 1)\">取得数据的顺序是完全随机</span>的。因为<span style=\"background-color: rgba(255, 255, 0, 1)\">键对象不可以重复</span>，所以HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null，是非同步的</p>\n<p><span style=\"background-color: rgba(255, 0, 0, 1)\">Hashtable</span></p>\n<p class=\"NewStyle15\">Hashtable与HashMap类似，是HashMap的<span style=\"background-color: rgba(255, 255, 0, 1)\">线程安全</span>版，它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢，它继承自Dictionary类，不同的是它不允许记录的键或者值为null，同时效率较低。</p>\n<p class=\"NewStyle15\"><span style=\"background-color: rgba(255, 0, 0, 1)\">ConcurrentHashMap</span></p>\n<p class=\"NewStyle15\"><span style=\"background-color: rgba(255, 255, 255, 1)\">线程安全，并且锁分离。</span>ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash&nbsp;table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>\n<p><span style=\"background-color: rgba(255, 0, 0, 1)\">LinkedHashMap</span></p>\n<p class=\"NewStyle15\">LinkedHashMap<span style=\"background-color: rgba(255, 255, 0, 1)\">保存了记录的插入顺序</span>，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。</p>\n<p><span style=\"background-color: rgba(255, 0, 0, 1)\">TreeMap</span></p>\n<p class=\"NewStyle15\">TreeMap实现SortMap接口，能够把它保存的记录<span style=\"background-color: rgba(255, 255, 0, 1)\">根据键排序</span>，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的；</p>\n<p class=\"NewStyle15\"><strong>map的遍历</strong></p>\n<p>第一种：<span style=\"background-color: rgba(255, 204, 153, 1)\">KeySet()</span><br>将Map中所有的键存入到set集合中。因为set具备迭代器。所有可以迭代方式取出所有的键，再根据get方法。获取每一个键对应的值。 keySet():迭代后只能通过get()取key&nbsp;。<br>取到的结果会乱序，是因为取得数据行主键的时候，使用了HashMap.keySet()方法，而这个方法返回的Set结果，里面的数据是乱序排放的。<br>典型用法如下：<br>Map map = new HashMap();<br>map.put(\"key1\",\"lisi1\");<br>map.put(\"key2\",\"lisi2\");<br>map.put(\"key3\",\"lisi3\");<br>map.put(\"key4\",\"lisi4\");&nbsp;&nbsp;<br>//先获取map集合的所有键的set集合，keyset（）<br>Iterator it = map.keySet().iterator();<br>&nbsp;//获取迭代器<br>while(it.hasNext()){<br>Object key = it.next();<br>System.out.println(map.get(key));<br>}</p>\n<p>第二种：<span style=\"background-color: rgba(255, 204, 153, 1)\">entrySet（）</span><br>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() //返回此映射中包含的映射关系的 Set 视图。（一个关系就是一个键-值对），就是把(key-value)作为一个整体一对一对地存放到Set集合当中的。Map.Entry表示映射关系。entrySet()：迭代后可以e.getKey()，e.getValue()两种方法来取key和value。返回的是Entry接口。<br>典型用法如下：<br>Map map = new HashMap();<br>map.put(\"key1\",\"lisi1\");<br>map.put(\"key2\",\"lisi2\");<br>map.put(\"key3\",\"lisi3\");<br>map.put(\"key4\",\"lisi4\");<br>//将map集合中的映射关系取出，存入到set集合<br>Iterator it = map.entrySet().iterator();<br>while(it.hasNext()){<br>Entry e =(Entry) it.next();<br>System.out.println(\"键\"+e.getKey () + \"的值为\" + e.getValue());<br>}<br>推荐使用第二种方式，即<span style=\"background-color: rgba(255, 255, 0, 1)\">entrySet()方法，效率较高</span>。<br>对于keySet其实是遍历了2次，一次是转为iterator，一次就是从HashMap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，所以快了。两种遍历的遍历时间相差还是很明显的。</p>\n<p><strong><span style=\"background-color: rgba(255, 255, 255, 1)\">七、主要实现类区别小结</span></strong></p>\n<p><span style=\"background-color: rgba(255, 204, 153, 1)\">Vector和ArrayList</span><br>1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。<br>2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%，而arraylist增长率为目前数组长度的50%。如果在集合中使用数据量比较大的数据，用vector有一定的优势。<br>3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，如果频繁的访问数据，这个时候使用vector和arraylist都可以。而如果移动一个指定位置会导致后面的元素都发生移动，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据时其它元素不移动。<br>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以索引数据快，插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。</p>\n<p><span style=\"background-color: rgba(255, 204, 153, 1)\">arraylist和linkedlist</span><br>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。&nbsp;这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</p>\n<p><span style=\"background-color: rgba(255, 204, 153, 1)\">HashMap与TreeMap</span><br>1、&nbsp;HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。<br>2、在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。<br>两个map中的元素一样，但顺序不一样，导致hashCode()不一样。<br>同样做测试：<br>在HashMap中，同样的值的map,顺序不同，equals时，false;<br>而在treeMap中，同样的值的map,顺序不同,equals时，true，说明，treeMap在equals()时是整理了顺序了的。</p>\n<p><span style=\"background-color: rgba(255, 204, 153, 1)\">HashTable与HashMap</span><br>1、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的。<br>2、HashMap允许存在一个为null的key，多个为null的value 。<br>3、hashtable的key和value都不允许为null。</p>\n</div>\n<div id=\"MySignature\"></div>\n<div class=\"clear\"></div>\n<div id=\"blog_post_info_block\"><div id=\"BlogPostCategory\">\n    分类: \n            <a href=\"https://www.cnblogs.com/leeplogs/category/775933.html\" target=\"_blank\">javaEE</a></div>\n\n\n    <div id=\"blog_post_info\">\n<div id=\"green_channel\">\n        <a href=\"javascript:void(0);\" id=\"green_channel_digg\" onclick=\"DiggIt(5891861,cb_blogId,1);green_channel_success(this,'谢谢推荐！');\">好文要顶</a>\n        <a id=\"green_channel_follow\" onclick=\"follow('8e828f03-e5b4-e511-9fc1-ac853d9f53cc');\" href=\"javascript:void(0);\">关注我</a>\n    <a id=\"green_channel_favorite\" onclick=\"AddToWz(cb_entryId);return false;\" href=\"javascript:void(0);\">收藏该文</a>\n    <a id=\"green_channel_weibo\" href=\"javascript:void(0);\" title=\"分享至新浪微博\" onclick=\"ShareToTsina()\"><img src=\"https://common.cnblogs.com/images/icon_weibo_24.png\" alt=\"\"></a>\n    <a id=\"green_channel_wechat\" href=\"javascript:void(0);\" title=\"分享至微信\" onclick=\"shareOnWechat()\"><img src=\"https://common.cnblogs.com/images/wechat.png\" alt=\"\"></a>\n</div>\n<div id=\"author_profile\">\n    <div id=\"author_profile_info\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/leeplogs/\" target=\"_blank\"><img src=\"https://pic.cnblogs.com/face/875181/20170516170133.png\" class=\"author_avatar\" alt=\"\"></a>\n        <div id=\"author_profile_detail\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/leeplogs/\">lipper_p</a><br>\n            <a href=\"https://home.cnblogs.com/u/leeplogs/followees/\">关注 - 4</a><br>\n            <a href=\"https://home.cnblogs.com/u/leeplogs/followers/\">粉丝 - 43</a>\n        </div>\n    </div>\n    <div class=\"clear\"></div>\n    <div id=\"author_profile_honor\"></div>\n    <div id=\"author_profile_follow\">\n                <a href=\"javascript:void(0);\" onclick=\"follow('8e828f03-e5b4-e511-9fc1-ac853d9f53cc');return false;\">+加关注</a>\n    </div>\n</div>\n<div id=\"div_digg\">\n    <div class=\"diggit\" onclick=\"votePost(5891861,'Digg')\">\n        <span class=\"diggnum\" id=\"digg_count\">48</span>\n    </div>\n    <div class=\"buryit\" onclick=\"votePost(5891861,'Bury')\">\n        <span class=\"burynum\" id=\"bury_count\">1</span>\n    </div>\n    <div class=\"clear\"></div>\n    <div class=\"diggword\" id=\"digg_tips\">\n    </div>\n</div>\n\n<script type=\"text/javascript\">\n    currentDiggType = 0;\n</script></div>\n    <div class=\"clear\"></div>\n    <div id=\"post_next_prev\">\n\n    <a href=\"https://www.cnblogs.com/leeplogs/p/5880746.html\" class=\"p_n_p_prefix\">« </a> 上一篇：    <a href=\"https://www.cnblogs.com/leeplogs/p/5880746.html\" title=\"发布于 2016-09-18 10:46\">Hibernate与MyBatis</a>\n    <br>\n    <a href=\"https://www.cnblogs.com/leeplogs/p/5911203.html\" class=\"p_n_p_prefix\">» </a> 下一篇：    <a href=\"https://www.cnblogs.com/leeplogs/p/5911203.html\" title=\"发布于 2016-09-26 23:48\">Spring MVC常用注解</a>\n\n</div>\n</div>\n\t\t</div>"
  },
  {
    "category": "javaBasic",
    "qes": "描述一下ArrayList和LinkedList各自实现和区别",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<p>ArrayList,LinkedList,Vestor这三个类都实现了java.util.List接口，但它们有各自不同的特性，主要如下：&nbsp;<br><br>一、同步性&nbsp;<br><br>ArrayList,LinkedList是不同步的，而Vestor是同步的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。&nbsp;<br><br>二、数据增长&nbsp;<br>从内部实现机制来讲ArrayList和Vector都是使用Objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。&nbsp;<br><br>三、检索、插入、删除对象的效率&nbsp;<br><br>ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。&nbsp;<br>LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。&nbsp;<br>————————————————————————————————————————&nbsp;<br>一般大家都知道ArrayList和LinkedList的大致区别：&nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。&nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。&nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。&nbsp;<br><br>ArrayList和LinkedList是两个集合 类，用于存储一系列的对象引用(references)。例如我们可以用ArrayList来存储一系列的String或者Integer。那么 ArrayList和LinkedList在性能上有什么差别呢？什么时候应该用ArrayList什么时候又该用LinkedList呢？&nbsp;<br><br><br>一．时间复 杂度&nbsp;<br>首先一点关键的是，ArrayList的内部实现是基于基础的对象数组的，因此，它使用get方法访问列表中的任意一个元素时 (random access)，它的速度要比LinkedList快。LinkedList中的get方法是按照顺序从列表的一端开始检查，直到另外一端。对 LinkedList而言，访问列表中的某个指定元素没有更快的方法了。&nbsp;<br>假设我们有一个很大的列表，它里面的元素已经排好序了，这个列表可能是ArrayList类型 的也可能是LinkedList类型的，现在我们对这个列表来进行二分查找(binary search)，比较列表是ArrayList和LinkedList时的查询速度，看下面的程序：&nbsp;<br><br>Java代码&nbsp;<br>package com.mangocity.test;&nbsp; &nbsp;<br>import java.util.LinkedList;&nbsp; &nbsp;<br>import java.util.List;&nbsp; &nbsp;<br>import java.util.Random;&nbsp; &nbsp;<br>import java.util.ArrayList;&nbsp; &nbsp;<br>import java.util.Arrays;&nbsp; &nbsp;<br>import java.util.Collections;&nbsp; &nbsp;<br>public class TestList ...{&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;public static final int N=50000;&nbsp; &nbsp;<br>&nbsp;&nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;public static List values;&nbsp; &nbsp;<br>&nbsp;&nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;static...{&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Integer vals[]=new Integer[N];&nbsp; &nbsp;<br>&nbsp;&nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Random r=new Random();&nbsp; &nbsp;<br>&nbsp;&nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for(int i=0,currval=0;i&lt;N;i++)...{&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; vals=new Integer(currval);&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; currval+=r.nextInt(100)+1;&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;}&nbsp; &nbsp;<br>&nbsp;&nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;values=Arrays.asList(vals);&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp; &nbsp;<br>&nbsp;&nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;static long timeList(List lst)...{&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;long start=System.currentTimeMillis();&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for(int i=0;i&lt;N;i++)...{&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; int index=Collections.binarySearch(lst, values.get(i));&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; if(index!=i)&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;System.out.println(\"***错误***\");&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;}&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;return System.currentTimeMillis()-start;&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;public static void main(String args[])...{&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;System.out.println(\"ArrayList消耗时间：\"+timeList(new ArrayList(values)));&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;System.out.println(\"LinkedList消耗时间：\"+timeList(new LinkedList(values)));&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp; &nbsp;<br>}&nbsp; &nbsp;<br><br>我得到的输出 是：ArrayList消耗时间：15&nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;LinkedList消耗时间：2596&nbsp;<br>这个结果不是固定的，但是基本上ArrayList的 时间要明显小于LinkedList的时间。因此在这种情况下不宜用LinkedList。二分查找法使用的随机访问(random access)策略，而LinkedList是不支持快速的随机访问的。对一个LinkedList做随机访问所消耗的时间与这个list的大小是成比例 的。而相应的，在ArrayList中进行随机访问所消耗的时间是固定的。&nbsp;<br>这是否表明ArrayList总是比LinkedList性能要好呢？这并不一定，在某些情况 下LinkedList的表现要优于ArrayList，有些算法在LinkedList中实现时效率更高。比方说，利用 Collections.reverse方法对列表进行反转时，其性能就要好些。&nbsp;<br>看这样一个例子，加入我们有一个列表，要对其进行大量的插入和删除操作，在这种情况下 LinkedList就是一个较好的选择。请看如下一个极端的例子，我们重复的在一个列表的开端插入一个元素：&nbsp;<br><br>Java代码&nbsp;<br>package com.mangocity.test;&nbsp; &nbsp;<br>&nbsp;&nbsp;<br>import java.util.*;&nbsp; &nbsp;<br>public class ListDemo {&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;static final int N=50000;&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;static long timeList(List list){&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;long start=System.currentTimeMillis();&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;Object o = new Object();&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;for(int i=0;i&lt;N;i++)&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;list.add(0, o);&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;return System.currentTimeMillis()-start;&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;public static void main(String[] args) {&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;System.out.println(\"ArrayList耗时：\"+timeList(new ArrayList()));&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;System.out.println(\"LinkedList耗时：\"+timeList(new LinkedList()));&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp; &nbsp;<br>}&nbsp; &nbsp;<br>这时我的输出结果是：ArrayList耗时：2463&nbsp;<br><br><br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;LinkedList耗时：15&nbsp;<br>这和前面一个例子的结果截然相反，当一个元素被加到ArrayList的最开端时，所有已经存在的元素都会后 移，这就意味着数据移动和复制上的开销。相反的，将一个元素加到LinkedList的最开端只是简单的未这个元素分配一个记录，然后调整两个连接。在 LinkedList的开端增加一个元素的开销是固定的，而在ArrayList的开端增加一个元素的开销是与ArrayList的大小成比例的。&nbsp;<br><br><br>二．空间复 杂度&nbsp;<br>在LinkedList中有一个私有的内部类，定义如下：&nbsp;<br><br>Java代码&nbsp;<br>private static class Entry {&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Object element;&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Entry next;&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Entry previous;&nbsp; &nbsp;<br>&nbsp; &nbsp;&nbsp;&nbsp;}&nbsp; &nbsp;<br><br>每个Entry对象 reference列表中的一个元素，同时还有在LinkedList中它的上一个元素和下一个元素。一个有1000个元素的LinkedList对象将 有1000个链接在一起的Entry对象，每个对象都对应于列表中的一个元素。这样的话，在一个LinkedList结构中将有一个很大的空间开销，因为 它要存储这1000个Entity对象的相关信息。&nbsp;<br>ArrayList使用一个内置的数组来存储元素，这个数组的起始容量是10.当数组需要增长时，新的容量按 如下公式获得：新容量=(旧容量*3)/2+1，也就是说每一次容量大概会增长50%。这就意味着，如果你有一个包含大量元素的ArrayList对象， 那么最终将有很大的空间会被浪费掉，这个浪费是由ArrayList的工作方式本身造成的。如果没有足够的空间来存放新的元素，数组将不得不被重新进行分 配以便能够增加新的元素。对数组进行重新分配，将会导致性能急剧下降。如果我们知道一个ArrayList将会有多少个元素，我们可以通过构造方法来指定 容量。我们还可以通过trimToSize方法在ArrayList分配完毕之后去掉浪费掉的空间。&nbsp;<br><br><br>三．总结&nbsp;<br>ArrayList和LinkedList在性能上各 有优缺点，都有各自所适用的地方，总的说来可以描述如下：&nbsp;<br>1．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对 ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是 统一的，分配一个内部Entry对象。&nbsp;<br><br><br>2．在ArrayList的 中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。&nbsp;<br><br><br>3．LinkedList不 支持高效的随机元素访问。&nbsp;<br><br><br>4．ArrayList的空 间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间&nbsp;<br><br><br>可以这样说：当操作是在一列 数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中 间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。&nbsp;<br><br>所以，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList</p>\n</div>"
  },
  {
    "category": "javaBasic",
    "qes": "HashMap最小树形化阈值MIN_TREEIFY_CAPACITY",
    "ans": "<div id=\"content_views\" class=\"htmledit_views\">\n                    <p>HashMap的几个关键参数很重要，大家非常熟悉capacity loadFactory threshold table&nbsp; size&nbsp;以及下列jdk1.8后特有的红黑树相关参数。其中，最小树形化参数MIN_TREEIFY_THRESHOLD&nbsp;的作用到底是什么呢？</p> \n<p>/**</p> \n<p>* 与红黑树相关的参数</p> \n<p>*/</p> \n<p>// 1. 桶的树化阈值：即 链表转成红黑树的阈值，在存储数据时，当链表长度 &gt; 该值时，则将链表转换成红黑树</p> \n<p>static final int TREEIFY_THRESHOLD = 8;</p> \n<p>// 2. 桶的链表还原阈值：即 红黑树转为链表的阈值，当在扩容（resize（））时（此时HashMap的数据存储位置会重新计算），在重新计算存储位置后，当原有的红黑树内数量 &lt; 6时，则将 红黑树转换成链表</p> \n<p>static final int UNTREEIFY_THRESHOLD = 6;</p> \n<p>// 3. 最小树形化容量阈值：即 当哈希表中的容量 &gt; 该值时，才允许树形化链表 （即 将链表 转换成红黑树）</p> \n<p>// 否则，若桶内元素太多时，则直接扩容，而不是树形化</p> \n<p>// 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</p> \n<p>static final int MIN_TREEIFY_CAPACITY = 64;</p> \n<p>&nbsp;</p> \n<p>在我们熟悉的</p> \n<pre>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict)</pre> \n<p>方法中并没有出现最小树形化参数，并且在链表转成红黑树的判断语句前并没有相关判断，顿时头痛。仔细再核对一遍putVal（）中的判断语句</p> \n<pre>for (int binCount = 0; ; ++binCount) {\n    if ((e = p.next) == null) {\n        p.next = newNode(hash, key, value, null);\n        \n// 链表长度达到8，进行链表转红黑树\n        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n            treeifyBin(tab, hash);\n        break;\n    }\n    if (e.hash == hash &amp;&amp;\n        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n        break;\n    p = e;\n}</pre> \n<pre>final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {\n    int n, index; Node&lt;K,V&gt; e;\n//判断capacity是否小于最小树形化容量阈值\n    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {\n        TreeNode&lt;K,V&gt; hd = null, tl = null;\n        do {\n            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        if ((tab[index] = hd) != null)\n            hd.treeify(tab);\n    }\n}</pre> \n<p>原来MIN_TREEIFY_CAPACITY出现在了treeifyBin()中！这样做会让逻辑更清楚，避免了在treeifyBin()前判断capacity与MIN_TREEIFY_CAPACITY比较的代码量过大。</p> \n<p></p>\n                </div>"
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  }

]