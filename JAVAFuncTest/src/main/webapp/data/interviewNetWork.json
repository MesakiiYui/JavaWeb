[

  {
    "category": "network",
    "qes": "OSI七层模型详解",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <p align=\"center\"><img alt=\"\" src=\"http://hi.csdn.net/attachment/201201/5/0_1325744597WM32.gif\" width=\"666\" height=\"963\"></p> \n<p align=\"center\"></p> \n<p align=\"left\">&nbsp;</p> \n<p>OSI 七层模型通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯，因此其最主要的功能就是帮助不同类型的主机实现数据传输 。</p> \n<p>完成中继功能的节点通常称为中继系统。在OSI七层模型中，处于不同层的中继系统具有不同的名称。&nbsp;&nbsp;&nbsp;</p> \n<p align=\"center\"></p> \n<p>一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。<br> 具体说:<br> <span style=\"background-color:#33ff33\">物理层：网卡，网线，集线器，中继器，调制解调器</span></p> \n<p><span style=\"background-color:#33ff33\">数据链路层：网桥，交换机</span></p> \n<p><span style=\"background-color:#33ff33\">网络层：路由器</span></p> \n<p><span style=\"background-color:#33ff33\">网关工作在第四层传输层及其以上</span></p> \n<p>集线器是物理层设备,采用广播的形式来传输信息。</p> \n<p>交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文.。</p> \n<p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。&nbsp;<br> </p> \n<p><strong>交换机和路由器的区别</strong></p> \n<p>交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。&nbsp;<br> 使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。&nbsp;<br> 交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。&nbsp;<br> <span style=\"color:#ff0000\">总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。</span>交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。</p> \n<p>从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。</p> \n<p><strong>集线器与路由器在功能上有什么不同?&nbsp;<br> </strong><br> 首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。<span style=\"color:#ff0000\">路由器主要克服了交换机不能路由转发数据包的不足。</span>&nbsp;<br> <br> 总的来说，路由器与交换机的主要区别体现在以下几个方面：&nbsp;<br> <br> （1）工作层次不同&nbsp;<br> 最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。&nbsp;<br> <br> （2）数据转发所依据的对象不同&nbsp;<br> 交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。&nbsp;<br> <br> （3）传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域&nbsp;<br> 由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。&nbsp;<br> <br> （4）路由器提供了防火墙的服务&nbsp;<br> 路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p> \n<p>&nbsp;</p> \n<p><strong>物理层<br> </strong>在OSI参考模型中，物理层（Physical Layer）是参考模型的最低层，也是OSI模型的第一层。<br> 物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br> 物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p> \n<p><strong>数据链路层<br> </strong>数据链路层（Data Link Layer）是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br> 在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。<br> 该层通常又被分为<span style=\"color:#000000; background-color:#33ffff\">介质访问控制（MAC）和逻辑链路控制（LLC）</span>两个子层。</p> \n<p>MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制；</p> \n<p>LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制。<br> 数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p> \n<p><strong>网络层<br> </strong>网络层（Network Layer）是OSI模型的第三层，它是OSI参考模型中<span style=\"color:#ff0000\">最复杂的一层</span>，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。<br> 一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。&nbsp;</p> \n<p>在实现网络层功能时，需要解决的主要问题如下：<br> <span style=\"background-color:#ffff33\">&nbsp;寻址：</span>数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。<br> <span style=\"background-color:#ffff33\">&nbsp;交换：</span>规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。<br> <span style=\"background-color:#ffff33\">&nbsp;路由算法：</span>当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。<br> <span style=\"background-color:#ffff33\">&nbsp;连接服务：</span>与数据链路层流量控制不同的是，前者控制的是<span style=\"color:#ff0000\">网络相邻节点间的流量</span>，后者控制的是<span style=\"color:#ff0000\">从源节点到目的节点间的流量</span>。其目的在于防止阻塞，并进行差错检测。<br> <br> <strong>传输层<br> </strong>OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。<br> 该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。<br> 传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下：<br> <span style=\"background-color:#ffff33\">传输连接管理：</span>提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。<br> <span style=\"background-color:#ffff33\">处理传输差错：</span>提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。<br> <span style=\"color:#000000; background-color:#ffff33\">监控服务质量</span>。<br> <strong>会话层<br> </strong>会话层（Session Layer）是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。<br> 用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC（介质访问控制子层）地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。域名（DN）就是一种网络上使用的远程地址例如：<a href=\"http://student.csdn.net/link.php?url=http://www.3721.com%2F\" target=\"_blank\" rel=\"noopener noreferrer\">www.3721.com</a>就是一个域名。会话层的具体功能如下：<br> <span style=\"background-color:#ffff33\">会话管理：</span>允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。<br> <span style=\"background-color:#ffff33\">&nbsp;会话流量控制：</span>提供会话流量控制和交叉会话功能。<br> <span style=\"background-color:#ffff33\">寻址：</span>使用远程地址建立会话连接。l<br> <span style=\"background-color:#ffff33\">出错控制：</span>从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。<br> <strong>表示层<br> </strong>表示层（Presentation Layer）是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。表示层的具体功能如下：<br> <span style=\"background-color:#ffff33\">数据格式处理：</span>协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。<br> <span style=\"background-color:#ffff33\">数据的编码：</span>处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。<br> <span style=\"background-color:#ffff33\">压缩和解压缩：</span>为了减少数据的传输量，这一层还负责数据的压缩与恢复。<br> <span style=\"background-color:#ffff33\">数据的加密和解密：</span>可以提高网络的安全性。</p> \n<p><strong>应用层<br> </strong>应用层（Application Layer）是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。<br> 应用层为用户提供的服务和协议有：文件服务、目录服务、文件传输服务（FTP）、远程登录服务（Telnet）、电子邮件服务（E-mail）、打印服务、安全服务、网络管理服务、数据库服务等。上述的各种网络服务由该层的不同应用协议和程序完成，不同的网络操作系统之间在功能、界面、实现技术、对硬件的支持、安全可靠性以及具有的各种应用程序接口等各个方面的差异是很大的。应用层的主要功能如下：<br> <span style=\"background-color:#ffff33\">用户接口：</span>应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。<br> <span style=\"background-color:#ffff33\">实现各种服务：</span>该层具有的各种应用程序可以完成和实现用户请求的各种服务。<br> </p> \n<p>&nbsp;OSI7层模型的小结<br> 由于OSI是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。<br> 在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能。<br> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</p> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<p>以下是TCP/IP分层模型<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;┌────------────┐┌─┬─┬─-┬─┬─-┬─┬─-┬─┬─-┬─┬─-┐<br> 　　│　　　　　　　　││Ｄ│Ｆ│Ｗ│Ｆ│Ｈ│Ｇ│Ｔ│Ｉ│Ｓ│Ｕ│　│<br> 　　│　　　　　　　　││Ｎ│Ｉ│Ｈ│Ｔ│Ｔ│Ｏ│Ｅ│Ｒ│Ｍ│Ｓ│其│<br> 　　│第四层，应用层　││Ｓ│Ｎ│Ｏ│Ｐ│Ｔ│Ｐ│Ｌ│Ｃ│Ｔ│Ｅ│　│<br> 　　│　　　　　　　　││　│Ｇ│Ｉ│　│Ｐ│Ｈ│Ｎ│　│Ｐ│Ｎ│　│<br> 　　│　　　　　　　　││　│Ｅ│Ｓ│　│　│Ｅ│Ｅ│　│　│Ｅ│它│<br> 　　│　　　　　　　　││　│Ｒ│　│　│　│Ｒ│Ｔ│　│　│Ｔ│　│<br> 　　└───────------─┘└─┴─┴─-┴─┴─-┴─┴─-┴─┴─-┴─┴-─┘<br> 　　┌───────-----─┐┌─────────-------┬──--------─────────┐<br> 　　│第三层，传输层　││　　　ＴＣＰ　　　│　　　　ＵＤＰ　　　　│<br> 　　└───────-----─┘└────────-------─┴──────────--------─┘<br> 　　┌───────-----─┐┌───----──┬───---─┬────────-------──┐<br> 　　│　　　　　　　　││　　　　　│ＩＣＭＰ│　　　　　　　　　　│<br> 　　│第二层，网间层　││　　　　　└──---──┘　　　　　　　　　　│<br> 　　│　　　　　　　　││　　　　　　　ＩＰ　　　　　　　　　　　 │<br> 　　└────────-----┘└────────────────────-------------─-┘<br> 　　┌────────-----┐┌─────────-------┬──────--------─────┐<br> 　　│第一层，网络接口││ＡＲＰ／ＲＡＲＰ　│　　　　其它　　　　　│<br> 　　└────────------┘└─────────------┴─────--------──────┘<br> 　　　　　　 TCP/IP四层参考模型 <br> <br> 　　TCP/IP协议被组织成四个概念层，其中有三层对应于ISO参考模型中的相应层。ICP/IP协议族并不包含物理层和数据链路层，因此它不能独立完成整个计算机网络系统的功能，必须与许多其他的协议协同工作。<br> 　　TCP/IP分层模型的四个协议层分别完成以下的功能：<br> 　　第一层:网络接口层<br> 　　包括用于协作IP数据在已有网络介质上传输的协议。实际上TCP/IP标准并不定义与ISO数据链路层和物理层相对应的功能。相反，它定义像地址解析协议(Address Resolution Protocol,ARP)这样的协议，提供TCP/IP协议的数据结构和实际物理硬件之间的接口。<br> 　　第二层:网间层<br> 　　对应于OSI七层参考模型的网络层。本层包含IP协议、RIP协议(Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议(Internet Control Message Protocol,ICMP)用来提供网络诊断信息。<br> 　　第三层:传输层<br> 　　对应于OSI七层参考模型的传输层，它提供两种端到端的通信服务。其中TCP协议(Transmission Control Protocol)提供可靠的数据流运输服务，UDP协议(Use Datagram Protocol)提供不可靠的用户数据报服务。<br> 　　第四层:应用层<br> 　　对应于OSI七层参考模型的应用层和表达层。因特网的应用层协议包括Finger、Whois、FTP(文件传输协议)、Gopher、HTTP(超文本传输协议)、Telent(远程终端协议)、SMTP(简单邮件传送协议)、IRC(因特网中继会话)、NNTP（网络新闻传输协议）等，这也是本书将要讨论的重点。<br> </p>\n                </div><div><div></div></div>\n        </div>"
  },
  {
    "category": "network",
    "qes": "TCP/IP的体系结构",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n    <p>一、简介<br>\n1、传输控制协议/网络互联协议，是针对Internet开发的一种体系结构和协议标准，相对于OSI体系结构更简洁。<br>\n2、结构类型：分层体系，由下至上分别是网络接口层、网际层、传输层和应用层（四层分法）。</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-a98170ca6063dace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP-IP.png\" loading=\"lazy\"><br>\n3、TCP/IP协议与OSI模型的对应关系（五层分法）。</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-bd1b393b6575cdad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP-IP与OSI的对应关系.png\" loading=\"lazy\"></p>\n<p>二、TCP/IP体系结构<br>\n1、应用层：为用户的应用程序提供接口，使用户可以访问网络。（IE浏览器就处于应用层）</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-c72b22fb255691b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"应用层协议.png\" loading=\"lazy\"><br>\nHTTP 超文本传输协议（浏览网页服务）<br>\nTFTP 文件传输协议（较快，但是不可靠）<br>\nFTP 文件传输协议（提供文件上传，文件下载服务，较慢但是可靠）<br>\nNFS  网络文件系统（Unix和Linux系统之间共享文件）<br>\nSMTP  简单邮件传输协议（邮件的发送和转发）<br>\nPOP3  接收邮件（由服务器下载到本地）<br>\nTalnet  (远程登录功能（配置交换机、路由器）)<br>\nSNMP  简单网络管理协议（通过网管软件来管理网络）<br>\nDNS  域名系统，将域名解析为IP地址（将百度的域名转换为服务器的IP地址）</p>\n<p>2、传输层：提供端到端的通信（两台计算机上的软件间的连接），对信息流具有调节作用。</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-10de34c1828866ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"传输层协议.png\" loading=\"lazy\"><br>\nTCP  传输控制协议 面向连接（打电话） 可靠服务<br>\n在通信之前要先建立连接 需要同时在线<br>\nUDP  用户数据报协议 非面向连接（发快递）不可靠 不稳定 但速度更快</p>\n<hr>\n<p>传输层-TCP数据包格式</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-b1e825d3460088ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP数据格式.png\" loading=\"lazy\"><br>\n源端口(Source Port) 目的端口(Desination Port)<br>\n序列号(Sequence Number)【数据包的序号】<br>\n确认号(Acknowledgment Number)（序列号+1）【用于指示下一个数据包序号】</p>\n<p>报头的长度(HLEN):以32字节为单位的报头长度<br>\n保留域(Reserved)：设置为0</p>\n<p>编码位(Code Bits):用于控制段的传输（如会话的建立和终止）<br>\n包括：URG、ACK、PSH、RST、SYN、FIN 6个位<br>\nSYN（synchronous）：请求建立TCP连接<br>\nFIN：断开TCP连接<br>\nRST：重置TCP连接<br>\nACK：确认、反馈连接情况<br>\nPSH：将数据立刻送到应用层进行处理的命令<br>\nURG：判断紧急指针是否有效的命令</p>\n<p>窗口大小(Windows)：接收方能够继续接收的字节数【控制发送的速度】<br>\n校验和(Checksum):baokuo TCP报头和数据在内的校验和【判断数据传输是否出错】<br>\n紧急指针(Urgent Pointer)：当前序列号到紧急位置的偏移量</p>\n<p>选项(Option)：厂商根据需要自定义的内容<br>\nMAC地址<br>\n数据(Data)：上层协议数据</p>\n<hr>\n<p>传输层-TCP端口号</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-39e7d103355367e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP端口.png\" loading=\"lazy\"><br>\nHTTP：80<br>\n端口范围是：0-6535</p>\n<p>端口的使用</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-5ee964d7d980f35e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"端口的使用.png\" loading=\"lazy\"></p>\n<p>TCP的三次握手</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-fb8eac58e66fb0f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP的三次握手.png\" loading=\"lazy\"></p>\n<p>顺序号和确认号</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-a712e0f3e946971e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"顺序号和确认号.png\" loading=\"lazy\"></p>\n<p>TCP滑动窗口</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-1db76ab6f0b6d80b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP滑动窗口.png\" loading=\"lazy\"></p>\n<p>UDP数据结构</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-3c18c75153d70036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"UDP数据结构.png\" loading=\"lazy\"></p>\n<hr>\n<p>3、网络层：IP包的封装和路径的选择</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-98744b367e3e0342.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网络层.png\" loading=\"lazy\"><br>\n网络层的协议<br>\nIP数据包的封装，定义IP地址</p>\n<p>ICMP错误诊断（用ping测试网络连通性）</p>\n<p>ARP将IP地址解析为MAC地址</p>\n<p>RARP将MAC地址转换为IP地址</p>\n<p>4、数据链路层<br>\nMAC地址（网卡编号）：48位的二进制数。表示为12位的16进制数。分为两部分：前24位为厂商编号，后24位为网卡的编号（由专门的机构分配）</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-ba2d564a9554c06c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"数据链路层.png\" loading=\"lazy\"></p>\n<p>5、物理层</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-c3b56a95ab7680c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"物理层.png\" loading=\"lazy\"></p>\n<hr>\n<h2 id=\"总结\">总结</h2>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-ec18b4f285e64dc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"协议功能总结.png\" loading=\"lazy\"><br>\nH.248 为电话语音协议</p>\n<p>数据封装</p>\n<p><img src=\"//upload-images.jianshu.io/upload_images/1228431-0eaf1d7c9dec32d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"数据封装.png\" loading=\"lazy\"></p>\n<p>课后练习</p>\n<p>1、TCP/IP协议族中每一层的功能是什么，包括哪些协议？</p>\n<p>物理层：在物理传输媒体上传送比特流<br>\n数据链路层：为上层提供可靠的数据帧的传输<br>\n网络层：IP包的封装和路径选择<br>\n传输层：建立端到端的连接<br>\n应用层：提供应用程序网络接口</p>\n<p>2、TCP协议和UDP协议的区别有哪些？</p>\n<p>TCP 传输控制协议 面向连接（打电话） 可靠服务<br>\n在通信之前要先建立连接 需要同时在线<br>\nUDP 用户数据报协议 非面向连接（发快递）不可靠 不稳定</p>\n<p>但速度更快</p>\n<p>3、什么是端口号，其范围是什么？常用的端口号有哪些？</p>\n<p>端口号：指示了正在使用的上层协议<br>\n范围是：0-6535<br>\n常用的端口号：<br>\nFTP——21 文件传输协议(慢但是稳)<br>\nTELNET——23 远程登录协议<br>\nSMTP——25 简单邮件传输协议<br>\nDNS——53 域名系统协议<br>\nTFTP——69 文件传输协议(快而不稳)<br>\nHTTP——80 超文本传输协议<br>\nSNMP——161 简单网络管理协议<br>\nRIP——520 内部网关协议</p>\n<p>4、MAC地址有多少位，分为哪几部分？</p>\n<p>MAC地址（网卡编号）：48位的二进制数。表示为12位的16进制数。分为两部分：前24位为厂商编号，后24位为网卡的编号（由专门的机构分配）</p>\n<p>5、TCP/IP模型中每一层的数据单元是什么？</p>\n<p>物理层——比特流<br>\n数据链路层——帧<br>\n网络层——数据包<br>\n传输层——数据报文<br>\n数据发送时，由上层向下层封装。<br>\n四层，协议层传输的是数据报文，主要是协议格式。<br>\n三层，网络层传输的是数据包，包含数据报文，并且增加传输使用的IP地址等三层信息<br>\n二层，数据链路层传输的是数据帧，包含数据包，并且增加相应MAC地址与二层信息<br>\n数据接收的时候，下层向上层解封装。</p>\n<p>6、TCP报文的编码位包括哪些值？</p>\n<p>源端口(Source Port) 目的端口(Desination Port)<br>\n序列号(Sequence Number)【数据包的序号】<br>\n确认号(Acknowledgment Number)（序列号+1）【用于指示下一个数据包序号】</p>\n<p>报头的长度(HLEN):以32字节为单位的报头长度<br>\n保留域(Reserved)：设置为0</p>\n<p>编码位(Code Bits):用于控制段的传输（如会话的建立和终止）<br>\n包括：URG、ACK、PSH、RST、SYN、FIN 6个位<br>\nSYN（synchronous）：请求建立TCP连接<br>\nFIN：断开TCP连接<br>\nRST：重置TCP连接<br>\nACK：确认、反馈连接情况<br>\nPSH：将数据立刻送到应用层进行处理的命令<br>\nURG：判断紧急指针是否有效的命令</p>\n<p>窗口大小(Windows)：接收方能够继续接收的字节数【控制发送的速度】<br>\n校验和(Checksum):baokuo TCP报头和数据在内的校验和【判断数据传输是否出错】<br>\n紧急指针(Urgent Pointer)：当前序列号到紧急位置的偏移量</p>\n<p>选项(Option)：厂商根据需要自定义的内容<br>\nMAC地址<br>\n数据(Data)：上层协议数据</p>\n\n</div>"
  },
  {
    "category": "network",
    "qes": "TCP三次握手四次挥手详解",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <p>相对于SOCKET开发者,TCP创建过程和链接折除过程是由TCP/IP协议栈自动创建的.因此开发者并不需要控制这个过程.但是对于理解TCP底层运作机制,相当有帮助.</p>\n<p>而且对于有网络协议工程师之类笔试,几乎是必考的内容.企业对这个问题热情之高,出乎我的意料：-）。有时上午面试前强调这个问题，并重复讲一次，下午几乎每一个人都被问到这个问题。</p>\n<p>因此在这里详细解释一下这两个过程。</p>\n<p><strong>TCP三次握手</strong></p>\n<p>所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。</p>\n<p>三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。<br>\n<a class=\"pirobox_gall first\" href=\"http://www.centos.bz/wp-content/uploads/2012/08/100327002629.png\" rel=\"1&amp;nbsp;of&amp;nbsp;6\" rev=\"0\"><img class=\"aligncenter size-full wp-image-4033\" title=\"100327002629\" src=\"http://www.centos.bz/wp-content/uploads/2012/08/100327002629.png\" alt=\"\" width=\"714\" height=\"537\"></a><br>\n第一次握手:<br>\n客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。<br>\n<a class=\"pirobox_gall\" href=\"http://www.centos.bz/wp-content/uploads/2012/08/100327002911.png\" rel=\"2&amp;nbsp;of&amp;nbsp;6\" rev=\"1\"><img class=\"aligncenter size-full wp-image-4034\" style=\"display: block\" title=\"100327002911\" src=\"http://www.centos.bz/wp-content/uploads/2012/08/100327002911.png\" alt=\"\" width=\"548\" height=\"239\"></a><br>\n第二次握手:<br>\n服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。<br>\n<a class=\"pirobox_gall\" href=\"http://www.centos.bz/wp-content/uploads/2012/08/100327003054.png\" rel=\"3&amp;nbsp;of&amp;nbsp;6\" rev=\"2\"><img class=\"aligncenter size-full wp-image-4035\" style=\"display: block\" title=\"100327003054\" src=\"http://www.centos.bz/wp-content/uploads/2012/08/100327003054.png\" alt=\"\" width=\"541\" height=\"233\"></a></p>\n<p>第三次握手.<br>\n客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1<br>\n<a class=\"pirobox_gall\" href=\"http://www.centos.bz/wp-content/uploads/2012/08/100327003214.png\" rel=\"4&amp;nbsp;of&amp;nbsp;6\" rev=\"3\"><img class=\"aligncenter size-full wp-image-4036\" style=\"display: block\" title=\"100327003214\" src=\"http://www.centos.bz/wp-content/uploads/2012/08/100327003214.png\" alt=\"\" width=\"541\" height=\"237\"></a><br>\n<strong>SYN攻击</strong><br>\n   在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.<br>\n  Syn攻击就是 攻击客户端 \n在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直\n 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。<br>\n Syn攻击是一个典型的<a title=\"DDOS\" href=\"https://www.centos.bz/tag/ddos/\">DDOS</a>攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在<a title=\"Linux\" href=\"http://www.centos.bz/\">Linux</a>下可以如下命令检测是否被Syn攻击<br>\nnetstat -n -p TCP | grep SYN_RECV<br>\n一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.<br>\n但是不能完全防范syn攻击。<br>\n<strong>TCP 四次挥手</strong><br>\nTCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>\n<p><a class=\"pirobox_gall\" href=\"http://www.centos.bz/wp-content/uploads/2012/08/100327022731.jpg\" rel=\"5&amp;nbsp;of&amp;nbsp;6\" rev=\"4\"><img class=\"aligncenter size-full wp-image-4037\" style=\"display: block\" title=\"100327022731\" src=\"http://www.centos.bz/wp-content/uploads/2012/08/100327022731.jpg\" alt=\"\" width=\"717\" height=\"532\"></a></p>\n<p>\n\n参见wireshark抓包，实测的抓包结果并没有严格按挥手时序。我估计是时间间隔太短造成。<br>\n<a class=\"pirobox_gall last\" href=\"http://www.centos.bz/wp-content/uploads/2012/08/100327023334.png\" rel=\"6&amp;nbsp;of&amp;nbsp;6\" rev=\"5\"><img class=\"aligncenter size-full wp-image-4038\" style=\"display: block\" title=\"100327023334\" src=\"http://www.centos.bz/wp-content/uploads/2012/08/100327023334.png\" alt=\"\" width=\"799\" height=\"448\"></a><span style=\"background-color: rgba(255, 204, 0, 1)\">注意上面的字段标号地段和发送接收的内容序号，可能有个有错，记不住哪个了，后头要细看看</span></p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18pt\">第二部分：补充tcp连接过程</span></p>\n<p>&nbsp;</p>\n<div class=\"Blog_wz1\">\n<div class=\"showContent\">\n<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，如图1所示。</p>\n<p>&nbsp;(1) 第一次握手：建立连接时，客户端A发送SYN包(SYN=j)到服务器B，并进入SYN_SEND状态，等待服务器B确认。</p>\n<p>&nbsp;(2) 第二次握手：服务器B收到SYN包，必须确认客户A的SYN(ACK=j+1)，同时自己也发送一个SYN包(SYN=k)，即SYN+ACK包，此时服务器B进入SYN_RECV状态。</p>\n<p>&nbsp;(3) 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK(ACK=k+1)，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p>\n<p>完成三次握手，客户端与服务器开始传送数据。</p>\n<p align=\"center\">&nbsp;</p>\n<p class=\"a\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 图1 TCP三次握手建立连接</p>\n<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>\n<p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送(报文段4)。</p>\n<p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1(报文段5)。和SYN一样，一个FIN将占用一个序号。</p>\n<p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A(报文段6)。</p>\n<p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1(报文段7)。</p>\n<p>TCP采用四次挥手关闭连接如图2所示。</p>\n<p align=\"center\">&nbsp;</p>\n<p class=\"a\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图2 &nbsp;TCP四次挥手关闭连接</p>\n<p><strong>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p>\n<p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>\n<p>&nbsp;</p>\n<p><strong>2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？</strong></p>\n<p><strong>这个问题可以参考《unix 网络编程》（第三版，2.7 TIME_WAIT状态）。</strong></p>\n<p><strong>TIME_WAIT状态由两个存在的理由。</strong></p>\n<p><strong><strong>（1）可靠的实现TCP全双工链接的终止。</strong><br></strong></p>\n<p>这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。</p>\n<p align=\"left\">&nbsp;（2）允许老的重复的分节在网络中消逝。</p>\n<p align=\"left\">假\n设在12.106.32.254的1500端口和206.168.1.112.219的21端口之间有一个TCP连接。我们关闭这个链接，过一段时间后在\n相同的IP地址和端口建立另一个连接。后一个链接成为前一个的化身。因为它们的IP地址和端口号都相同。TCP必须防止来自某一个连接的老的重复分组在连\n接已经终止后再现，从而被误解成属于同一链接的某一个某一个新的化身。为做到这一点，TCP将不给处于TIME_WAIT状态的链接发起新的化身。既然\nTIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活msl秒即被丢弃，另一个方向上的应答最多存活msl秒也被丢弃。\n通过实施这个规则，我们就能保证每成功建立一个TCP连接时。来自该链接先前化身的重复分组都已经在网络中消逝了。</p>\n<p align=\"left\">&nbsp;</p>\n<p align=\"left\"><strong>3. 为什么不能用两次握手进行连接？</strong></p>\n<p align=\"left\">我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>\n&nbsp;&nbsp;&nbsp;   \n现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发\n \n送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S\n \n是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分\n 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>\n<p align=\"left\">&nbsp;</p>\n<p align=\"left\"><strong>补充：</strong></p>\n<p align=\"left\">a. 默认情况下(不改变socket选项)，当你调用close( or closesocket，以下说close不再重复)时，如果发送缓冲中还有数据，TCP会继续把数据发送完。</p>\n<p align=\"left\">b. 发送了FIN只是表示这端不能继续发送数据(应用层不能再调用send发送)，但是还可以接收数据。</p>\n<p align=\"left\">c. 应用层如何知道对端关闭？通常，在最简单的阻塞模型中，当你调用recv时，如果返回0，则表示对端关闭。在这个时候通常的做法就是也调用close，那么TCP层就发送FIN，继续完成四次握手。如果你不调用close，那么对端就会处于FIN_WAIT_2状态，而本端则会处于CLOSE_WAIT状态。这个可以写代码试试。</p>\n<p align=\"left\">d. 在很多时候，TCP连接的断开都会由TCP层自动进行，例如你CTRL+C终止你的程序，TCP连接依然会正常关闭，你可以写代码试试。</p>\n<p align=\"left\">&nbsp;</p>\n<p align=\"left\"><strong>插曲：</strong></p>\n<p>&nbsp;</p>\n<p>&nbsp;&nbsp; 特别的TIME_WAIT状态：</p>\n<p>&nbsp;</p>\n<p>&nbsp;&nbsp; 从以上TCP连接关闭的状态转换图可以看出，主动关闭的一方在发送完对对方FIN报文的确认(ACK)报文后，会进入TIME_WAIT状态。TIME_WAIT状态也称为2MSL状态。</p>\n<p>&nbsp;</p>\n<p>&nbsp;&nbsp; 什么是2MSL？MSL即Maximum Segment Lifetime，也就是报文最大生存时间，引用《TCP/IP详解》中的话：“它(MSL)是任何报文段被丢弃前在网络内的最长时间。”那么，2MSL也就是这个时间的2倍。其实我觉得没必要把这个MSL的确切含义搞明白，你所需要明白的是，当TCP连接完成四个报文段的交换时，主动关闭的一方将继续等待一定时间(2-4分钟)，即使两端的应用程序结束。你可以写代码试试，然后用setstat查看下。</p>\n<p>&nbsp;</p>\n<p>&nbsp;&nbsp; 为什么需要2MSL？根据《TCP/IP详解》和《The TCP/IP Guide》中的说法，有两个原因：</p>\n<p>&nbsp;&nbsp; 其一，保证发送的ACK会成功发送到对方，如何保证？我觉得可能是通过超时计时器发送。这个就很难用代码演示了。</p>\n<p>&nbsp;&nbsp; 其二，报文可能会被混淆，意思是说，其他时候的连接可能会被当作本次的连接。直接引用《The TCP/IP Guide》的说法：The second is to provide a “buffering period” between the end of this connection and any subsequent ones. If not for this period, it is possible that packets from different connections could be mixed, creating confusion.</p>\n<p>&nbsp;</p>\n<p>&nbsp;&nbsp; TIME_WAIT状态所带来的影响：</p>\n<p>&nbsp;&nbsp; 当某个连接的一端处于TIME_WAIT状态时，该连接将不能再被使用。事实上，对于我们比较有现实意义的是，这个端口将不能再被使用。某个端口处于TIME_WAIT状态(其实应该是这个连接)时，这意味着这个TCP连接并没有断开(完全断开)，那么，如果你bind这个端口，就会失败。对于服务器而言，如果服务器突然crash掉了，那么它将无法再2MSL内重新启动，因为bind会失败。解决这个问题的一个方法就是设置socket的SO_REUSEADDR选项。这个选项意味着你可以重用一个地址。</p>\n<p>&nbsp;</p>\n<p>&nbsp;&nbsp; 对于TIME_WAIT的插曲：</p>\n<p>&nbsp;&nbsp; 当建立一个TCP连接时，服务器端会继续用原有端口监听，同时用这个端口与客户端通信。而客户端默认情况下会使用一个随机端口与服务器端的监听端口通信。有时候，为了服务器端的安全性，我们需要对客户端进行验证，即限定某个IP某个特定端口的客户端。客户端可以使用bind来使用特定的端口。对于服务器端，当设置了SO_REUSEADDR选项时，它可以在2MSL内启动并listen成功。但是对于客户端，当使</p>\n<p>用bind并设置SO_REUSEADDR时，如果在2MSL内启动，虽然bind会成功，但是在windows平台上connect会失败。而在linux上则不存在这个问题。(我的实验平台：winxp, ubuntu7.10)</p>\n<p>&nbsp;&nbsp;&nbsp; 要解决windows平台的这个问题，可以设置SO_LINGER选项。SO_LINGER选项决定调用close时TCP的行为。SO_LINGER涉及到linger结构体，如果设置结构体中l_onoff为非0，l_linger为0，那么调用close时TCP连接会立刻断开，TCP不会将发送缓冲中未发送的数据发送，而是立即发送一个RST报文给对方，这个时候TCP连接就不会进入TIME_WAIT状态。如你所见，这样做虽然解决了问题，但是并不安全。通过以上方式设置SO_LINGER状态，等同于设置SO_DONTLINGER状态。</p>\n<p>&nbsp;</p>\n<p>&nbsp;&nbsp;&nbsp; 断开连接时的意外：</p>\n<p>&nbsp;&nbsp;&nbsp; 这个算不上断开连接时的意外，当TCP连接发生一些物理上的意外情况时，例如网线断开，linux上的TCP实现会依然认为该连接有效，而windows则会在一定时间后返回错误信息。这似乎可以通过设置SO_KEEPALIVE选项来解决，不过不知道这个选项是否对于所有平台都有效。</p>\n\n\n    \t\t</div>\n\n           </div>\n<p>&nbsp;</p>\n<p><span style=\"font-size: x-large\"><strong>第三部分：常见面试题</strong></span></p>\n<ul>\n<ul>\n<li><span style=\"font-size: medium\">TCP协议和UDP协议的区别是什么</span></li>\n<ul>\n<li><span style=\"font-size: medium\">TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的</span></li>\n<li><span style=\"font-size: medium\">TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。</span></li>\n<li><span style=\"font-size: medium\">TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。</span></li>\n<li><span style=\"font-size: medium\">TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率</span></li>\n<li><span style=\"font-size: medium\">TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。</span></li>\n<li><span style=\"font-size: medium\">TCP面向的是字节流的服务，UDP面向的是报文的服务。</span></li>\n<li><span style=\"font-size: medium\"><a href=\"http://www.cnblogs.com/newwy/archive/2013/08/02/3232503.html\">TCP介绍</a>和UDP介绍</span></li>\n</ul>\n<li><span style=\"font-size: medium\">请详细介绍一下TCP协议建立连接和终止连接的过程？</span></li>\n<ul>\n<li><span style=\"font-size: medium\">助于理解的<a href=\"http://www.cppblog.com/MemoryGarden/archive/2011/07/02/150007.html\">一段话</a></span></li>\n<li><span style=\"font-size: medium\">两幅图（<a href=\"http://www.cnblogs.com/newwy/archive/2013/08/03/3234536.html\">来源</a>）：</span></li>\n<ul>\n<li><span style=\"font-size: medium\">建立连接：三次握手</span></li>\n<li><a href=\"https://images0.cnblogs.com/blog/385532/201308/30193701-72f027c0ea0f4c69834076466fa5383c.png\"><img style=\"background-image: none; padding-top: 0; padding-left: 0; display: inline; padding-right: 0; border: 0\" title=\"image\" src=\"https://images0.cnblogs.com/blog/385532/201308/30193702-7287165c73e7440382207309e07fcbb5.png\" alt=\"image\" width=\"470\" height=\"272\" border=\"0\"></a></li>\n<li>关闭连接：四次挥手</li>\n<li><a href=\"https://images0.cnblogs.com/blog/385532/201308/30193703-63640062b79a4fc8b8ed31e95fd87bd8.png\"><img style=\"background-image: none; padding-top: 0; padding-left: 0; display: inline; padding-right: 0; border: 0\" title=\"image\" src=\"https://images0.cnblogs.com/blog/385532/201308/30193703-330b281cddc5439f99eb027ac1c9627c.png\" alt=\"image\" width=\"426\" height=\"298\" border=\"0\"></a></li>\n</ul>\n</ul>\n<li>三次握手建立连接时，发送方再次发送确认的必要性？</li>\n<ul>\n<ul>\n<li>主 要是为了防止已失效的连接请求报文段突然又传到了B,因而产生错误。假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结 点长时间滞留了，一直延迟到连接释放以后的某个时间才到达B，本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次 新的连接请求，于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了，这样一直等待A发来数据，B的许多 资源就这样白白浪费了。</li>\n</ul>\n</ul>\n<li>四次挥手释放连接时，等待2MSL的意义？</li>\n<ul>\n<ul>\n<li>第 一，为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK 报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。</li>\n<li>第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</li>\n</ul>\n</ul>\n</ul>\n</ul>\n<p>&nbsp;</p>\n<ul>\n<ul>\n<li><span style=\"font-size: medium\">常见的应用中有哪些是应用TCP协议的，哪些又是应用UDP协议的，为什么它们被如此设计？</span></li>\n<ul>\n<li><span style=\"font-size: medium\">以下应用一般或必须用udp实现？</span></li>\n<ul>\n<li><span style=\"font-size: medium\">多播的信息一定要用udp实现，因为tcp只支持一对一通信。</span></li>\n<li><span style=\"font-size: medium\">如果一个应用场景中大多是简短的信息，适合用udp实现，因为udp是基于报文段的，它直接对上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输效率。</span></li>\n<li><span style=\"font-size: medium\">如果一个应用场景重性能甚于重完整性和安全性，那么适合于udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达的速度快，因此比较适合用udp</span></li>\n<li><span style=\"font-size: medium\">如果要求快速响应，那么udp听起来比较合适</span></li>\n<li><span style=\"font-size: medium\">如果又要利用udp的快速响应优点，又想可靠传输，那么只能考上层应用自己制定规则了。</span></li>\n<li><span style=\"font-size: medium\">常见的使用udp的例子：ICQ,QQ的聊天模块。</span></li>\n</ul>\n<li><span style=\"font-size: medium\">以qq为例的一个说明（转载自<a href=\"http://www.zhihu.com/question/20292749\">知乎</a>）</span></li>\n</ul>\n</ul>\n</ul>\n<p>登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内网传文件采用了P2P技术。总来的说： <br>1.登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。            <br>2.和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。            <br>3.如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。</p>\n<p><a href=\"https://images0.cnblogs.com/blog/385532/201308/30193704-d65f24c7ddea474ab3236bd701650059.png\"><img style=\"background-image: none; padding-top: 0; padding-left: 0; display: inline; padding-right: 0; border: 0\" title=\"image\" src=\"https://images0.cnblogs.com/blog/385532/201308/30193705-accbdcad601c4d45b96392feea1bb63a.png\" alt=\"image\" width=\"409\" height=\"456\" border=\"0\"></a></p>\n<p>&nbsp;</p>\n</div>"
  },
  {
    "category": "network",
    "qes": "TCP协议如何保证可靠传输",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"markdown_views prism-atom-one-light\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display: none;\">\n                        <path stroke-linecap=\"round\" d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n                    </svg>\n                    <p>TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。这篇博客，我们就重点讨论一下TCP协议如何确保传输的可靠性的。</p> \n<h1 id=\"确保传输可靠性的方式\"><a name=\"t0\"></a><a name=\"t0\"></a>确保传输可靠性的方式</h1> \n<p>TCP协议保证数据传输可靠性的方式主要有：</p> \n<ul><li>校验和</li><li>序列号</li><li>确认应答</li><li>超时重传</li><li>连接管理</li><li>流量控制</li><li>拥塞控制</li></ul> \n<h2 id=\"校验和\"><a name=\"t1\"></a><a name=\"t1\"></a>校验和</h2> \n<p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。 <br> 发送方：在发送数据之前计算检验和，并进行校验和的填充。 <br> 接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p> \n<p><img src=\"https://img-blog.csdn.net/20180524102010286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\" title=\"\"></p> \n<p>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，<strong>数据不一定传输成功。</strong></p> \n<h2 id=\"确认应答与序列号\"><a name=\"t2\"></a><a name=\"t2\"></a>确认应答与序列号 </h2> \n<p>序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。 <br> 确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p> \n<p><img src=\"https://img-blog.csdn.net/20180524103121705?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\" title=\"\"></p> \n<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p> \n<h2 id=\"超时重传\"><a name=\"t3\"></a><a name=\"t3\"></a>超时重传</h2> \n<p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？</p> \n<p>首先，发送方没有介绍到响应的ACK报文原因可能有两点：</p> \n<ol><li>数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。</li><li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</li></ol> \n<p>TCP在解决这个问题的时候引入了一个新的机制，叫做超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。</p> \n<p>那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？</p> \n<p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。</p> \n<blockquote> \n <p>在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。</p> \n</blockquote> \n<h2 id=\"连接管理\"><a name=\"t4\"></a><a name=\"t4\"></a>连接管理</h2> \n<p>连接管理就是三次握手与四次挥手的过程，在前面详细讲过这个过程，这里不再赘述。保证可靠的连接，是保证可靠性的前提。</p> \n<h2 id=\"流量控制\"><a name=\"t5\"></a><a name=\"t5\"></a>流量控制</h2> \n<p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。</p> \n<p>在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。 <br> <img src=\"https://img-blog.csdn.net/20180524111634561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\" title=\"\"></p> \n<p>注：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。</p> \n<h2 id=\"拥塞控制\"><a name=\"t6\"></a><a name=\"t6\"></a>拥塞控制</h2> \n<p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p> \n<p>所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</p> \n<p>拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。 <br> <img src=\"https://img-blog.csdn.net/20180524125815394?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNoZW54aWE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\" title=\"\"></p> \n<p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p> \n<hr> \n<p>欢迎大家共同讨论，如有错误及时联系作者指出，并改正。谢谢大家！</p>\n                </div><div data-report-view=\"{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/liuchenxia8/article/details/80428157&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}\"><div></div></div>\n                <link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-10218d227c.css\" rel=\"stylesheet\">\n                <link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-6aa8c38f9a.css\" rel=\"stylesheet\">\n        </div>"
  },
  {
    "category": "network",
    "qes": "TCP连续ARQ协议和滑动窗口协议",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">TCP协议通过使用连续ARQ协议和滑动窗口协议，来保证数据传输的正确性，从而提供可靠的传输。</span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"color:rgb(51,102,255)\"><span style=\"font-size:14px\">一、ARQ协议</span></span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用<strong>确认</strong>和<strong>超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括<span style=\"color:#ff0000\">停止等待ARQ协议</span>和<span style=\"color:#ff0000\">连续ARQ协议</span>，拥有错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n</blockquote> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><strong><span style=\"font-size:14px\">（1）停止等待ARQ协议</span></strong></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">要想弄明白为什么TCP要使用连续ARQ协议，首先需要弄清楚停止等待ARQ协议的原理。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">TCP 连接是全双工的连接，也就是说在通信的时候，双方既是发送方，也是接收方。下面为了简化问题，只考虑一方发送，一方接受的情况。其中，A作为发送方，B作为接收方。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">1.无差错情况</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">A发送分组M1，发送完就暂停发送，等待B的确认。B收到M1就向A发送确认。A在收到了对M1的确认后，就再发送下一个分组M2。依次下去发送剩余的数据...如下图所示：</span></p> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n    <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n     <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n      <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313194700419\" alt=\"\"></span></p> \n     </blockquote> \n    </blockquote> \n   </blockquote> \n  </blockquote> \n  <p><span style=\"font-size:14px\">2.出现差错</span></p> \n  <p><span style=\"font-size:14px\">如果A发送的过程中出现差错，B在接收M1时检测出了差错，就丢弃M1，其他什么都不做（也不会通知A收到有差错的分组）。又或者A传送的过程中分组丢失了，以上这两种情况下，B不会发送任何信息。&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">既然说它是可靠传输协议，那自然有它可靠的方法：如果发生以上的情况，A只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，所以它会重传刚刚的发送过的分组，也就是所谓的<span style=\"color:#ff0000\">超时重传</span>。&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">超时重传的原理也很简单：发送方发送完一个分组后，就会设置一个<span style=\"color:rgb(255,0,0)\"><strong>超时计时器</strong></span>，如果超时计时器到期之前没有收到接收方发来的确认信息，则会重发刚发送过的分组；如果收到确认信息，则撤销该超时计时器。如下图所示：</span></p> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n    <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n     <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313194706822\" alt=\"\"></span></p> \n    </blockquote> \n   </blockquote> \n   <span style=\"font-size:14px\"><br> </span>\n  </blockquote> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\">\n  <span style=\"font-size:14px\">这里应该注意的是：</span>\n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">①既然发送方发送的分组可能丢失或者有差错，可能需要重传，那么它必须暂时保留已发送的分组副本，只有收到确认后，才清除这个副本。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">②分组和确认分组信息都应该有各自的编号，用来标示每一个分组和确认信息。（这样才知道需要发送哪个分组，收到了哪个分组的确认信息）</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">③超时计时器设置的时间应该略长于分组传送往返时间。</span></p> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\">\n  <span style=\"font-size:14px\"><br> </span>\n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n    <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n     <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313194711247\" alt=\"\"></span></p> \n    </blockquote> \n   </blockquote> \n  </blockquote> \n  <p><span style=\"font-size:14px\">3.确认丢失和确认延迟&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">没有正常进行通信，除了发送方出现问题外，接收方同时也可能存在问题。</span></p> \n  <p><span style=\"font-size:14px\">例如，如果A发送了M1分组，到达B，B发送了M1确认信息，但由于网络原因，该确认信息丢失。那么这个时候，A在超时重传时间内，没有收到B的确认信息，而且它并不知道是自己的分组有差错、丢失，还是B发生的确认丢失了。因此，A会在超时重传过后，重传M1分组。&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">接收方B会采取这两个行动：&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">①B会丢弃M1分组，不向上层交付。（B之前已经收到过M1分组了）&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">②向A发送确认（因为A重发了，肯定重传时间内没有收到确认信息）</span></p> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n    <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n     <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313195540266\" alt=\"\"></span></p> \n    </blockquote> \n   </blockquote> \n  </blockquote> \n  <span style=\"font-size:14px\">还有可能是另一种情况，就是B发送了确认，没有丢失，但是延迟了。也就是说，B发送的确认在A超时计时器过期后才到达。 这种情况下，A收到确认信息后会丢弃，然后重传刚才的分组，B收到后，丢弃重复的分组，并重传确认信息。<br> </span>\n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n    <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n     <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313194714900\" alt=\"\"></span></p> \n    </blockquote> \n   </blockquote> \n  </blockquote> \n  <p><span style=\"font-size:14px\"><br> </span></p> \n  <p><span style=\"font-size:14px\">根据上述的确认和重传机制，我们就可以在不可靠的网络上实现可靠的传输。</span></p> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">4.信道利用率</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">停止等待ARQ协议的优点是简答，但也有很严重的确定，就是信道利用率太低。如下图所示：</span></p> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <p style=\"margin:0 0 0 40px; border:none; padding:0px\"></p> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313194720810\" alt=\"\"></span></p> \n  </blockquote> \n  <p><span style=\"font-size:14px\"><br> </span></p> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <p><span style=\"font-size:14px\">信道利用率U = TD / (TD + RTT + TA)</span></p> \n  </blockquote> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\">\n <span style=\"font-size:14px\"><strong>（2）连续ARQ协议</strong></span>\n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">由于停止等待ARQ协议信道利用率太低，所以需要使用连续ARQ协议来进行改善。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">发送方采用流水线传输。流水线传输就是发送方可以连续发送多个分组，不必每发完一个分组就停下来等待对方确认。如下图所示：<br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313194725494\" alt=\"\"></span></p> \n  </blockquote> \n  <p><span style=\"font-size:14px\"><br> </span></p> \n  <p><span style=\"font-size:14px\">连续ARQ协议通常是结合滑动窗口协议来使用的，发送方需要维持一个发送窗口，如下图所示：</span></p> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n    <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><a target=\"_blank\" href=\"https://zh.wikipedia.org/wiki/ARQ\" rel=\"noopener noreferrer\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313194734979\" alt=\"\"></span></a></p> \n   </blockquote> \n  </blockquote> \n  <p><span style=\"font-size:14px\">图（a）是发送方维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，这样就提高了信道利用率。&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。例如上面的图（b），当发送方收到第一个分组的确认，就把发送窗口向前移动一个分组的位置。如果原来已经发送了前5个分组，则现在可以发送窗口内的第6个分组。&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">接收方一般都是采用<span style=\"color:#ff0000\">累积确认</span>的方式。也就是说接收方不必对收到的分组逐个发送确认。而是在收到几个分组后，<span style=\"color:#ff0000\">对按序到达的最后一个分组发送确认</span>。如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。&nbsp;</span></p> \n  <p><span style=\"font-size:14px\">累积确认的优点是容易实现，即使确认丢失也不必重传。但缺点是，不能正确的向发送方反映出接收方已经正确收到的所以分组的信息。比如发送方发送了前5个分组，而中间的第3个分组丢失了，这时候接收方只能对前2个发出确认。而不知道后面3个分组的下落，因此只能把后面的3个分组都重传一次，这种机制叫<span style=\"color:#ff0000\">Go-back-N（回退N）</span>，表示需要再退回来重传已发送过的N个分组。</span></p> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n</blockquote> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"color:rgb(51,102,255)\"><span style=\"font-size:14px\">二、滑动窗口协议</span></span></p> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">滑动窗口协议在在发送方和接收方之间各自维持一个滑动窗口，发送发是发送窗口，接收方是接收窗口，而且这个窗口是随着时间变化可以向前滑动的。它允许发送方发送多个分组而不需等待确认。TCP的滑动窗口是以字节为单位的。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">如下图所示，发送窗口中有四个概念：：已发送并收到确认的数据（不在发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之内）、允许发送但尚未发送的数据（位于发送窗口之内）、发送窗口之外的缓冲区内暂时不允许发送的数据。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">接收窗口中也有四个概念：已发送确认并交付主机的数据（不在接收窗口和接收缓冲区之内）、未按序收到的数据（位于接收窗口之内）、允许的数据（位于接收窗口之内）、不允许接收的数据（位于发送窗口之内）。<br> </span></p> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313203419859\" alt=\"\"></span></p> \n  </blockquote> \n </blockquote> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">规则：</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">（1）凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">（2）只有当发送方A收到了接收方的确认报文段时，发送方窗口才可以向前滑动几个序号。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">（3）当发送方A发送的数据经过一段时间没有收到确认（由超时计时器控制），就要使用回退N步协议，回到最后接收到确认号的地方，重新发送这部分数据。</span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">此外，TCP利用滑动窗口协议来进行<span style=\"color:#ff0000\">流量控制</span>，如下图所示：</span></p> \n</blockquote> \n<blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n  <blockquote style=\"margin:0 0 0 40px; border:none; padding:0px\"> \n   <p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20160313204914823\" alt=\"\"><br> </span></p> \n  </blockquote> \n </blockquote> \n</blockquote> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">参考资料：</span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">1、ARQ-维基百科&nbsp;<a target=\"_blank\" href=\"https://zh.wikipedia.org/wiki/ARQ\" rel=\"noopener noreferrer\">https://zh.wikipedia.org/wiki/ARQ</a></span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">2、TCP/IP（三） —— 可靠传输工作原理<a target=\"_blank\" href=\"http://pmghong.blog.51cto.com/3221425/1242470\" rel=\"noopener noreferrer\">&nbsp;http://pmghong.blog.51cto.com/3221425/1242470</a></span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">3、TCP可靠传输&amp;流量控制&amp;拥塞控制 &nbsp;<a target=\"_blank\" href=\"http://my.oschina.net/manmao/blog/601585\" rel=\"noopener noreferrer\">http://my.oschina.net/manmao/blog/601585</a></span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">4、计算机网络【七】：可靠传输的实现&nbsp;<a target=\"_blank\" href=\"http://blog.chinaunix.net/uid-26275986-id-4109679.html\" rel=\"noopener noreferrer\">http://blog.chinaunix.net/uid-26275986-id-4109679.html</a></span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\">5、TCP/IP之TCP协议（3）：流量控制（滑动窗口协议）<a target=\"_blank\" href=\"http://blog.csdn.net/wbw1985/article/details/4879224\" rel=\"noopener noreferrer\">http://blog.csdn.net/wbw1985/article/details/4879224</a></span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p> \n<p style=\"margin:0 0 0 40px; border:none; padding:0px\"><span style=\"font-size:14px\"><br> </span></p>\n                </div><div data-report-view=\"{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/guoweimelon/article/details/50879588&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}\"><div></div></div>\n        </div>"
  },
  {
    "category": "network",
    "qes": "在浏览器中输入url地址到显示主页的过程",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"markdown_views prism-atom-one-dark\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display: none;\">\n                        <path stroke-linecap=\"round\" d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n                    </svg>\n                    <p>图解（图片来源：《图解HTTP》）：</p> \n<p><img src=\"https://img-blog.csdnimg.cn/20190420144503706.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RUVFpaWlRUVFpaWg==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p> \n<p>总体来说分为以下几个过程:</p> \n<ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol> \n<h2><a name=\"t0\"></a><a name=\"t0\"></a><a id=\"_13\"></a><strong>具体过程</strong></h2> \n<h3><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"DNS_14\"></a><strong>DNS解析</strong></h3> \n<p>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，<a href=\"http://xn--www-uc0ep96b.baidu.com\">例如www.baidu.com</a>，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的?</p> \n<p>解析过程<br> DNS解析是一个递归查询的过程。<br> <img src=\"https://img-blog.csdnimg.cn/2019021314255173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RUVFpaWlRUVFpaWg==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br> 上述图片是查找www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; <a href=\"http://google.com\">google.com</a> -&gt; <a href=\"http://www.google.com\">www.google.com</a>。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，<a href=\"http://xn--www-cs6et69dkeh2jun9at96b.google.com\">真正的网址是www.google.com</a>.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; <a href=\"http://google.com\">google.com</a>. -&gt; <a href=\"http://www.google.com\">www.google.com</a>.</p> \n<p><strong>DNS优化</strong></p> \n<p>了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。</p> \n<p><strong>DNS缓存</strong></p> \n<p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p> \n<ul><li>在你的chrome浏览器中输入:chrome://net-internals/#dns，你可以看到chrome浏览器的DNS缓存。</li><li>系统缓存主要存在/etc/hosts(Linux系统)中:<br> <img src=\"https://img-blog.csdnimg.cn/20190213142946585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RUVFpaWlRUVFpaWg==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li></ul> \n<p><strong>DNS负载均衡</strong></p> \n<p>不知道大家有没有思考过一个问题: DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p> \n<h3><a name=\"t2\"></a><a name=\"t2\"></a><a id=\"TCP_39\"></a><strong>TCP连接</strong></h3> \n<p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p> \n<p><strong>HTTPS协议</strong></p> \n<p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。<br> <img src=\"https://img-blog.csdnimg.cn/20190213143351436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RUVFpaWlRUVFpaWg==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p> \n<p><strong>HTTPS过程</strong></p> \n<p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。<br> HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。</p> \n<h3><a name=\"t3\"></a><a name=\"t3\"></a><a id=\"HTTP_53\"></a><strong>发送HTTP请求</strong></h3> \n<p>其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: <strong>请求行, 请求报头和请求正文</strong>。</p> \n<p><strong>请求行</strong></p> \n<p>格式如下:<br> Method Request-URL HTTP-Version CRLF</p> \n<pre class=\"prettyprint\"><code class=\"has-numbering\" onclick=\"mdcp.signin(event)\" style=\"position: unset;\">eg: GET index.html HTTP/1.1\n<div class=\"hljs-button signin\" data-title=\"登录后复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\"></div></code><ul class=\"pre-numbering\" style=\"\"><li style=\"color: rgb(153, 153, 153);\">1</li></ul></pre> \n<p>常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。</p> \n<p><strong>请求报头</strong></p> \n<p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br> PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br> 常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。<br> <img src=\"https://img-blog.csdnimg.cn/20190213144119299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RUVFpaWlRUVFpaWg==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br> 上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p> \n<p><strong>请求正文</strong></p> \n<p>当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。</p> \n<h3><a name=\"t4\"></a><a name=\"t4\"></a><a id=\"HTTP_78\"></a>服务器处理请求并返回HTTP报文</h3> \n<p>自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。</p> \n<p>HTTP响应报文也是由三部分组成: <strong>状态码, 响应报头和响应报文</strong>。</p> \n<p><strong>状态码</strong></p> \n<p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p> \n<ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul> \n<p>平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。</p> \n<p><strong>响应报头</strong></p> \n<p>常见的响应报头字段有: Server, Connection…</p> \n<p><strong>响应报文</strong></p> \n<p>服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分</p> \n<h1><a name=\"t5\"></a><a name=\"t5\"></a><a id=\"_103\"></a>浏览器解析渲染页面</h1> \n<p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。<br> <img src=\"https://img-blog.csdnimg.cn/20190213145222658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RUVFpaWlRUVFpaWg==,size_16,color_FFFFFF,t_70\" alt=\"\"><br> 浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。<br> <img src=\"https://img-blog.csdnimg.cn/20190213145301250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RUVFpaWlRUVFpaWg==,size_16,color_FFFFFF,t_70\" alt=\"\"><br> JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p> \n<p>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</p> \n<h1><a name=\"t6\"></a><a name=\"t6\"></a><a id=\"Web_113\"></a>Web优化</h1> \n<p>上面部分主要介绍了一次完整的请求对应的过程，了解该过程的目的无非就是为了Web优化。在谈到Web优化之前，我们回到一个更原始的问题，Web前端的本质是什么。我的理解是: 将信息快速并友好的展示给用户并能够与用户进行交互。快速的意思就是在尽可能短的时间内完成页面的加载，试想一下当你在淘宝购买东西的时候，淘宝页面加载了10几秒才显示出物品，这个时候你还有心情去购买吗？</p> \n<p>如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。</p>\n                </div><div data-report-view=\"{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/TTTZZZTTTZZZ/article/details/87214111&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}\"><div></div></div>\n                <link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-10218d227c.css\" rel=\"stylesheet\">\n                <link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-6aa8c38f9a.css\" rel=\"stylesheet\">\n        </div>"
  },
  {
    "category": "network",
    "qes": "计算及网络的各个状态码",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body cnblogs-markdown\">\n    <h2 id=\"前言\">前言</h2>\n<p>我想现在在上网的人，不可能不会不遇见到这种事情，就是我们在浏览器进入一个网页时，有时候网页会给你报错，例如下图出现的错误：</p>\n<p><img src=\"https://img2020.cnblogs.com/blog/2064879/202011/2064879-20201112223520500-1701503640.jpg\" alt=\"\" loading=\"lazy\"></p>\n<p>而图中显示的404就是我们所访问网页的浏览器返回的一个<strong>HTTP状态码</strong>，所以说HTTP状态码是会出现在我们上网的过程，它是互联网不可缺少的一部分,而且学习好HTTP状态码对我们了解互联网有很大的帮助。</p>\n<h2 id=\"什么是http状态码\">什么是HTTP状态码</h2>\n<p>首先我们先解释一下HTTP状态码是啥，<strong>HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码</strong>。</p>\n<p>所以我们可以知道HTTP状态码是由3位数字代码显示的，而且它的<strong>第一位数字代表了响应的类型</strong>，后两位则没有分类的作用。</p>\n<p>那HTTP状态码有什么用呢？</p>\n<p>当我们请求访问一个网站的时候，我们的浏览器会向网站的服务器发送一个请求。而服务器收到请求后便会发送一个包含HTTP状态码的消息头，以响应浏览器的请求，而浏览器通过HTTP状态码来判断下一步该执行什么操作，所以说我们可以用HTTP状态码来了解当前Web服务器的运行状况。</p>\n<h2 id=\"http状态码的分类\">HTTP状态码的分类</h2>\n<p>了解完什么是HTTP状态码后，我们要对HTTP状态码进行一个分类，HTTP状态码一般可以分为五类：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center\">类型</th>\n<th style=\"text-align: center\">类型说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">100-199</td>\n<td style=\"text-align: center\">接受的请求正在处理</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">200-299</td>\n<td style=\"text-align: center\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">300-399</td>\n<td style=\"text-align: center\">需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">400-499</td>\n<td style=\"text-align: center\">客户端请求出错，服务器无法处理请求</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">500-599</td>\n<td style=\"text-align: center\">服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"各类http状态码的说明\">各类HTTP状态码的说明</h2>\n<h3 id=\"100-199的状态码：\">100-199的状态码：</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center\">代码</th>\n<th>代码说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">100</td>\n<td>请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">101</td>\n<td>请求者已要求服务器切换协议，服务器已确认并准备进行切换。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"200-299的状态码\">200-299的状态码</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center\">代码</th>\n<th>代码说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">200</td>\n<td>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt 文件显示为此状态，那么，这表示 Googlebot 已成功检索到该文件。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">201</td>\n<td>请求成功且服务器已创建了新的资源。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">202</td>\n<td>服务器已接受了请求，但尚未对其进行处理。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">203</td>\n<td>服务器已成功处理了请求，但返回了可能来自另一来源的信息。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">204</td>\n<td>服务器成功处理了请求，但未返回任何内容。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">205</td>\n<td>服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">206</td>\n<td>服务器成功处理了部分 GET 请求。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"300-399的状态码\">300-399的状态码</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center\">代码</th>\n<th>代码说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">300</td>\n<td>服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">301</td>\n<td>请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久移动到新位置。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">302</td>\n<td>服务器正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">303</td>\n<td>当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">304</td>\n<td>自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">305</td>\n<td>请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">307</td>\n<td>服务器正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"400-499的状态码\">400-499的状态码</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center\">代码</th>\n<th>代码说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">400</td>\n<td>服务器不理解请求的语法。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">401</td>\n<td>请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">403</td>\n<td>服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码（您可在 Google 网站管理员工具中诊断下的网络抓取页面上看到此状态代码），那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">404</td>\n<td>服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具\"诊断\"标签的 robots.txt 页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。（该文件应当位于顶级域名上，且应当名为 robots.txt）。如果您在 Googlebot 尝试抓取的网址上发现此状态（位于\"诊断\"标签的 HTTP 错误页上），那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">405</td>\n<td>禁用请求中所指定的方法。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">406</td>\n<td>无法使用请求的内容特性来响应请求的网页。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">407</td>\n<td>此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">408</td>\n<td>服务器等候请求时超时。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">409</td>\n<td>服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">410</td>\n<td>如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">411</td>\n<td>服务器不会接受包含无效内容长度标头字段的请求。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">412</td>\n<td>服务器未满足请求者在请求中设置的其中一个前提条件。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">413</td>\n<td>服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">414</td>\n<td>请求的 URI（通常为网址）过长，服务器无法进行处理。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">415</td>\n<td>请求的格式不受请求页面的支持。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">416</td>\n<td>如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">417</td>\n<td>服务器未满足\"期望\"请求标头字段的要求。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"500-599的状态码\">500-599的状态码</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align: center\">代码</th>\n<th>代码说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align: center\">500</td>\n<td>服务器遇到错误，无法完成请求。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">501</td>\n<td>服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">502</td>\n<td>服务器作为网关或代理，从上游服务器收到了无效的响应。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">503</td>\n<td>无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">504</td>\n<td>服务器作为网关或代理，未及时从上游服务器接收请求。</td>\n</tr>\n<tr>\n<td style=\"text-align: center\">505</td>\n<td>服务器不支持请求中所使用的 HTTP 协议版本。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"结尾\">结尾</h2>\n<p>HTTP状态码暂时就说这么多了，在未来的互联网会越发复杂，肯定会出现更多的状态码，不过这都是后话了，感谢各位的观看。</p>\n\n</div>"
  },
  {
    "category": "network",
    "qes": "各种协议与HTTP协议之间的关系",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"markdown_views prism-atom-one-dark\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display: none;\">\n                        <path stroke-linecap=\"round\" d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n                    </svg>\n                    <h3 id=\"当我们在浏览器地址栏中输入一个网址时发生了什么呢\"><a name=\"t0\"></a><a name=\"t0\"></a>当我们在浏览器地址栏中输入一个网址时发生了什么呢？</h3> \n<p><img src=\"https://img-blog.csdn.net/20180203130314494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzczMzExMTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"HTTP与其他协议之间的关系\" title=\"\"></p> \n<h4 id=\"上面这张图片能够很好的解释发生了什么首先发给dns服务器进行域名解析得到ip地址后生成针对目标web服务器的http请求报文然后报文由tcp协议负责传输为了方便通信http请求报文被分为报文段然后每个报文段可靠的传输给对方然后报文段由ip层负责一边中转一遍传送服务器收到报文段后重组报文段然后由应用层的http协议处理请求的内容请求的结果以-同样的方式进行回传\">上面这张图片能够很好的解释发生了什么。首先发给DNS服务器，进行域名解析，得到IP地址后生成针对目标Web服务器的HTTP请求报文，然后报文由TCP协议负责传输，为了方便通信，HTTP请求报文被分为报文段，然后每个报文段可靠的传输给对方，然后报文段由IP层负责一边中转一遍传送，服务器收到报文段后重组报文段，然后由应用层的HTTP协议处理请求的内容，请求的结果以 同样的方式进行回传。</h4> \n<h3 id=\"那么各部分是怎么完成工作的呢\"><a name=\"t1\"></a><a name=\"t1\"></a>那么各部分是怎么完成工作的呢？</h3> \n<h4 id=\"dns解析方式\">DNS解析方式</h4> \n<ol><li>递归查询 <br> 由客户机向DNS服务器发出请求，如果该DNS服务器为被授权的服务器，且它能够回应该请求，则返回给客户机，若不能，则该DNS服务器则向它认为能够给我结果的DNS服务器发出请求，以此类推，得到结果后逐级返回。</li><li>迭代查询 <br> 由客户机向DNS服务器发出请求，如果该DNS服务器为被授权的服务器，且它能够回应该请求，则返回给客户机，若不能，该DNS服务器则向客户机返回一个可能给出结果的DNS服务器地址，客户机再向这个地址发出请求，以此类推，最终可能得到结果，也可能得不到结果。</li></ol> \n<h4 id=\"其他的协议在图中有简单的介绍由于涉及太广就不累述了\">其他的协议在图中有简单的介绍，由于涉及太广，就不累述了。</h4>\n                </div><div data-report-view=\"{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/qq_37331119/article/details/79246331&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}\"><div></div></div>\n                <link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-10218d227c.css\" rel=\"stylesheet\">\n                <link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-6aa8c38f9a.css\" rel=\"stylesheet\">\n        </div>"
  },
  {
    "category": "network",
    "qes": "HTTP长连接，短连接",
    "ans": "<div class=\"postBody\">\n                \n<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <div class=\"box-title\">\n<p><strong><span style=\"font-size: 1.5em\">1. HTTP协议与TCP/IP协议的关系</span></strong></p>\n</div>\n<div id=\"docArticleContent\">\n<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。</p>\n<h2 id=\"2.-.E5.A6.82.E4.BD.95.E7.90.86.E8.A7.A3http.E5.8D.8F.E8.AE.AE.E6.98.AF.E6.97.A0.E7.8A.B6.E6.80.81.E7.9A.84\">2. 如何理解HTTP协议是无状态的</h2>\n<p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>\n<h2 id=\"3.-.E4.BB.80.E4.B9.88.E6.98.AF.E9.95.BF.E8.BF.9E.E6.8E.A5.E3.80.81.E7.9F.AD.E8.BF.9E.E6.8E.A5.EF.BC.9F\">3. 什么是长连接、短连接？</h2>\n<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>\n<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\"><span class=\"hljs-attribute\">Connection</span><span class=\"hljs-selector-pseudo\">:keep-alive\n</span></span></code></pre>\n<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>\n<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>\n<h3 id=\"3.1.-tcp.E8.BF.9E.E6.8E.A5\">3.1. TCP连接</h3>\n<p>当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。</p>\n<p>经典的三次握手建立连接示意图：<br><img src=\"https://mccdn.qcloud.com/static/img/da079414fde193f4d790c72a719eba78/image.jpg\" alt=\"\"></p>\n<p><img src=\"https://images2015.cnblogs.com/blog/593345/201702/593345-20170204231325729-1747734402.png\" alt=\"\"></p>\n<p>经典的四次握手关闭连接示意图：<br><img src=\"https://mccdn.qcloud.com/static/img/4e7b6439145e3db6c0a2ff62eec24322/image.jpg\" alt=\"\"></p>\n<p><img src=\"https://images2015.cnblogs.com/blog/593345/201702/593345-20170204231344745-1817753534.jpg\" alt=\"\"></p>\n<h3 id=\"3.2.-tcp.E7.9F.AD.E8.BF.9E.E6.8E.A5\">3.2. TCP短连接</h3>\n<p>模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。</p>\n<p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</p>\n<h3 id=\"3.3.-tcp.E9.95.BF.E8.BF.9E.E6.8E.A5\">3.3. TCP长连接</h3>\n<p>我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>\n<p>TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</p>\n<p>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：</p>\n<ul>\n<li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li>\n<li>客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li>\n<li>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li>\n<li>客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</li>\n\n\n\n\n\n\n\n\n\n\n\n\n</ul>\n<h2 id=\"4.-.E9.95.BF.E8.BF.9E.E6.8E.A5.E5.92.8C.E7.9F.AD.E8.BF.9E.E6.8E.A5.E7.9A.84.E4.BC.98.E7.82.B9.E5.92.8C.E7.BC.BA.E7.82.B9\">4. 长连接和短连接的优点和缺点</h2>\n<p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。</p>\n<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。</p>\n<p>长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。</p>\n<p>由上可以看出，<strong>长连接</strong>可以<strong>省去较多的TCP建立和关闭的操作，减少浪费，节约时间</strong>。对于频繁请求资源的客户来说，较适用长连接。不过这里<strong>存在一个问题</strong>，<strong>存活功能的探测周期太长</strong>，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，<strong>Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候</strong>，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>\n<p><strong>短连接</strong>对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户<strong>请求频繁</strong>，将在<strong>TCP的建立和关闭操作上浪费时间和带宽</strong>。</p>\n<p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p>\n<h2><strong>长连接短连接操作过程</strong></h2>\n<pre><strong>短连接</strong>的操作步骤是：</pre>\n<pre>建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接</pre>\n<pre><strong>长连接</strong>的操作步骤是：</pre>\n<pre>建立连接——数据传输...（保持连接）...数据传输——关闭连接</pre>\n<h2><strong>什么时候用长连接，短连接？</strong>&nbsp;&nbsp;　　</h2>\n<p><strong>长连接</strong>多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。&nbsp;<br>&nbsp;&nbsp;<br>　　而像WEB网站的http服务一般都用<strong>短链接</strong>，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>\n<p>&nbsp;</p>\n<h1 class=\"title\">http和socket之长连接和短连接区别</h1>\n<p>http://www.jianshu.com/p/b68d2b26f5f4</p>\n<p>&nbsp;</p>\n<h1>HTTP 的长连接和短连接</h1>\n<p>http://blog.jobbole.com/104108/</p>\n<p>&nbsp;</p>\n<h1 id=\"firstHeading\" class=\"firstHeading\" lang=\"zh-CN\">HTTP持久连接</h1>\n<p>https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5</p>\n<p>&nbsp;</p>\n<p>长连接</p>\n<p>http://baike.baidu.com/view/2831907.htm</p>\n\n\n\n\n\n\n\n\n\n\n\n\n</div>\n</div>\n<div id=\"MySignature\"></div>\n<div class=\"clear\"></div>\n<div id=\"blog_post_info_block\">\n<div id=\"EntryTag\">\n    标签: \n            <a href=\"https://www.cnblogs.com/gotodsp/tag/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/\">计算机网络</a>,             <a href=\"https://www.cnblogs.com/gotodsp/tag/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/\">网络协议</a>,             <a href=\"https://www.cnblogs.com/gotodsp/tag/HTTP/\">HTTP</a>,             <a href=\"https://www.cnblogs.com/gotodsp/tag/TCP/\">TCP</a></div>\n\n    <div id=\"blog_post_info\">\n<div id=\"green_channel\">\n        <a href=\"javascript:void(0);\" id=\"green_channel_digg\" onclick=\"DiggIt(6366163,cb_blogId,1);green_channel_success(this,'谢谢推荐！');\">好文要顶</a>\n        <a id=\"green_channel_follow\" onclick=\"follow('dc0cfc8b-6969-e311-8d02-90b11c0b17d6');\" href=\"javascript:void(0);\">关注我</a>\n    <a id=\"green_channel_favorite\" onclick=\"AddToWz(cb_entryId);return false;\" href=\"javascript:void(0);\">收藏该文</a>\n    <a id=\"green_channel_weibo\" href=\"javascript:void(0);\" title=\"分享至新浪微博\" onclick=\"ShareToTsina()\"><img src=\"https://common.cnblogs.com/images/icon_weibo_24.png\" alt=\"\"></a>\n    <a id=\"green_channel_wechat\" href=\"javascript:void(0);\" title=\"分享至微信\" onclick=\"shareOnWechat()\"><img src=\"https://common.cnblogs.com/images/wechat.png\" alt=\"\"></a>\n</div>\n<div id=\"author_profile\">\n    <div id=\"author_profile_info\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/gotodsp/\" target=\"_blank\"><img src=\"https://pic.cnblogs.com/face/593345/20140716153435.png\" class=\"author_avatar\" alt=\"\"></a>\n        <div id=\"author_profile_detail\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/gotodsp/\">dai.sp</a><br>\n            <a href=\"https://home.cnblogs.com/u/gotodsp/followees/\">关注 - 57</a><br>\n            <a href=\"https://home.cnblogs.com/u/gotodsp/followers/\">粉丝 - 114</a>\n        </div>\n    </div>\n    <div class=\"clear\"></div>\n    <div id=\"author_profile_honor\"></div>\n    <div id=\"author_profile_follow\">\n                <a href=\"javascript:void(0);\" onclick=\"follow('dc0cfc8b-6969-e311-8d02-90b11c0b17d6');return false;\">+加关注</a>\n    </div>\n</div>\n<div id=\"div_digg\">\n    <div class=\"diggit\" onclick=\"votePost(6366163,'Digg')\">\n        <span class=\"diggnum\" id=\"digg_count\">29</span>\n    </div>\n    <div class=\"buryit\" onclick=\"votePost(6366163,'Bury')\">\n        <span class=\"burynum\" id=\"bury_count\">0</span>\n    </div>\n    <div class=\"clear\"></div>\n    <div class=\"diggword\" id=\"digg_tips\">\n    </div>\n</div>\n\n<script type=\"text/javascript\">\n    currentDiggType = 0;\n</script></div>\n    <div class=\"clear\"></div>\n    <div id=\"post_next_prev\">\n\n    <a href=\"https://www.cnblogs.com/gotodsp/p/6364677.html\" class=\"p_n_p_prefix\">« </a> 上一篇：    <a href=\"https://www.cnblogs.com/gotodsp/p/6364677.html\" title=\"发布于 2017-02-04 15:11\">分布式服务框架Dubbo</a>\n    <br>\n    <a href=\"https://www.cnblogs.com/gotodsp/p/6368277.html\" class=\"p_n_p_prefix\">» </a> 下一篇：    <a href=\"https://www.cnblogs.com/gotodsp/p/6368277.html\" title=\"发布于 2017-02-05 18:15\">Linux Shell下”&gt;/dev/null 2&gt;&amp;1“相关知识说明</a>\n\n</div>\n</div>\n            </div>"
  },
  {
    "category": "network",
    "qes": "HTTP是不保存状态的协议，如何保存用户状态",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"markdown_views prism-github-gist\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" style=\"display: none;\">\n                        <path stroke-linecap=\"round\" d=\"M5,0 0,2.5 5,5z\" id=\"raphael-marker-block\" style=\"-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\"></path>\n                    </svg>\n                    <p></p>\n<div class=\"toc\">\n <h3><a name=\"t0\"></a><a name=\"t0\"></a>http无状态协议如何保存用户状态</h3>\n <ul><li><a href=\"#http_1\" target=\"_self\">http无状态协议如何保存用户状态？</a></li></ul>\n</div>\n<p></p> \n<h1><a name=\"t1\"></a><a name=\"t1\"></a><a id=\"http_1\"></a>http无状态协议如何保存用户状态？</h1> \n<p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理</p> \n<p><img src=\"https://img-blog.csdnimg.cn/2019080522021342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h4eHh4eHh4eHh4eW4=,size_16,color_FFFFFF,t_70\" alt=\"图片出自图解http\"><br> <strong>常见的有以下两种解决方案：</strong></p> \n<ol><li>基于Session实现的会话保持<br> 在会话开始时（客户端第一次像服务器发送http请求），服务器将会话状态保存起来（本机内存或数据库中），然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端Cookie中，以后每次浏览器发送http请求都会带上Cookie中的SessionId到服务器，服务器拿到会话标识就可以把之前存储在服务器端的状态信息与会话联系起来，实现会话保持（如果遇到浏览器禁用Cookie的情况，则可以通过url重写的方式将会话标识放在url的参数里，也可实现会话保持）</li><li>基于Cookie实现的会话保持<br> 基于Cookie实现会话保持与上述基于Session实现会话保持的最主要区别是前者完全将会话状态信息存储在浏览器Cookie中，这样一来每次浏览器发送HTTP请求的时候都会带上状态信息，因此也就可以实现状态保持。</li></ol> \n<p><strong>两者优缺点</strong></p> \n<ol><li>基于Session的会话保持优点是安全性较高，因为状态信息保存在服务器端。缺点是不便于服务器的水平扩展。大型网站的后台一般都不止一台服务器，可能几台甚至上百台，浏览器发送的HTTP请求一般要先通过负载均衡器才能到达具体的后台服务器，这就会导致每次HTTP请求可能落到不同的服务器上，比如说第一次HTTP请求落到server1上，第二次HTTP请求落到server2上。而Session默认是存储在服务器本机内存的，当多次请求落到不同的服务器上时，上述方案就不能实现会话保持了（常用解决方案是中间件，例如Redis，将Session的信信息存储在Redis中，这样每个server就都可以访问到）。</li><li>基于Cookie的会话保持的优点是服务器不用保存状态信息，减轻服务端存储压力，也便于服务端做水平扩展。缺点是不够安全，因为状态信息是存储在客户端的，这意味着不能在会话中保存机密数据，另一个缺点是每次HTTP请求都需要发送额外的Cookie到服务端，会消耗更多带宽。</li></ol> \n<blockquote> \n <p>参考：<a href=\"https://blog.csdn.net/hzjjames/article/details/81143934\">https://blog.csdn.net/hzjjames/article/details/81143934</a><br> 参考：图解http 链接：<a href=\"https://pan.baidu.com/s/1VtKk1E9TpRzvi6XLWLQM9A\">https://pan.baidu.com/s/1VtKk1E9TpRzvi6XLWLQM9A</a><br> 提取码：pn3z</p> \n</blockquote>\n                </div><div data-report-view=\"{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/xxxxxxxxxxxyn/article/details/98530211&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}\"><div></div></div>\n                <link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-10218d227c.css\" rel=\"stylesheet\">\n                <link href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-6aa8c38f9a.css\" rel=\"stylesheet\">\n        </div>"
  },
  {
    "category": "network",
    "qes": "Token ，Cookie和Session的区别",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <p>在做接口测试时，经常会碰到请求参数为token的类型，但是可能大部分测试人员对token，cookie，session的区别还是一知半解。</p>\n<p>&nbsp;</p>\n<h2 id=\"cookie\"><a name=\"t0\"></a><strong>Cookie</strong></h2>\n<p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p>\n<p><span style=\"color: rgba(255, 0, 0, 1)\">cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。</span>由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p>\n<h2 id=\"session\"><a name=\"t1\"></a><strong>Session</strong></h2>\n<p>session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。</p>\n<p>session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，<span style=\"color: rgba(255, 0, 0, 1)\">服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。</span>至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。</p>\n<p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p>\n<h2 id=\"token\"><a name=\"t2\"></a><strong>Token</strong></h2>\n<p><span style=\"color: rgba(255, 0, 0, 1)\">Token的引入</span>：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p>\n<p><span style=\"color: rgba(255, 0, 0, 1)\">Token的定义</span>：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。</p>\n<p><span style=\"color: rgba(255, 0, 0, 1)\">使用Token的目的</span>：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>\n<p>&nbsp;</p>\n<h2 id=\"传统身份验证\"><a name=\"t3\"></a><strong>传统身份验证</strong></h2>\n<p>HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。</p>\n<p>解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p>\n<p>上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。</p>\n<h2 id=\"基于-token-的身份验证\"><a name=\"t4\"></a><strong>基于 Token 的身份验证</strong></h2>\n<p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p>\n<ul>\n<li>客户端使用用户名跟密码请求登录</li>\n<li>服务端收到请求，去验证用户名与密码</li>\n<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>\n<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li>\n<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>\n<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>\n</ul>\n<p>APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到APP，以后APP请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上token设置一个有效期，每次APP请求的时候都验证token和有效期。</p>\n<p>那么我的问题来了： 1.服务器上的token存储到数据库中，每次查询会不会很费时。如果不存储到数据库，应该存储到哪里呢。 2.客户端得到的token肯定要加密存储的，发送token的时候再解密。存储到数据库还是配置文件呢？</p>\n<p>token是个易失数据，丢了无非让用户重新登录一下，新浪微博动不动就让我重新登录，反正这事儿我是无所谓啦。 <br>\n所以如果你觉得普通的数据库表撑不住了，可以放到 MSSQL/MySQL 的内存表里（不过据说mysql的内存表性能提升有限），可以放到 Memcache里（讲真，这个是挺常见的策略），可以放到redis里（我做过这样的实现），甚至可以放到 OpenResty 的变量字典里（只要你有信心不爆内存）。</p>\n<p>token是个凭条，不过它比门票温柔多了，门票丢了重新花钱买，token丢了重新操作下认证一个就可以了，因此token丢失的代价是可以忍受的——前提是你别丢太频繁，要是让用户隔三差五就认证一次那就损失用户体验了。</p>\n<p>基于这个出发点，如果你认为用数据库来保持token查询时间太长，会成为你系统的瓶颈或者隐患，可以放在内存当中。 <br>\n比如memcached、redis，KV方式很适合你对token查询的需求。 <br>\n这个不会太占内存，比如你的token是32位字符串，要是你的用户量在百万级或者千万级，那才多少内存。 <br>\n要是数据量真的大到单机内存扛不住，或者觉得一宕机全丢风险大，只要这个token生成是足够均匀的，高低位切一下分到不同机器上就行，内存绝对不会是问题。</p>\n<p>客户端方面这个除非你有一个非常安全的办法，比如操作系统提供的隐私数据存储，那token肯定会存在泄露的问题。比如我拿到你的手机，把你的token拷出来，在过期之前就都可以以你的身份在别的地方登录。 <br>\n解决这个问题的一个简单办法 <br>\n1、在存储的时候把token进行对称加密存储，用时解开。 <br>\n2、将请求URL、时间戳、token三者进行合并加盐签名，服务端校验有效性。 <br>\n这两种办法的出发点都是：窃取你存储的数据较为容易，而反汇编你的程序hack你的加密解密和签名算法是比较难的。然而其实说难也不难，所以终究是防君子不防小人的做法。话说加密存储一个你要是被人扒开客户端看也不会被喷明文存储…… <br>\n方法1它拿到存储的密文解不开、方法2它不知道你的签名算法和盐，两者可以结合食用。 <br>\n但是如果token被人拷走，他自然也能植入到自己的手机里面，那到时候他的手机也可以以你的身份来用着，这你就瞎了。 <br>\n于是可以提供一个让用户可以主动expire一个过去的token类似的机制，在被盗的时候能远程止损。</p>\n<p>在网络层面上token明文传输的话会非常的危险，所以建议一定要使用HTTPS，并且把token放在post body里。</p>\n<p>&nbsp;</p>\n<p>补充：</p>\n<p><span style=\"color: rgba(255, 0, 0, 1)\">cookie与session的区别</span></p>\n<p>1、cookie数据存放在客户端上，session数据放在服务器上。</p>\n<p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>&nbsp;&nbsp; 考虑到安全应当使用session。</p>\n<p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>&nbsp;&nbsp; 考虑到减轻服务器性能方面，应当使用COOKIE。</p>\n<p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>\n<p>5、所以个人建议：<br>&nbsp;&nbsp; 将登陆信息等重要信息存放为SESSION<br>&nbsp;&nbsp; 其他信息如果需要保留，可以放在COOKIE中</p>\n<p>&nbsp;</p>\n<p><span style=\"color: rgba(255, 0, 0, 1)\">session与token的区别</span></p>\n<p>　　session 和 oauth token并不矛盾，作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态</p>\n<p>　　App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。&nbsp;如果你的后端不是stateless的rest api, 那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session.</p>\n<p>　　Session 是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。&nbsp;而Token ，如果指的是OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App 。其目的是让 某App有权利访问 某用户 的信息。这里的 Token是唯一的。不可以转移到其它 App上，也不可以转到其它 用户 上。&nbsp;转过来说Session 。Session只提供一种简单的认证，即有此 SID，即认为有此 User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。&nbsp;所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</p>\n<p>&nbsp;</p>\n<p>打破误解：</p>\n<p>“<span style=\"color: rgba(255, 0, 0, 1)\">只要关闭浏览器 ，session就消失了？<span style=\"color: rgba(0, 0, 0, 1)\">”</span></span></p>\n<p>不对。对session来说，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。</p>\n<p>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存在硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够打开原来的session.</p>\n<p>恰恰是<span style=\"color: rgba(255, 0, 0, 1)\">由于关闭浏览器不会导致session被删除，迫使服务器为session设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以以为客户端已经停止了活动，才会把session删除以节省存储空间。</span></p>\n<p><span style=\"color: rgba(0, 0, 0, 1)\">本文转至<a href=\"http://blog.csdn.net/tobetheender/article/details/52485948\" target=\"_blank\">&nbsp;http://blog.csdn.net/tobetheender/article/details/52485948</a></span></p>\n</div>"
  },
  {
    "category": "network",
    "qes": "HTTP1.0->1.1",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <p>原文：https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A&nbsp;</p>\n<p><strong>一、HTTP的历史</strong></p>\n<p>早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。</p>\n<p>&nbsp;</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribgQuEeJaevuN9LRgQ9WR85hRiaVISeia7SDz1aU9hAAgO33XFaJ3FhmhQ/0?wx_fmt=png\" alt=\"\" data-fail=\"0\" data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribgQuEeJaevuN9LRgQ9WR85hRiaVISeia7SDz1aU9hAAgO33XFaJ3FhmhQ/0?wx_fmt=png\" data-ratio=\"0.2923728813559322\" data-w=\"708\"></p>\n<p>&nbsp;</p>\n<p><strong>二、HTTP的基本优化</strong></p>\n<p>影响一个 HTTP 网络请求的因素主要有两个：<strong>带宽和延迟。</strong></p>\n<ul class=\"list-paddingleft-2\">\n<li>\n<p><strong>带宽：</strong>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p>\n</li>\n<li>\n<p><strong>延迟：</strong></p>\n</li>\n<ul class=\"list-paddingleft-2\">\n<li>\n<p>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p>\n</li>\n<li>\n<p>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p>\n</li>\n<li>\n<p>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p>\n<p>&nbsp;</p>\n</li>\n</ul>\n</ul>\n<p><strong>三、HTTP1.0和HTTP1.1的一些区别</strong></p>\n<p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p>\n<ol class=\"list-paddingleft-2\">\n<li>\n<p><strong> 缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>\n</li>\n<li>\n<p><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>\n</li>\n<li>\n<p><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>\n</li>\n<li>\n<p><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>\n</li>\n<li>\n<p><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>\n<p>&nbsp;</p>\n</li>\n</ol>\n<p><strong>四、HTTPS与HTTP的一些区别</strong></p>\n<ul class=\"list-paddingleft-2\">\n<li>\n<p>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>\n</li>\n<li>\n<p>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</p>\n</li>\n<li>\n<p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>\n</li>\n<li>\n<p>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p>\n</li>\n</ul>\n<p>&nbsp;</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribXL5PwzkqQdmyY9egu2hpzzMCgz2F5HhhkdSNc5eYJ9UGMDBGjeCGiag/0?wx_fmt=png\" alt=\"\" data-fail=\"0\" data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribXL5PwzkqQdmyY9egu2hpzzMCgz2F5HhhkdSNc5eYJ9UGMDBGjeCGiag/0?wx_fmt=png\" data-ratio=\"0.3856749311294766\" data-w=\"726\"></p>\n<p>&nbsp;</p>\n<p><strong>五、SPDY：HTTP1.x的优化</strong></p>\n<p>2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p>\n<ol class=\"list-paddingleft-2\">\n<li>\n<p><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</p>\n</li>\n<li>\n<p><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p>\n</li>\n<li>\n<p><strong>header压缩。</strong>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p>\n</li>\n<li>\n<p><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</p>\n</li>\n<li>\n<p><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</p>\n</li>\n</ol>\n<p>&nbsp;</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribjhshzcKo97UNNVIFgpOYZic95drsxo5TaiadPSSmcYhOI7GYAO99W6Sw/0?wx_fmt=png\" alt=\"\" data-fail=\"0\" data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribjhshzcKo97UNNVIFgpOYZic95drsxo5TaiadPSSmcYhOI7GYAO99W6Sw/0?wx_fmt=png\" data-ratio=\"0.9970238095238095\" data-w=\"336\"></p>\n<p>&nbsp;</p>\n<p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p>\n<p>&nbsp;</p>\n<p><strong>六、HTTP2.0性能惊人</strong></p>\n<p><strong>HTTP/2: the Future of the Internet</strong> https://link.zhihu.com/?target=https://http2.akamai.com/demo 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。</p>\n<p>&nbsp;</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribcBaVkwLTtI3YprKtxYXhyYq7N1N70iaiaUxHFzc05wxQlSFrz3ltzrgw/0?wx_fmt=png\" alt=\"\" data-fail=\"0\" data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribcBaVkwLTtI3YprKtxYXhyYq7N1N70iaiaUxHFzc05wxQlSFrz3ltzrgw/0?wx_fmt=png\" data-ratio=\"0.640268456375839\" data-w=\"745\"></p>\n<p>&nbsp;</p>\n<p><strong>七、HTTP2.0：SPDY的升级版</strong></p>\n<p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：</p>\n<p><br><strong>HTTP2.0和SPDY的区别：</strong></p>\n<ol class=\"list-paddingleft-2\">\n<li>\n<p>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</p>\n\n</li>\n<li>\n<p>HTTP2.0 消息头的压缩算法采用 <strong>HPACK</strong> http://http2.github.io/http2-spec/compression.html，而非 SPDY 采用的 <strong>DEFLATE</strong>&nbsp;http://zh.wikipedia.org/wiki/DEFLATE</p>\n\n</li>\n\n</ol>\n<p>&nbsp;</p>\n<p><strong>八、HTTP2.0和HTTP1.X相比的新特性</strong></p>\n<ul class=\"list-paddingleft-2\">\n<li>\n<p><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>\n\n</li>\n<li>\n<p><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p>\n\n</li>\n<li>\n<p><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>\n\n</li>\n<li>\n<p><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</p>\n<p>&nbsp;</p>\n\n</li>\n\n</ul>\n<p><strong>九、HTTP2.0的升级改造</strong></p>\n<ul class=\"list-paddingleft-2\">\n<li>\n<p>前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。</p>\n\n</li>\n<li>\n<p>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考<strong>NGINX白皮书，NGINX配置HTTP2.0官方指南&nbsp;</strong>https://www.nginx.com/blog/nginx-1-9-5/。</p>\n\n</li>\n<li>\n<p>使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</p>\n\n</li>\n\n</ul>\n<p>&nbsp;</p>\n<p><strong>十、附注</strong></p>\n<p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p>\n<ul class=\"list-paddingleft-2\">\n<li>\n<p>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</p>\n\n</li>\n<li>\n<p>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</p>\n\n</li>\n<li>\n<p>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；<br>具体如图：</p>\n<p>&nbsp;</p>\n\n</li>\n\n</ul>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQriba5ygCTOOjIQH4wvoJS2iaFBseyEAUfvpJQThHmTjuGuaSspUo8xppiaA/0?wx_fmt=png\" alt=\"\" data-fail=\"0\" data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQriba5ygCTOOjIQH4wvoJS2iaFBseyEAUfvpJQThHmTjuGuaSspUo8xppiaA/0?wx_fmt=png\" data-ratio=\"0.9867549668874173\" data-w=\"755\"></p>\n<p>&nbsp;</p>\n<p>服务器推送到底是什么？<br>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：</p>\n<ul class=\"list-paddingleft-2\">\n<li>\n<p>普通的客户端请求过程：</p>\n\n</li>\n\n</ul>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribkZLpDyHlTbAGkEiazqLfjkTSfMgib2UlC0p3Yw0T3iaaHcvLjL22PZWPg/0?wx_fmt=png\" alt=\"\" data-fail=\"0\" data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribkZLpDyHlTbAGkEiazqLfjkTSfMgib2UlC0p3Yw0T3iaaHcvLjL22PZWPg/0?wx_fmt=png\" data-ratio=\"0.8677685950413223\" data-w=\"726\"></p>\n<p>&nbsp;</p>\n<ul class=\"list-paddingleft-2\">\n<li>\n<p>服务端推送的过程：</p>\n\n</li>\n\n</ul>\n<p>&nbsp;</p>\n<p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribq79os9yK2JmEODZqRVBweS7uMP2WWz4Ij6Z1f9TuiaXANOozhwCWljw/0?wx_fmt=png\" alt=\"\" data-fail=\"0\" data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribq79os9yK2JmEODZqRVBweS7uMP2WWz4Ij6Z1f9TuiaXANOozhwCWljw/0?wx_fmt=png\" data-ratio=\"0.594059405940594\" data-w=\"707\"></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><strong>为什么需要头部压缩？</strong><br>假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍</p>\n<p>&nbsp;</p>\n<p><strong>HTTP2.0多路复用有多好？</strong><br>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。<br>HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>\n<p>&nbsp;</p>\n<p><strong>十一、参考</strong></p>\n<p>HTTP/2.0 相比1.0有哪些重大改进？<br>深入研究：HTTP2 的真正性能到底如何<br>HTTP/2 头部压缩技术介绍</p>\n</div>"
  },
  {
    "category": "network",
    "qes": "URI和URL的区别",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <p>这两天在写代码的时候，由于涉及到资源的位置，因此，需要在Java Bean中定义一些字段，用来表示资源的位置，比如：imgUrl，logoUri等等。但是，每次定义的时候，心里都很纠结，是该用imgUrl还是imgUri呢？</p>\n<p>同样的，另外一个问题：String HttpServletRequest.getRequestURI()；和StringBuffer HttpServletRequest.getRequestURL();返回的内容有何不同？为什么会如此？</p>\n<p>带着这些问题到网上去搜了下，没发现让自己看了明白的解释，于是，想到了Java类库里有两个对应的类java.net.URI和java.net.URL，终于，在这两个类里的javadoc里找到了答案。</p>\n<h4>URIs, URLs, and URNs</h4>\n<p>首先，URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。而URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。而URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。</p>\n<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，schema必须被指定。</p>\n<p>ok，现在回答文章开头提出的问题，到底是imgUrl好呢，还是imgUri好？显然，如果说imgUri是肯定没问题的，因为即使它实际上是url，那它也是uri的一种。那么用imgUrl有没有问题呢？此时则要看它的可能取值，如果是绝对路径，能够定位的，那么用imgUrl是没问题的，而如果是相对路径，那还是不要用ImgUrl的好。总之，用imgUri是肯定没问题的，而用imgUrl则要视实际情况而定。</p>\n<p>第二个，从HttpServletRequest的javadoc中可以看出，getRequestURI返回一个String，“the part of this request’s URL from the protocol name up to the query string in the first line of the HTTP request”，比如“POST /some/path.html?a=b HTTP/1.1”，则返回的值为”/some/path.html”。现在可以明白为什么是getRequestURI而不是getRequestURL了，因为此处返回的是相对的路径。而getRequestURL返回一个StringBuffer，“The returned URL contains a protocol, server name, port number, and server path, but it does not include query string parameters.”，完整的请求资源路径，不包括querystring。</p>\n<p>总结一下：URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，所以，是绝对的，而通常说的relative URL，则是针对另一个absolute URL，本质上还是绝对的。</p>\n<p>注：这里的绝对(absolute)是指包含scheme，而相对(relative)则不包含scheme。</p>\n<p>URI抽象结构 &nbsp; &nbsp;<span style=\"color: rgba(255, 102, 0, 1)\"> [<em>scheme</em><tt><strong>:</strong></tt>]<em>scheme-specific-part</em>[<tt><strong>#</strong></tt><em>fragment</em>]</span></p>\n<p>[<em>scheme</em><tt><strong>:</strong></tt>][<tt><strong>//</strong></tt><em>authority</em>][<em>path</em>][<tt><strong>?</strong></tt><em>query</em>][<tt><strong>#</strong></tt><em>fragment</em>]</p>\n<p>authority为[<em>user-info</em><tt><strong>@</strong></tt>]<em>host</em>[<tt><strong>:</strong></tt><em>port</em>]</p>\n<p>参考资料：</p>\n<p><a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/net/URI.html\">http://docs.oracle.com/javase/1.5.0/docs/api/java/net/URI.html</a></p>\n<p><a href=\"http://en.wikipedia.org/wiki/Uniform_Resource_Identifier\">http://en.wikipedia.org/wiki/Uniform_Resource_Identifier</a></p>\n<p><a href=\"http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletRequest.html\">http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletRequest.html</a></p>\n<p>ps:</p>\n<p>java.net.URL类不提供对标准RFC2396规定的特殊字符的转义，因此需要调用者自己对URL各组成部分进行encode。而java.net.URI则会提供转义功能。因此The recommended way &nbsp;to manage the encoding and decoding of URLs is to use &nbsp;java.net.URI. 可以使用URI.toURL()和URL.toURI()方法来对两个类型的对象互相转换。对于HTML FORM的url encode/decode可以使用java.net.URLEncoder和java.net.URLDecoder来完成，但是对URL对象不适用。</p>\n</div>"
  },
  {
    "category": "network",
    "qes": "HTTP和HTTPS",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <h2><a name=\"t0\"></a><a name=\"t0\"></a><strong><span style=\"color:#000000;\">前言</span></strong></h2> \n<p><span style=\"color:#000000;\">无论是在校学习还是找工作的时候，老师和面试官都问过同学 HTTP&nbsp;和 HTTPS&nbsp;的区别。平时上网的时候也没有关注这个问题，只是知道计算机网络里 HTTP&nbsp;的概念，所以最近才查资料好好补补这一块。其实这一块的知识延伸很广，如果之前不太了解加密算法和 SSL 协议，可以在学习了这个问题的基础上再做研究。</span></p> \n<p><span style=\"color:#0c0c0c;\">TLS/SSL 工作原理及握手过程详解：<a href=\"https://tyler-zx.blog.csdn.net/article/details/107591115\">https://tyler-zx.blog.csdn.net/article/details/107591115</a></span></p> \n<p>&nbsp;</p> \n<h3><a name=\"t1\"></a><a name=\"t1\"></a><strong><span style=\"color:#000000;\">一、HTTP</span><span style=\"color:#000000;\">&nbsp;和 HTTPS&nbsp;的基本概念</span></strong></h3> \n<p><strong><span style=\"color:#000000;\">HTTP</span></strong><span style=\"color:#000000;\">：</span><a href=\"https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8535513\"><span style=\"color:#000000;\">超文本传输协议</span></a><span style=\"color:#000000;\">（HTTP，HyperText Transfer Protocol)是</span><a href=\"https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91\"><span style=\"color:#000000;\">互联网</span></a><span style=\"color:#000000;\">上应用最为广泛的一种</span><a href=\"https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/328636\"><span style=\"color:#000000;\">网络协议</span></a><span style=\"color:#000000;\">。设计 HTTP&nbsp;最初的目的是为了提供一种发布和接收 HTML&nbsp;</span><span style=\"color:#000000;\">页面的方法。</span><span style=\"color:#000000;\">它可以使浏览器更加高效。HTTP&nbsp;协议</span><span style=\"color:#000000;\">是</span><span style=\"color:#000000;\">以明文方式发送</span><span style=\"color:#000000;\">信息的</span><span style=\"color:#000000;\">，如果</span><span style=\"color:#000000;\">黑客</span><span style=\"color:#000000;\">截取了 Web 浏览器和服务器之间的传输报文，就可以直接</span><span style=\"color:#000000;\">获得</span><span style=\"color:#000000;\">其中的信息</span><span style=\"color:#000000;\">。</span></p> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#000000;\">HTTP</span><span style=\"color:#0c0c0c;\">&nbsp;</span><span style=\"color:#0c0c0c;\">原理：</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">①&nbsp; 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">②&nbsp; 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<p><span style=\"color:#000000;\">HTTPS</span><span style=\"color:#000000;\">：</span><span style=\"color:#c00000;\">是以安全为目标的 HTTP&nbsp;通道，是 HTTP&nbsp;的安全版。HTTPS&nbsp;的安全基础是 SSL。SSL 协议位于&nbsp;</span><a href=\"https://baike.baidu.com/item/TCP/IP%E5%8D%8F%E8%AE%AE\"><u><span style=\"color:#c00000;\"><u>TCP/IP 协议</u></span></u></a><span style=\"color:#c00000;\">与各种应用层协议之间，为</span><a href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF\"><u><span style=\"color:#c00000;\"><u>数据通讯</u></span></u></a><span style=\"color:#c00000;\">提供安全支持。</span><span style=\"color:#000000;\">SSL 协议可分为两层：</span><span style=\"color:#c00000;\">SSL 记录协议（SSL Record Protocol）</span>，<span style=\"color:#0c0c0c;\">它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</span><span style=\"color:#c00000;\">SSL 握手协议（SSL Handshake Protocol）</span><span style=\"color:#0c0c0c;\">，它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</span></p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img alt=\"\" height=\"192\" src=\"https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70\" width=\"474\"> &nbsp; &nbsp;</p> \n<p>&nbsp;</p> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#000000;\">HTTPS</span><strong><span style=\"color:#0c0c0c;\">&nbsp;</span></strong><span style=\"color:#0c0c0c;\">设计目标</span><span style=\"color:#0c0c0c;\">：</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(1)&nbsp;</span><span style=\"color:#0c0c0c;\">数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么&nbsp;&nbsp;。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(2)&nbsp;</span><span style=\"color:#0c0c0c;\">数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收&nbsp;。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(3)&nbsp;</span><span style=\"color:#0c0c0c;\">身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方&nbsp;&nbsp;。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<h3><a name=\"t2\"></a><a name=\"t2\"></a><strong><span style=\"color:#000000;\">二、HTTP&nbsp;与 HTTPS</span><span style=\"color:#0c0c0c;\">&nbsp;</span><span style=\"color:#000000;\">&nbsp;的区别</span></strong></h3> \n<p><span style=\"color:#000000;\">1、HTTPS</span><strong><span style=\"color:#0c0c0c;\">&nbsp;</span></strong><span style=\"color:#000000;\"> 协议需要到 CA&nbsp;</span><span style=\"color:#0c0c0c;\">（Certificate Authority，证书颁发机构）</span><span style=\"color:#000000;\">申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https</span><strong><span style=\"color:#0c0c0c;\">&nbsp;</span></strong><span style=\"color:#000000;\">。)</span></p> \n<p><span style=\"color:#000000;\">2、</span><span style=\"color:#c00000;\">HTTP&nbsp;是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL&nbsp;加密传输协议。</span></p> \n<p><span style=\"color:#000000;\">3、</span><span style=\"color:#c00000;\">HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</span></p> \n<p><span style=\"color:#000000;\">4、</span><span style=\"color:#c00000;\">HTTP 的连接很简单，是无状态的。</span><span style=\"color:#000000;\">HTTPS&nbsp;协议是由 SSL+HTTP&nbsp;协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</span><span style=\"color:#c00000;\">(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</span></p> \n<p>&nbsp;</p> \n<h3 style=\"margin-left:0pt;\"><a name=\"t3\"></a><a name=\"t3\"></a><strong><span style=\"color:#0c0c0c;\">三、</span><span style=\"color:#000000;\">HTTPS</span><span style=\"color:#0c0c0c;\">&nbsp;相对于 </span><span style=\"color:#000000;\">HTTP</span><span style=\"color:#0c0c0c;\">&nbsp;的改进</span></strong></h3> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">双向的身份认证</span></strong></p> \n<p style=\"margin-left:0pt;\"><a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081\"><span style=\"color:#0c0c0c;\">客户端</span></a><span style=\"color:#0c0c0c;\">和</span><a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AF/6492316\"><span style=\"color:#0c0c0c;\">服务端</span></a><span style=\"color:#0c0c0c;\">在传输数据之前，会通过基于</span><a href=\"https://baike.baidu.com/item/X.509/2817050\"><span style=\"color:#0c0c0c;\">X.509</span></a><span style=\"color:#0c0c0c;\">证书对双方进行身份认证 。具体过程如下<a name=\"ref_3\"></a></span><span style=\"color:#0c0c0c;\"><a name=\"ref_[3]_14121\">：</a></span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">客户端发起 SSL 握手消息给服务端要求连接。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">服务端将证书发送给客户端。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的</span><a href=\"https://baike.baidu.com/item/%E5%85%AC%E9%92%A5/6447788\"><span style=\"color:#0c0c0c;\">公钥</span></a><span style=\"color:#0c0c0c;\">，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。</span></p> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">注意：</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(1) 采用&nbsp;</span><span style=\"color:#000000;\">HTTPS&nbsp;</span><span style=\"color:#0c0c0c;\">协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(3) 客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<p style=\"margin-left:0pt;\"><a name=\"3_2\"></a><span style=\"color:#0c0c0c;\"><a name=\"3-2\"></a><a name=\"sub14121_3_2\"></a><a name=\"数据传输的机密性\"></a></span></p> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">数据传输的机密性</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是</span><a href=\"https://baike.baidu.com/item/RSA/210678\"><span style=\"color:#0c0c0c;\">RSA</span></a><span style=\"color:#0c0c0c;\">)，数据签名摘要算法 ( 一般是</span><a href=\"https://baike.baidu.com/item/SHA/9533316\"><span style=\"color:#0c0c0c;\">SHA</span></a><span style=\"color:#0c0c0c;\">或者</span><a href=\"https://baike.baidu.com/item/MD5/212708\"><span style=\"color:#0c0c0c;\">MD5</span></a><span style=\"color:#0c0c0c;\">) ，加密传输数据的对称加密算法 ( 一般是</span><a href=\"https://baike.baidu.com/item/DES/210508\"><span style=\"color:#0c0c0c;\">DES</span></a><span style=\"color:#0c0c0c;\">)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<p style=\"margin-left:0pt;\"><a name=\"防止重放攻击\"></a><span style=\"color:#0c0c0c;\"><a name=\"3-3\"></a><a name=\"sub14121_3_3\"></a><a name=\"3_3\"></a></span></p> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">防止重放攻击</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">可以看到，鉴于</span><a href=\"https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/98106\"><span style=\"color:#0c0c0c;\">电子商务</span></a><span style=\"color:#0c0c0c;\">等安全上的需求，</span><span style=\"color:#000000;\">HTTPS&nbsp;</span><span style=\"color:#0c0c0c;\">对比&nbsp;</span><span style=\"color:#000000;\">HTTP&nbsp;</span><span style=\"color:#0c0c0c;\">协议，在安全方面已经取得了极大的增强。总结来说，</span><span style=\"color:#000000;\">HTTPS&nbsp;</span><span style=\"color:#0c0c0c;\">的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了</span><a href=\"https://baike.baidu.com/item/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/9874417\"><span style=\"color:#0c0c0c;\">非对称加密</span></a><span style=\"color:#0c0c0c;\">的安全性和</span><a href=\"https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/2152944\"><span style=\"color:#0c0c0c;\">对称加密</span></a><span style=\"color:#0c0c0c;\">的快速性。</span></p> \n<p>&nbsp;</p> \n<h3><a name=\"t4\"></a><a name=\"t4\"></a><strong><span style=\"color:#000000;\">四、HTTPS&nbsp;的优点</span></strong></h3> \n<p><span style=\"color:#000000;\">1、使用 HTTPS&nbsp;协议可认证用户和服务器，确保数据发送到正确的客户机和服务器</span><span style=\"color:#000000;\">。</span></p> \n<p><span style=\"color:#000000;\">2、HTTPS&nbsp;协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改</span><span style=\"color:#000000;\">，确保数据的完整性。</span></p> \n<p><span style=\"color:#000000;\">3、HTTPS&nbsp;是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</span></p> \n<p>&nbsp;</p> \n<h3><a name=\"t5\"></a><a name=\"t5\"></a><strong><span style=\"color:#000000;\">五、HTTPS&nbsp;的缺点（对比优点）</span></strong></h3> \n<p><span style=\"color:#000000;\">1、HTTPS&nbsp;协议握手阶段比较费时，会使页面的加载时间延长近</span><span style=\"color:#000000;\">。</span></p> \n<p><span style=\"color:#000000;\">2、HTTPS&nbsp;连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</span></p> \n<p><span style=\"color:#000000;\">3、</span><span style=\"color:#000000;\">HTTPS&nbsp;</span><span style=\"color:#0c0c0c;\">协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</span></p> \n<p><span style=\"color:#000000;\">4、</span><span style=\"color:#000000;\">SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</span></p> \n<p><span style=\"color:#000000;\">5、</span><span style=\"color:#0c0c0c;\">成本增加。部署 </span><span style=\"color:#000000;\">HTTPS&nbsp;</span><span style=\"color:#0c0c0c;\">后，因为 </span><span style=\"color:#000000;\">HTTPS&nbsp;</span><span style=\"color:#0c0c0c;\">协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。</span></p> \n<p><span style=\"color:#000000;\">6、HTTPS&nbsp;协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</span></p> \n<p>&nbsp;</p> \n<h3><a name=\"t6\"></a><a name=\"t6\"></a><strong><span style=\"color:#000000;\">六、HTTPS&nbsp;的连接过程</span></strong></h3> \n<p><span style=\"color:#000000;\">https://blog.csdn.net/kobejayandy/article/details/52433660（图片是我借用这位大佬的，大家可以看看）&nbsp;</span></p> \n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"540\" src=\"https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"610\"></p> \n<p><span style=\"color:#000000;\">图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。</span></p> \n<p><span style=\"color:#000000;\">① 客户端的</span><a href=\"https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8\"><span style=\"color:#000000;\">浏览器</span></a><span style=\"color:#000000;\">向服务器发送请求，并传送客户端 SSL 协议的</span><a href=\"https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E5%8F%B7\"><span style=\"color:#000000;\">版本号</span></a><span style=\"color:#000000;\">，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</span></p> \n<p><span style=\"color:#000000;\">② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</span></p> \n<p><span style=\"color:#000000;\">③ 客户</span><span style=\"color:#000000;\">端</span><span style=\"color:#000000;\">利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行</span><a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6\"><span style=\"color:#000000;\">服务器证书</span></a><span style=\"color:#000000;\">的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 \"发行者的数字签名\"，服务器证书上的</span><a href=\"https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D\"><span style=\"color:#000000;\">域名</span></a><span style=\"color:#000000;\">是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</span></p> \n<p><span style=\"color:#000000;\">④ 用户端随机产生一个用于通讯的 \"对称密码\"，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</span></p> \n<p><span style=\"color:#000000;\">⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。</span></p> \n<p><span style=\"color:#000000;\">⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA&nbsp; 是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主</span><a href=\"https://baike.baidu.com/item/%E9%80%9A%E8%AE%AF%E5%AF%86%E7%A0%81\"><span style=\"color:#000000;\">通讯密码</span></a><span style=\"color:#000000;\">（客户端也将通过同样的方法产生相同的主通讯密码）。</span></p> \n<p><span style=\"color:#000000;\">⑦ 服务器和客户端用相同的对称加密密钥，</span><a href=\"https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5\"><span style=\"color:#000000;\">对称密钥</span></a><span style=\"color:#000000;\">用于 SSL 协议的安全</span><a href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF\"><span style=\"color:#000000;\">数据通讯</span></a><span style=\"color:#000000;\">的加解密</span><a href=\"https://baike.baidu.com/item/%E9%80%9A%E8%AE%AF\"><span style=\"color:#000000;\">通讯</span></a><span style=\"color:#000000;\">。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</span></p> \n<p><span style=\"color:#000000;\">⑧&nbsp;</span><a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span style=\"color:#000000;\">客户端</span></a><span style=\"color:#000000;\">向</span><a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span style=\"color:#000000;\">服务器</span></a><span style=\"color:#000000;\">端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为</span><a href=\"https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5\"><span style=\"color:#000000;\">对称密钥</span></a><span style=\"color:#000000;\">，同时通知服务器客户端的握手过程结束。</span></p> \n<p><span style=\"color:#000000;\">⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</span></p> \n<p><span style=\"color:#000000;\">⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</span></p> \n<p>&nbsp;</p> \n<h3 style=\"margin-left:0pt;\"><a name=\"t7\"></a><a name=\"t7\"></a><strong><span style=\"color:#0c0c0c;\">上述的过程需要弄懂的核心思想</span></strong></h3> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">客户端解析证书</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</span><span style=\"color:#0c0c0c;\">如果证书没有问题，</span><span style=\"color:#c00000;\">那么就生成一个</span><span style=\"color:#c00000;\">对称加密密钥，</span><span style=\"color:#c00000;\">然后用</span><span style=\"color:#c00000;\">公钥</span><span style=\"color:#c00000;\">对该</span><span style=\"color:#c00000;\">密钥</span><span style=\"color:#c00000;\">进行</span><span style=\"color:#c00000;\">非对称</span><span style=\"color:#c00000;\">加密。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">传送加密信息</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">这部分传送的是用</span><span style=\"color:#0c0c0c;\">公钥</span><span style=\"color:#0c0c0c;\">加密后的</span><span style=\"color:#0c0c0c;\">对称加密密钥</span><span style=\"color:#0c0c0c;\">，目的就是让服务端得到这个</span><span style=\"color:#0c0c0c;\">密钥</span><span style=\"color:#0c0c0c;\">，以后客户端和服务端的通信就可以通过这个</span><span style=\"color:#0c0c0c;\">密钥</span><span style=\"color:#0c0c0c;\">来进行加密解密了。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">服务端解密信息</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#c00000;\">服务端用</span><span style=\"color:#c00000;\">非对称加密算法里的</span><span style=\"color:#c00000;\">私钥解密后，得到了客户端传过来的</span><span style=\"color:#c00000;\">对称加密算法的</span><span style=\"color:#c00000;\">私钥，然后把</span><span style=\"color:#c00000;\">之后传输的</span><span style=\"color:#c00000;\">内容通过该值进行对称加密。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">为什么用非对称加密协商对称加密密钥</span></strong></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以</span><span style=\"color:#c00000;\">想要保证其安全性就要保证密钥的安全</span><span style=\"color:#0c0c0c;\">。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">非对称加密的特点：</span><span style=\"color:#c00000;\">算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。</span><span style=\"color:#0c0c0c;\">非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">非对称加密公钥和私钥的使用方法：</span><span style=\"color:#c00000;\">(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。</span></p> \n<p>&nbsp;</p> \n<h3 style=\"margin-left:0pt;\"><a name=\"t8\"></a><a name=\"t8\"></a><strong><span style=\"color:#0c0c0c;\">补充：</span></strong></h3> \n<h3 style=\"margin-left:0pt;\"><a name=\"t9\"></a><a name=\"t9\"></a><strong><span style=\"color:#0c0c0c;\">SSL 提供服务</span></strong></h3> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(1)&nbsp;</span><span style=\"color:#0c0c0c;\">认证用户和服务器，确保数据发送到正确的</span><a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E6%9C%BA\"><span style=\"color:#0c0c0c;\">客户机</span></a><span style=\"color:#0c0c0c;\">和</span><a href=\"https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span style=\"color:#0c0c0c;\">服务器</span></a><span style=\"color:#0c0c0c;\">；</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(2)&nbsp;</span><span style=\"color:#0c0c0c;\">加密数据以防止数据中途被窃取；</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">(3)&nbsp;</span><span style=\"color:#0c0c0c;\">维护数据的完整性，确保数据在传输过程中不被改变。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<h3 style=\"margin-left:0pt;\"><a name=\"t10\"></a><a name=\"t10\"></a><strong><span style=\"color:#0c0c0c;\">SSL 工作流程</span></strong></h3> \n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#0c0c0c;\">服务器认证阶段：</span></strong></p> \n<p><span style=\"color:#0c0c0c;\">(1) 客户端</span><span style=\"color:#0c0c0c;\">向服务器发送一个开始信息 \"Hello\" 以便开始一个新的会话连接；</span></p> \n<p><span style=\"color:#0c0c0c;\">(2) 服务器根据客户的信息确定是否需要生成新的主</span><a href=\"https://baike.baidu.com/item/%E5%AF%86%E9%92%A5\"><span style=\"color:#0c0c0c;\">密钥</span></a><span style=\"color:#0c0c0c;\">，如需要则服务器在响应客户的 \"Hello\" 信息时将包含生成主密钥所需的信息；</span></p> \n<p><span style=\"color:#0c0c0c;\">(3) 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的</span><a href=\"https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86\"><span style=\"color:#0c0c0c;\">公开密钥加密</span></a><span style=\"color:#0c0c0c;\">后传给服务器；</span></p> \n<p><span style=\"color:#0c0c0c;\">(4) 服务器回复该主密钥，并返回给客户一个用主</span><a href=\"https://baike.baidu.com/item/%E5%AF%86%E9%92%A5%E8%AE%A4%E8%AF%81\"><span style=\"color:#0c0c0c;\">密钥认证</span></a><span style=\"color:#0c0c0c;\">的信息，以此让</span><a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E8%AE%A4%E8%AF%81\"><span style=\"color:#0c0c0c;\">客户认证</span></a><span style=\"color:#0c0c0c;\">服务器。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<p style=\"margin-left:0pt;\"><strong><a href=\"https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81\"><span style=\"color:#0c0c0c;\">用户认证</span></a></strong><span style=\"color:#0c0c0c;\"><strong>阶段：</strong>在此之前，服务器已经通过了</span><a href=\"https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E8%AE%A4%E8%AF%81\"><span style=\"color:#0c0c0c;\">客户认证</span></a><span style=\"color:#0c0c0c;\">，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其</span><a href=\"https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5\"><span style=\"color:#0c0c0c;\">公开密钥</span></a><span style=\"color:#0c0c0c;\">，从而向服务器提供认证。</span></p> \n<p style=\"margin-left:0pt;\">&nbsp;</p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\">SSL 协议提供的安全通道有以下三个特性：</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\"><strong>机密性：</strong>SSL 协议使用密钥加密通信数据。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\"><strong>可靠性：</strong>服务器和客户都会被认证，客户的认证是可选的。</span></p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\"><strong>完整性：</strong>SSL 协议会对传送的数据进行完整性检查。</span></p> \n<p>&nbsp;</p> \n<p style=\"margin-left:0pt;\"><span style=\"color:#0c0c0c;\"><strong>服务器证书</strong>(server certificates)</span><span style=\"color:#0c0c0c;\">是 SSL&nbsp;</span><a href=\"https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/326874\"><span style=\"color:#0c0c0c;\">数字证书</span></a><span style=\"color:#0c0c0c;\">的一种形式，意指</span><span style=\"color:#c00000;\">通过提交数字证书来证明您的身份或表明您有权访问在线服务。</span><span style=\"color:#0c0c0c;\">再者简单来说，通过使用服务器证书可为不同</span><a href=\"https://baike.baidu.com/item/%E7%AB%99%E7%82%B9/7108922\"><span style=\"color:#0c0c0c;\">站点</span></a><span style=\"color:#0c0c0c;\">提供身份鉴定并保证该站点拥有高强度加密安全。是</span><span style=\"color:#0c0c0c;\">组成&nbsp;</span><a href=\"https://baike.baidu.com/item/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/8390210\"><span style=\"color:#0c0c0c;\">Web 服务器</span></a><span style=\"color:#0c0c0c;\">的 SSL&nbsp;</span><span style=\"color:#0c0c0c;\">安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为</span><a href=\"https://baike.baidu.com/item/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5/7453570\"><span style=\"color:#0c0c0c;\">公开密钥</span></a><span style=\"color:#0c0c0c;\">的唯一的</span><a href=\"https://baike.baidu.com/item/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/2193233\"><span style=\"color:#0c0c0c;\">身份验证</span></a><span style=\"color:#0c0c0c;\">文件。</span></p>\n                </div><div data-report-view=\"{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;dest&quot;:&quot;https://tyler-zx.blog.csdn.net/article/details/80969419&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}\"><div></div></div>\n        </div>"
  },
  {
    "category": "network",
    "qes": "TCP协议如何保证可靠传输",
    "ans": "<p>1、应用数据被分割成TCP认为最适合发送的数据块。 <br> 2、超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 <br> 3、TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 <br> 4、校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 <br> 5、TCP的接收端会丢弃重复的数据。 <br> 6、流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 <br> 7、拥塞控制：当网络拥塞时，减少数据的发送。</p>"
  }

]

