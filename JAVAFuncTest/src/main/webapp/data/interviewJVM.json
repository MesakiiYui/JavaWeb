[
  {
    "category": "jvm",
    "qes": "说说sleep方法和wait方法的区别和共同点?",
    "ans": "1.两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁。</br>2.两者都可以暂停线程的执行。</br>3.Wait通常被用于线程间的交互通信，sleep通常被用于暂停执行。</br>4.wait()方法被调用之后，线程不会自动苏醒，需要别的线程调用同一对象上的notify()或者notifyAll()方法，sleep()方法执行完成后，线程会自动苏醒，或者可以使用wait(long timeout)超时后线程会自动苏醒"
  },
  {
    "category": "jvm",
    "qes": "为什么我们调用start()方法时会执行run方法，为什么我们不能直接调用run方法？",
    "ans": "new一个Thread,线程进入新建状态;调用start方法，会启动一个线程并使线程进入就绪状态，当分配到时间片以后就能构运行了。</br>start()方法会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作，而直接执行run()方法，会把run方法当成一个main线程下的普通方法执行，并不会在某个线程中执行它，所以这并不是多线程工作。"
  },
  {
    "category": "jvm",
    "qes": "说一说自己对于synchronized关键字的理解？",
    "ans": "synchronized关键字解决的是多个线程之间访问资源的异步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。另外，在JDK早期的版本，synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依赖于底层的操作系统的Mutex Lock来实现的，Java的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换需要从用户态转变为内核态，这个状态之间的切换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java6之后的Java官方从JVM层面对synchronized较大的优化，所以现在的synchronized锁效率也优化得很不错了。JDK1.6对锁得实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作得开销。"
  },
  {
    "category": "jvm",
    "qes": "synchronized关键字最主要的三种使用方式？",
    "ans": "1.修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象得实例的锁；</br>2.修饰静态方法：也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不会属于任何一个实例对象，是类成员(static表明这是该类的一个静态资源，不管new多少个对象，只有一份)。所以如果一个线程A调用一个实例对象的非静态类synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象，因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁;</br>3.修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码前要获得给定对象的锁。</br>总结:synchronized关键字加到static静态方法和synchronized(class)代码块上都是给Class类上。synchronized关键字加到实例方法上是给对象实例上锁，尽量不要使用synchronized(String a),因为JVM中，字符串常量池具有缓存功能。"
  },
  {
    "category": "jvm",
    "qes": "什么是指令重排?",
    "ans": "重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。编译期重排序的典型就是通过调整指令顺序，在不改变程序语义的前提下，尽可能减少寄存器的读取、存储次数，充分复用寄存器的存储值。例如int i = 1;int j = 2;第二行代码完全可能先被处理器执行，这并不影响先行先发生原则，因为我们在这条线程中没有办法感知到这点。（都是赋值操作，无论先发生哪一个，最终结果都与顺序执行一样）。但如果有其他线程在读取这两个值，重排序就会造成读取错误！\n\n对于单一线程，如果有办法感知到这点，即int a = 1;int b = a;那么就不能重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。也就是说：在单线程环境下，指令执行的最终效果应当与其在顺序执行下的效果一致，否则这种优化便会失去意义。这句话有个专业术语叫做as-if-serial semantics (as-if-serial语义)。"
  },
  {
    "category": "jvm",
    "qes": "产生死锁的四个必要条件",
    "ans": "互斥，不剥夺，请求与保持，循环等待"
  },
  {
    "category": "jvm",
    "qes": "yield有什么作用？",
    "ans": "public static native void yield();这是一个静态方法，一旦执行，它会是当前线程让出CPU，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配给当前线程相同优先级的线程。"
  },
  {
    "category": "jvm",
    "qes": "sleep()和yield()方法，同样都是当前线程会交出处理器资源,但是他们具有什么不同之处？",
    "ans": "sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。"
  },
  {
    "category": "jvm",
    "qes": "Java内存模型(JMM)的核心概念",
    "ans": "Java的采用的是共享内存模型，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。\n从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。"
  },
  {
    "category": "jvm",
    "qes": "JVM内存模型的三大特性",
    "ans": "JAVA内存模型主要是建立在如何处理java并发过程中的原子性、可见性和有序性这三个特征的：</br>1.原子性：由Java内存模型直接保证的原子性变量操作包括read、load、use、assign、store和write六个，大致可以认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock与unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐匿地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—synchronized关键字，因此在synchronized块之间的操作也具备原子性。</br>2.可见性：可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。</br>3.有序性：Java语言提供了volatile和synchronized两个关键字来保证线程间操作的有序性。在java中，有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程内观察另一个线程，所有操作都是无序的。前半句讲的是“线程内表现为串行语义”，后半句指“指令重排序”和“工作内存和主内存同步延迟”。"
  },
  {
    "category": "jvm",
    "qes": "synchronized和ReentrantLock的区别",
    "ans": "1.两者都是可以重入锁：可重入锁的概念是，自己可以再次获取自己的内部锁，比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁，同一个线程每次获取锁，锁的计数器都会自增1，所以要等到锁的计数器下降为0时才能释放锁；</br>2.synchronized依赖于JVM并没有直接暴露给我们，而ReentrantLock依赖于API，需要lock()和unlock()方法配合try/finally语句块来完成，</br>3.ReentrantLock比synchronized增加了一些高级的功能，主要有三点：1.等待可中断（正在等待的线程可以选择放弃等待，改为处理其他事情）2.可实现公平锁(即可指定公平锁还是非公平锁，而synchronized只能是非公平锁，所谓的公平锁就是先等待的线程先获得锁)3.可实现选择性通知(锁可以绑定多个条件)"
  },
  {
    "category": "jvm",
    "qes": "透过volatile关键字了解一下Java内存模型",
    "ans": "在JDK1.2之前，Java的内存模型实现总是从主存(即共享内存)读取变量，而在当前JVM下，线程可以把变量保存在本地内存，如寄存器中，而不是直接在主存中进行读写，这就可能导致多个线程同时读取导致数据不一致，为了避免这种情况，就需要把变量声明为volatile，这就只是JVM，这个变量是不稳定的，每次使用它都到主存中进行读取，即volatile关键字的作用就是保证变量的可见性然后还有一个作用是防止指令重排序。"
  },
  {
    "category": "jvm",
    "qes": "说说synchronized关键字和volatile关键字的区别",
    "ans": "1.volatile关键字是线程同步的轻量级实现，所以volatile性能肯定要比synchronized要好，但前者只能修饰变量，后者可以修饰方法及代码块，jdk1.6之后synchronized进行了主要包括为了减少锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其他各种优化之后执行效率有了明显的提升，因此在实际的开发过程中，synchronized关键字的场景还是更多一些；</br>2.多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞;</br>3.volatile只能保证数据的原子性，不能保证数据的可见性，但是synchronized两者都能保证;</br>4.volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问的同步性"
  },
  {
    "category": "jvm",
    "qes": "为什么要使用线程池，使用线程池有什么好处？",
    "ans": "池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。线程池提供了一种限制和管理资源(包括执行一个任务)。每个线程池还维护一些基本统计信息，例如已完成人物的数量</br>1.降低资源消耗--通过重复利用已创建的线程降低线程创建和销毁造成的消耗;</br>2.提高响应速度--当任务到达时，任务可以不需要等到线程创建就能立即执行;</br>3.提高系统的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以统一的分配，调优和监控"
  },
  {
    "category": "jvm",
    "qes": "实现Runnable接口和Callable接口的区别？",
    "ans": "Runnable自Java1.0以来一直存在，而Callable仅在Java1.5中引入，目的是为了来处理Runnable不支持的用例，Runnable接口不会返回结果或抛出异常推荐使用Runnable接口，这样代码会看起来更加简洁。"
  },
  {
    "category": "jvm",
    "qes": "执行execute()方法和submit()方法的区别是什么呢？",
    "ans": "1.execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池成功执行与否。</br>submit()方法用于提交需要返回值的任务，线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值，get()方法会阻塞当前线程知道任务完成，而是用get(long timeout, TimeUnit unitr)方法则会阻塞当前线程一段时间后立即返回，这时候可能任务没有执行完。"
  },
  {
    "category": "jvm",
    "qes": "阿里巴巴Java开发手册中强制线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，为什么？",
    "ans": "  Executor返回线程池对象的弊端如下：</br>1.FixedThreadPool和SingleThreadExecutor:允许请求的队列长度为Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</br>2.CacheThreadPool和ScheduledThreadPool：允许创建的线程数量为Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM"
  },
  {
    "category": "jvm",
    "qes": "线程池大小确定的依据",
    "ans": "线程池数量的确定一直是困扰着程序员的一个难题，大部分程序员在设定线程池大小的时候就是随心而定。我们并没有考虑过这样大小的配置是否会带来什么问题，我自己就是这大部分程序员中的一个代表。\n\n由于笔主对如何确定线程池大小也没有什么实际经验，所以，这部分内容参考了网上很多文章/书籍。\n\n首先，可以肯定的一点是线程池大小设置过大或者过小都会有问题。合适的才是最好，貌似在 95 % 的场景下都是合适的。\n\n如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。\n\n但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</br></br>有一个简单并且适用面比较广的公式：\n\n</br>1.CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。\n</br>2.I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。"
  },
  {
    "category": "jvm",
    "qes": "java.util.concurrent简称juc，该包中的原子类是哪4类？",
    "ans": "1.基本类型(使用原子的方式更新基本类型)</br>2.数组类型(使用原子的方式更新数组里的某些元素)</br>3.引用类型</br>4.对象的属性修改类型"
  },
  {
    "category": "jvm",
    "qes": "简要描述AQS原理",
    "ans": "AQS的全称是AbstractQueuedSynchronizer,AQS的核心思想是如果被请求的共享共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到的线程加入到队列中。"
  },
  {
    "category": "jvm",
    "qes": "接上问，CLH是什么？",
    "ans": "Craig,Landin, and Hagersten队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH队列的一个结点(Node)来实现锁的分配"
  },
  {
    "category": "jvm",
    "qes": "JDK1.8前后，Java的内存区域发生了哪些变化？",
    "ans": "线程共享的方法区(内含运行时常量)变成了直接内存中的元空间，即从方法区(PermGen)到元空间(MetaSpace)"
  },
  {
    "category": "jvm",
    "qes": "接上问，什么是方法区？",
    "ans": " 1.JDK1.8以前的HotSpot JVM有方法区，也叫做永久代</br>2.方法区用于存放已被虚拟机加载的类信息、常量、静态变量、即编译器编译后的代码；</br>3.方法区是一片连续的堆空间，通过-XX:MaxPermSize来设定永久代最大可分配空间，当JVM加载的类信息容量超过这个值，会报OOM:PermGen的错误;</br>4.永久代的GC是和老年代的(old generation)捆绑在一起的，无论谁满了都会触发永久代和老年代的垃圾收集;</br>5.JDK1.7开始了方法区的部分移除，符号引用(Symbols)移至native heap，字面量的(interned strings)和静态变量(class statics)移至java heap;</br>6.为什么要用Metaspace代替方法区？随着动态类加载的情况越来越多，这块内存变得不太可控，如果设置小了，系统运行过程中的就容易出现内存溢出，设置大了又浪费内存。"
  },
  {
    "category": "jvm",
    "qes": "元空间MetaSpace的组成？",
    "ans": "元空间(MetaSpace)由两大部分组成:Klass Metaspace和NoKlass Metaspace。</br>1.Klass Metaspace就是用来存klass的，就是class文件在jvm里的运行时数据结构(不过我们看到的类似A.class其实是存在heap里的，是java.lang.Class的对象实例);</br>2.NoKlass Metaspace专门来存klass相关的其他内容，比如method,constantPool等，可以由多块不连续的内存组成"
  },
  {
    "category": "jvm",
    "qes": "jdk1.8下Java的内存区域(运行时数据区)哪些是线程共享的，哪些是线程私有的",
    "ans": "1.线程私有：程序计数器，虚拟机栈，本地方法栈；2.线程共享：堆，方法区，直接内存(非运行时数据区的一部分)"
  },
  {
    "category": "jvm",
    "qes": "简单解释一下程序计数器",
    "ans": "程序计数器是一块比较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码指示器工作时通过改变这个计时器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存；</br>因此，我们可以总结出程序计数器主要有如下的两个作用，1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如:顺序执行，选择，循环，异常处理；2.在多线程的处理下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能狗知道程序上次执行到哪儿了。注意：程序计数器是为一个个不会出险OOM的内存区域，它的生命周期随着线程的创建而创建，随着现成的结束而死亡"
  },
  {
    "category": "jvm",
    "qes": "简单解释一下Java虚拟机栈",
    "ans": "和程序计数器一样，Java虚拟机栈也是程序私有的，它的生命周期和线程周期相同，描述的是Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java内存可以粗糙的区分为堆内存(Heap)和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。(实际上，Java虚拟机栈是由一个个栈帧组成的，而每一格栈帧中都拥有：局部变量表，操作数栈，动态链接，方法出口信息。)</br>局部变量表主要存放了编译器可知的各种数据类型(boolean,byte,char,short,int,float,long,double)，对象引用(reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他于此对象相关的位置)"
  },
  {
    "category": "jvm",
    "qes": "Java虚拟机栈会出现两种异常,哪两种？",
    "ans": "StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前java虚拟机栈的最大深度时，就抛出StackOverFlowError异常</br>OutOfMemoryError：若Java虚拟机栈的内存大小允许动态扩展，且当前线程请求栈时内存用完了，无法再动态扩展了，此时就会抛出OOM异常"
  },
  {
    "category": "jvm",
    "qes": "简单解释一下本地方法栈？",
    "ans": "和虚拟机栈发挥的作用非常类似，区别是：虚拟机栈为虚拟执行java方法(也就是字节码)服务，而本地方法栈则为虚拟机栈使用到的Native方法服务，在HotSpot虚拟机中和Java虚拟机栈合二为一；</br>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</br>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种异常"
  },
  {
    "category": "jvm",
    "qes": "简单解释一下堆空间",
    "ans": "Java堆是Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存；</br>Java堆是垃圾收集器管理的主要区域，因此也被称作GC堆(Garbage Collected Heap)从垃圾回收的角度，由于现在收集器基本采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间，From Survivor,To Survivor空间等，进一步划分的目的是更好的回收内存，或者更快的分配内存"
  },
  {
    "category": "jvm",
    "qes": "Java堆可以分为哪几代？",
    "ans": "Java堆可以分为新生代和老年代，再细致一点的可以分为(按从新到老的顺序)eden->s0->s1->tentired,其中前三是新生代，最后一个老年代，大部分情况下，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1,并且对象的年龄还会加1(Eden区->Survivor区后对象的初始年龄变为1)，当它的年龄增加到一定程度(默认为15岁)，就会被晋升到老年代中，对象晋升到老年代的年龄域值，可以通过参数(-XX:MaxTenuringThreshold来设置)"
  },
  {
    "category": "jvm",
    "qes": "简单解释一下方法区",
    "ans": "方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作Non-Heap(非堆)，目的是与Java堆区分开来"
  },
  {
    "category": "jvm",
    "qes": "方法区和永久代的关系",
    "ans": "Java虚拟机规范只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它，那么，在不同的JVM上方法区的实现肯定是不同的，方法区和永久代的关系很象Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的实现方式。也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法；JDK1.8的时候，方法区(HotSpot的永久代)被彻底移除了，(JDK1.7就已经开始了)，取而代之的是元空间，元空间使用的是直接内存"
  },
  {
    "category": "jvm",
    "qes": "为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢",
    "ans": "整个永久代有一个JVM本身设定固定大小上限，无法进行调整，而元空间使用的是直接内存，收本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError，你可以使用-XX:MaxMetaspaceSize标志设置最大空间大小，默认值为unlimited，这意味着它只受系统内存的限制，。-XX:MetaspaceSize调整标志定义元空间的初始大小如果未指定此标志，则Metaspace将根据运行时的应用程序需求动态的重新调整大小"
  },
  {
    "category": "jvm",
    "qes": "简答解释一下直接内存",
    "ans": "直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。"
  },
  {
    "category": "jvm",
    "qes": "说一下Java内存的创建过程",
    "ans": "类检查机制->分配内存->初始化零值->设置对象头->执行init方法</br>1.类加载检查：虚拟机遇到一条new指令时，首先将去检查这个指令地参数是否能在常量池中定位到这个类地符号引用，并且检查这个符号引用代表地类是否已被加载过、解析和初始化过。如果没有，那就必须先执行相应的类加载过程</br>2.分配内存:在类加载检查通过后，接下来虚拟机将为新生对象分配内存，对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，分配方式有指针碰撞和空闲列表两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采集的垃圾收集器是否带有压缩整理功能决定"
  },
  {
    "category": "jvm",
    "qes": "分配内存的两种方式",
    "ans": "1.指针碰撞:适用场合:堆内存规整(即没有内存碎片)的情况下；原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界值指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可;GC收集器:Serial,ParNew</br> 2.空闲列表：适用场合:堆内存不规整的情况下；原理:虚拟机会维护一个列表，该列表会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录;GC收集器:CMS"
  },
  {
    "category": "jvm",
    "qes": "内存分配的并发问题，虚拟机有哪些办法来保证线程安全?",
    "ans": "1.CAS+失败重试:CAS乐观锁的一种实现方式，所谓的乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用的是CAS配上失败重试的方式保证更新操作的原子性</br>TLAB:为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配"
  },
  {
    "category": "jvm",
    "qes": "初始化零值的过程",
    "ans": "内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，(不包括对象头)，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值"
  },
  {
    "category": "jvm",
    "qes": "设置对象头的过程",
    "ans": "初始化零值完成后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些信息才能放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏置锁等，对象头会有不同的设置方法"
  },
  {
    "category": "jvm",
    "qes": "执行init的方法",
    "ans": "在上面工作都完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的角度来看，执行new指令之后会接着执行init方法，把对象按照程序员的义元进行初始化，，这样一个真正可用的对象才算完全产生出来"
  },
  {
    "category": "jvm",
    "qes": "对象的访问定位有哪两种方式",
    "ans": "建立对象就是为了访问对象，我们的Java程序通过栈上的reference数据来操作堆上的具体对象，对象的访问方式有虚拟机实现而定，目前的主流访问方式有</br>1.句柄:如果使用句柄的话，那么java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</br>2.直接指针:如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址</br>这两种对象访问方式各有优势，使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改，使用直接指针访问的最大好处是速度快，它节省了一次指针定位到时间开销"
  },
  {
    "category": "jvm",
    "qes": "说一下堆内存中对象的分配的基本策略",
    "ans": "堆内存可分为新生代(eden代->s0代->s1代)以及老年代(tentired)区属于老年代。大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1,并且对象的年龄还会加1，(Eden区->Survivor区后对象的初始年龄变为1)，当它的年龄增加到一定程度(默认为15岁)，就会被晋升到老年代中，并长久的存在。可以通过参数-XX:MaxTenuringThreshould来设置。</br>另外，大对象和长期存活的对象会直接进入老年代</br>总结(堆内存常见的分配策略):1.对象优先在eden区分配，2.大对象直接进入老年代，3.长期存活的对象将进入老年代"
  },
  {
    "category": "jvm",
    "qes": "Minor GC和Full GC有什么不同?",
    "ans": "大多数情况下，对象在新生代中eden区分配，当eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</br>1.新生代GC(Minor GC):指发生新生代的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快;</br>2.老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC经常会伴随一到两次的Minor GC(并非绝对),Major GC的速度一般会比Minor GC的馒10倍以上"
  },
  {
    "category": "jvm",
    "qes": "判断对象死亡有哪几种方法",
    "ans": "1.引用计数法:给对象中添加一个应用计数器，每当有一个地方引用它，计数器就+1;当引用失效，计数器就-1；任何时候计数器为0的对象就是不可能再被使用的；</br>可达性分析算法:这个算法的基本思想就是通过一系列的称为GC Root的对象作为起点，从这些结点开始开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Root没有任何引用链相连的话，则证明此对象是不可用的"
  },
  {
    "category": "jvm",
    "qes": "简单介绍一下强引用，软引用，弱引用，虚引用",
    "ans": "<table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" style=\"width:500px;\"><tbody><tr><td>引用类型</td><td>被回收时间</td><td>用途</td><td>生存时间</td></tr><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时</td></tr><tr><td>软引用</td><td>内存不足时</td><td>对象缓存</td><td>内存不足时</td></tr><tr><td>弱引用</td><td>jvm垃圾回收时</td><td>对象缓存</td><td>gc运行后</td></tr><tr><td>虚引用</td><td>未知</td><td>未知</td><td>未知</td></tr></tbody></table>"
  },
  {
    "category": "jvm",
    "qes": "如何判断一个常量是废弃常量，一个类是无用类",
    "ans": "判断一个对象是否是一个废弃对象，需想到的是检测垃圾对象的两种方法：</br></br>1.引用计数法</br>给对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1</br></br>     2.可达性分析算法</br></br>以根集对象为起始点进行搜索，如果对象不可达的话，即为垃圾对象。这里的根集指java栈中引用的对象、方法去常量池中引用的对象，本地方法中引用的对象等。</br></br>综上，判断一个对象是否为废弃对象，1.引用计数为0    2.对象不可达</br></br> </br></br>相比对象的判断，一个类是否为无用类，就复杂了点。类需要同时满足下面3个条件才能算无用的类：</br></br>该类所有的实例都已经被回收，也就是说java堆中不存在该类的任何实例。</br>加载该类的ClassLoader已经被回收</br>该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</br>Jvm可以对满足以上条件的无用类进行回收，当然这里所说的是可以，并不代表，和对象一样不使用了，就一定会被回收"
  },
  {
    "category": "jvm",
    "qes": "垃圾收集有哪些算法，各自的特点",
    "ans": "1.标记-清除算法</br>标记-清除算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高</br>空间问题（标记清除后会产生大量不连续的碎片）</br>2. 复制算法</br>它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</br>3. 标记-整理算法</br>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</br>4.分代收集算法</br>因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。</br></br>分为老年代和新生代区。新生代区又被分为Eden区和两个Survivor区。新产生的对象放在新生代的Eden区，当Eden区满的时候，清理Eden区的垃圾，将存活对象放在Survivor一区。当Eden区又满的时候，清理Eden区和Survivor一区，并将存活对象放在Survivor二区。依次这样循环。当对象经过15次垃圾收集都没有被收集后，就放到老年区，中间放不下的对象，大对象也放在老年区。"
  },
  {
    "category": "jvm",
    "qes": "hotspot为什么要分为新生代和老年代？为什么要有Survivor区？",
    "ans": "HotSpot为什么要分为新生代和老年代？</br>因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。</br></br>为什么要有Survivor区？</br>如果没有Survivor区，那么Eden每次满了清理垃圾，存活的对象被迁移到老年区，老年区满了，就会触发Full GC，Full GC是非常耗时的，解决办法：</br></br>增加老年代内存，那么老年代清理频次减少，但清理一次花费时间更长。</br>减少老年代内存，老年代一次FullGC时间更少，频率增加。</br>都不行，只有再加一层Survivor。将Eden区满了的对象，添加到Survivor区，等对象反复清理几遍之后都没清理掉，再放到老年区，这样老年区的压力就会小很多。即Survivor相当于一个筛子，筛掉生命周期短的，将生命周期长的放到老年代区，减少老年代被清理的次数。"
  },
  {
    "category": "jvm",
    "qes": "JVM有哪些常见的垃圾回收器？各自的特点是什么？",
    "ans": "<article class=\"article fmt article-content\" data-id=\"1190000037547621\" data-license=\"\">\n                                <h2 id=\"item-1\">前言</h2><p>之前我们讲解了<code>jvm</code>的<code>组成结构</code>与<code>垃圾回收算法</code>等知识点，今天我们来讲讲jvm最重要的<code>堆内存</code>是如何使用<code>垃圾回收器</code>进行垃圾回收，并且如何使用<code>命令</code>去配置使用这些垃圾回收器。</p><h2 id=\"item-2\">堆内存详解</h2><p><span class=\"img-wrap\"></span></p><p>上面这个图大家应该已经很明白了吧。大家就可以理解成一个<code>房子</code>被分成了几个<code>房间</code>，每个房间的作用不同而已，有的是婴儿住的，有的是父母住的，有的是爷爷奶奶住的</p><ul><li>堆内存被划分为<code>两块</code>，一块的<code>年轻代</code>，另一块是<code>老年代</code>。</li><li>年轻代又分为<code>Eden</code>和<code>survivor</code>。他俩空间大小比例默认为8:2,</li><li>幸存区又分为<code>s0</code>和<code>s1</code>。这两个空间大小是一模一样的，就是一对双胞胎，他俩是1:1的比例</li></ul><h3 id=\"item-2-1\">堆内存垃圾回收过程</h3><h4>第一步</h4><p><code>新生成</code>的对象首先放到<code>Eden</code>区，当Eden区<code>满了</code>会触发<code>Minor GC</code>。</p><h4>第二步</h4><p>第一步GC活下来的对象，会被移动到<code>survivor</code>区中的S0区，S0区满了之后会触发<code>Minor GC</code>，S0区存活下来的对象会被移动到S1区，S0区空闲。</p><p>S1满了之后在GC，存活下来的再次移动到S0区，S1区空闲，这样反反复复GC，每GC一次，对象的年龄就<code>涨一岁</code>，达到某个值后（15），就会进入<code>老年代</code>。</p><h4>第三步</h4><p>在发生一次<code>Minor GC</code>后（前提条件），老年代可能会出现<code>Major GC</code>，这个视垃圾回收器而定。</p><h4>Full GC触发条件</h4><ul><li>手动调用System.gc，会不断的执行Full GC</li><li>老年代空间不足/满了</li><li>方法区空间不足/满了</li></ul><h4>注意</h4><p>们需要记住一个单词：<code>stop-the-world</code>。它会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而<code>停止</code>应用程序的执行。</p><p>当stop-the-world 发生时，除GC所需的线程外，所有的<code>线程</code>都进入<code>等待</code>状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生。</p><h4>回收哪些区域的对象</h4><p>需要注意的是，JVM GC只回收<code>堆内存</code>和<code>方法区内</code>的对象。而<code>栈内存</code>的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p><h3 id=\"item-2-2\">堆内存常见参数配置</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>堆内存初始大小，单位m、g</td></tr><tr><td>-Xmx</td><td>堆内存最大允许大小，一般不要大于物理内存的80%</td></tr><tr><td>-XX:PermSize</td><td>非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了</td></tr><tr><td>-XX:MaxPermSize</td><td>非堆内存最大允许大小</td></tr><tr><td>-XX:NewSize（-Xns）</td><td>年轻代内存初始大小</td></tr><tr><td>-XX:MaxNewSize（-Xmn）</td><td>年轻代内存最大允许大小</td></tr><tr><td>-XX:SurvivorRatio=8</td><td>年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td></tr><tr><td>-Xss</td><td>堆栈内存大小</td></tr><tr><td>-XX:NewRatio=老年代/新生代</td><td>设置老年代和新生代的大小比例</td></tr><tr><td>-XX:+PrintGC</td><td>jvm启动后，只要遇到GC就会打印日志</td></tr><tr><td>-XX:+PrintGCDetails</td><td>查看GC详细信息，包括各个区的情况</td></tr><tr><td>-XX:MaxDirectMemorySize</td><td>在NIO中可以直接访问<strong>直接内存</strong>，这个就是设置它的大小，不设置默认就是最大堆空间的值-Xmx</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾可以进入老年代的年龄</td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收</td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比，默认是1%</td></tr><tr><td>-XX:+CollectGen0First</td><td>FullGC时是否先YGC，默认false</td></tr></tbody></table><h3 id=\"item-2-3\">TLAB 内存</h3><p>TLAB全称是Thread Local Allocation Buffer即<code>线程本地分配缓存</code>，从名字上看是一个线程专用的内存分配区域，是为了加速对象分配而生的。</p><p>每一个线程都会产生一个TLAB，该线程独享的工作区域，java虚拟机使用这种TLAB区来避免多线程冲突问题，提高了对象分配的效率。</p><p>TLAB空间一般不会太大，当大对象无法在TLAB分配时，则会直接分配到堆上。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-Xx:+UseTLAB</td><td>使用TLAB</td></tr><tr><td>-XX:+TLABSize</td><td>设置TLAB大小</td></tr><tr><td>-XX:TLABRefillWasteFraction</td><td>设置维护进入TLAB空间的单个对象大小，他是一个比例值，默认为64，即如果对象大于整个空间的1/64，则在堆创建</td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB信息</td></tr><tr><td>-Xx:ResizeTLAB</td><td>自调整TLABRefillWasteFraction阀值。</td></tr></tbody></table><p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" src=\"/img/bVcHHZJ\" alt=\"image.png\" title=\"image.png\"></span></p><h2 id=\"item-3\">垃圾回收器总览</h2><p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" src=\"/img/bVcHHZL\" alt=\"image.png\" title=\"image.png\"></span></p><p>新生代可配置的回收器：Serial、ParNew、Parallel Scavenge</p><p>老年代配置的回收器：CMS、Serial Old、Parallel Old</p><p>新生代和老年代区域的回收器之间进行连线，说明他们之间可以搭配使用。</p><h2 id=\"item-4\">新生代垃圾回收器</h2><h3 id=\"item-4-4\">Serial 垃圾回收器</h3><p>Serial收集器是最基本的、发展历史最悠久的收集器。俗称为：<code>串行回收器</code>，采用<code>复制算法</code>进行垃圾回收</p><h4>特点</h4><p>串行回收器是指使用单线程进行垃圾回收的回收器。每次回收时，串行回收器只有一个工作线程。</p><p>对于并行能力较弱的单CPU计算机来说，串行回收器的专注性和独占性往往有更好的性能表现。</p><p>它存在Stop The World问题，及垃圾回收时，要停止程序的运行。</p><p>使用<code>-XX:+UseSerialGC</code>参数可以设置新生代使用这个串行回收器</p><h3 id=\"item-4-5\">ParNew 垃圾回收器</h3><p>ParNew其实就是Serial的<code>多线程</code>版本，除了使用多线程之外，其余参数和Serial一模一样。俗称：<code>并行垃圾回收器</code>，采用<code>复制算法</code>进行垃圾回收</p><h4>特点</h4><p>ParNew默认开启的线程数与CPU数量相同，在CPU核数很多的机器上，可以通过参数<code>-XX:ParallelGCThreads</code>来设置线程数。</p><p>它是目前新生代首选的垃圾回收器，因为除了ParNew之外，它是唯一一个能与老年代CMS配合工作的。</p><p>它同样存在Stop The World问题</p><p>使用<code>-XX:+UseParNewGC</code>参数可以设置新生代使用这个并行回收器</p><h3 id=\"item-4-6\">ParallelGC 回收器</h3><p>ParallelGC使用复制算法回收垃圾，也是多线程的。</p><h4>特点</h4><p>就是非常关注系统的吞吐量，<code>吞吐量</code>=<code>代码运行时间</code>/(<code>代码运行时间</code>+<code>垃圾收集时间</code>)</p><p><code>-XX:MaxGCPauseMillis</code>：设置最大垃圾收集停顿时间，可用把虚拟机在GC停顿的时间控制在MaxGCPauseMillis范围内，如果希望减少GC停顿时间可以将MaxGCPauseMillis设置的很小，但是会导致<code>GC频繁</code>，从而增加了GC的<code>总时间</code>，<code>降低</code>了<code>吞吐量</code>。所以需要根据实际情况设置该值。</p><p><code>-Xx:GCTimeRatio</code>：设置吞吐量大小，它是一个0到100之间的整数，默认情况下他的取值是<code>99</code>，那么系统将花费不超过<code>1/(1+n)</code>的时间用于垃圾回收，也就是<code>1/(1+99)=1%</code>的时间。</p><p>另外还可以指定<code>-XX:+UseAdaptiveSizePolicy</code>打开自适应模式，在这种模式下，新生代的大小、eden、from/to的比例，以及晋升老年代的对象年龄参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</p><p>使用-XX:+UseParallelGC参数可以设置新生代使用这个并行回收器</p><h2 id=\"item-5\">老年代垃圾回收器</h2><h3 id=\"item-5-7\">SerialOld 垃圾回收器</h3><p>SerialOld是Serial回收器的<code>老年代</code>回收器版本，它同样是一个<code>单线程</code>回收器。</p><h4>用途</h4><ul><li>一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，</li><li>另一个就是作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。</li></ul><p><code>使用算法</code>：标记 - 整理算法</p><h3 id=\"item-5-8\">ParallelOldGC 回收器</h3><p>老年代<code>ParallelOldGC</code>回收器也是一种多线程的回收器，和新生代的ParallelGC回收器一样，也是一种关注吞吐量的回收器，他使用了<code>标记压缩算法</code>进行实现。</p><p><code>-XX:+UseParallelOldGc</code>进行设置老年代使用该回收器</p><p><code>-XX:+ParallelGCThreads</code>也可以设置垃圾收集时的线程数量。</p><h3 id=\"item-5-9\">CMS 回收器</h3><p>CMS全称为:Concurrent Mark Sweep意为并发标记清除，他使用的是<code>标记清除法</code>。主要关注系统停顿时间。</p><p>使用<code>-XX:+UseConcMarkSweepGC</code>进行设置老年代使用该回收器。</p><p>使用<code>-XX:ConcGCThreads</code>设置并发线程数量。</p><h4>特点</h4><p>CMS并不是独占的回收器，也就说CMS回收的过程中，应用程序仍然在不停的工作，又会有新的垃圾不断的产生，所以在使用CMS的过程中应该确保应用程序的内存足够可用。</p><p>CMS不会等到应用程序<code>饱和</code>的时候才去回收垃圾，而是在某一阀值的时候开始回收，回收阀值可用指定的参数进行配置：<code>-XX:CMSInitiatingoccupancyFraction</code>来指定，默认为<code>68</code>，也就是说当老年代的空间<code>使用率</code>达到<code>68%</code>的时候，会<code>执行</code>CMS回收。</p><p>如果内存使用率增长的很快，在CMS执行的过程中，已经出现了内存不足的情况，此时CMS回收就会失败，虚拟机将启动老年代<code>串行</code>回收器；<code>SerialOldGC</code>进行垃圾回收，这会导致应用程序中断，直到垃圾回收完成后才会正常工作。</p><p>这个过程GC的停顿时间可能较长，所以<code>-XX:CMSInitiatingoccupancyFraction</code>的设置要根据实际的情况。</p><p>之前我们在学习算法的时候说过，标记清除法有个缺点就是存在<code>内存碎片</code>的问题，那么CMS有个参数设置<code>-XX:+UseCMSCompactAtFullCollecion</code>可以使CMS回收完成之后进行一次<code>碎片整理</code>。</p><p><code>-XX:CMSFullGCsBeforeCompaction</code>参数可以设置进行多少次CMS回收之后，对内存进行一次<code>压缩</code>。</p><h3 id=\"item-5-10\">G1 回收器</h3><p>篇幅太长，我们下篇文章讲解！！！</p><p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" src=\"/img/bVcHHZW\" alt=\"image.png\" title=\"image.png\"></span></p><h2 id=\"item-6\">IT 老哥</h2><p><em><strong><code>一个在大厂做高级Java开发的程序猿，一路自学走到今天，关注 老哥，我们一起来自学技术</code></strong></em></p>\n                            </article>"
  },
  {
    "category": "jvm",
    "qes": "Java类加载过程",
    "ans": "<div id=\"content_views\" class=\"htmledit_views\">\n                    <p><strong><span style=\"font-family:Arial Black; font-size:18px\"><span style=\"color:#003300\">转载请注明出处：</span><a target=\"_blank\" href=\"http://blog.csdn.net/ns_code/article/details/17881581\" rel=\"noopener noreferrer\"><span style=\"color:#660000\">http://blog.csdn.net/ns_code/article/details/17881581</span></a></span></strong></p> \n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><br> </span></p> \n<h1><a name=\"t0\"></a><a name=\"t0\"></a><span style=\"font-family:Microsoft YaHei; font-size:18px; color:#000099\">类加载过程</span></h1> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#003300\"><strong>&nbsp; &nbsp;&nbsp;</strong></span>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示：</span></p> \n<p style=\"text-align:center\"><img alt=\"\" src=\"https://img-blog.csdn.net/20140105211344671\"><br> </p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 其中<span style=\"color:#ff0000\">类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。</span>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序<strong>开始</strong>，而不是按顺序<strong>进行</strong>或<strong>完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</span></p> \n<p><span style=\"font-size:14px\"><span style=\"font-family:'Microsoft YaHei'\">&nbsp; &nbsp; 这里简要说明下Java中的绑定：</span><span style=\"line-height:26px\"><span style=\"font-family:Microsoft YaHei\">绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：</span></span></span></p> \n<p></p> \n<ul><li><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"line-height:26px\">静态绑定：即前期绑定。<span style=\"line-height:26px\">在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</span></span></span></li><li><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"line-height:26px\">动态绑定：即晚期绑定，也叫运行时绑定。<span style=\"line-height:26px\">在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</span></span></span></li></ul> \n<div>\n <span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"line-height:26px\">&nbsp; &nbsp; 下面详细讲述类加载过程中每个阶段所做的工作。</span></span>\n</div> \n<div>\n <span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"line-height:26px\"><br> </span></span>\n</div> \n<h2><a name=\"t1\"></a><a name=\"t1\"></a><span style=\"color:#0099\"><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp;<span style=\"color:#000099\">加载</span></span></span></h2> \n<p></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp; 1、通过一个类的全限定名来获取其定义的二进制字节流。</span></span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp; 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</span></span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp; 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</span></span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。</span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; <span style=\"color:#ff0000\"> 说到加载，不得不提到类加载器，下面就具体讲述下类加载器。</span></span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。</span></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</span></p> \n<p></p> \n<ul><li><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。</span></span></li><li><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</span></span></li></ul> \n<p></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</span></p> \n<p></p> \n<ul><li><span style=\"font-family:Microsoft YaHei; font-size:14px\">启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">Bootstrap ClassLoader加载</span>）。启动类加载器是无法被Java程序直接引用的。</span></li><li><span style=\"font-family:Microsoft YaHei; font-size:14px\">扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</span></li><li><span style=\"font-family:Microsoft YaHei; font-size:14px\">应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，<span style=\"color:#ff0000\">一般情况下这个就是程序中默认的类加载器。</span></span></li></ul> \n<p></p> \n<p><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; &nbsp;应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。</span><span style=\"line-height:24px; text-indent:2em\"><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#ff0000\">因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</span></span></span></p> \n<p style=\"text-indent:24px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px; line-height:24px; text-indent:2em\">&nbsp;1）在执行非置信代码之前，自动验证数字签名。</span></p> \n<p style=\"text-indent:24px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px; line-height:24px; text-indent:2em\">&nbsp;2）动态地创建符合用户特定需要的定制化构建类。</span></p> \n<p style=\"text-indent:24px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px; line-height:24px; text-indent:2em\">&nbsp;3）从特定的场所取得java class，例如数据库中和网络中。</span></p> \n<p style=\"text-indent:24px\"><span style=\"line-height:24px; font-family:'Microsoft YaHei'; font-size:14px\">事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，</span><span style=\"line-height:24px; font-family:'Microsoft YaHei'; font-size:14px; text-indent:2em\">应用服务器也大都使用了自定义的ClassLoader技术。</span></p> \n<p></p> \n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&nbsp; &nbsp; 这几种类加载器的层次关系如下图所示：</span></p> \n<p style=\"text-align:center\"><img alt=\"\" src=\"https://img-blog.csdn.net/20140105211242593\"><br> </p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 这种层次关系称为类加载器的<span style=\"color:#ff0000\">双亲委派模型</span>。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。</span></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</span></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 使用双亲委派模型来组织类加载器之间的关系，<span style=\"color:#ff0000\">有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系</span>，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\\jre\\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。</span></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\"><br> </span></p> \n<p style=\"text-align:left\"></p> \n<h2 style=\"font-family:'Microsoft YaHei'; font-size:14px\"><a name=\"t2\"></a><a name=\"t2\"></a><span style=\"color:#0099\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&nbsp; &nbsp;<span style=\"color:#000099\">验证</span></span></span></h2> \n<span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：<span style=\"color:#ff0000\">文件格式的验证、元数据的验证、字节码验证和符号引用验证。</span></span> \n<p></p> \n<p style=\"text-align:left\"></p> \n<ul><li><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。<br> </span></span></li><li><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</span></span></li><li><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</span></span></li><li><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</span></span></li></ul> \n<div>\n <span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\"><br> </span></span>\n</div> \n<p></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\"></span></p> \n<h2 style=\"font-family:'Microsoft YaHei'\"><a name=\"t3\"></a><a name=\"t3\"></a><span style=\"color:#0099\"><span style=\"font-size:14px\">&nbsp; &nbsp;<span style=\"color:#000099\">准备</span></span></span></h2> \n<span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; <span style=\"color:#ff0000\"> 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</span><span style=\"color:#ff0000\">对于该阶段有以下几点需要注意：</span></span> \n<p></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#ff0000\">&nbsp; &nbsp;&nbsp;</span><span style=\"color:#0099\">1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</span></span></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#0099\">&nbsp; &nbsp; 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</span></span></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp;</span>假设一个类变量的定义为：</span></span></p> \n<p style=\"text-align:center\"><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">public static int value = 3；</span></span></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">&nbsp; &nbsp; 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器&lt;clinit&gt;（）方法之中的，<span style=\"color:#ff0000\">所以把value赋值为3的动作将在初始化阶段才会执行。</span></span></span></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 下表列出了Java中所有基本数据类型以及reference类型的默认零值：</span></p> \n<p style=\"text-align:center\"><span style=\"font-family:Microsoft YaHei; font-size:14px\"><img alt=\"\" src=\"https://img-blog.csdn.net/20140105195119234\"><br> </span></p> \n<p style=\"text-align:left\"><span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#ff0000\">&nbsp; &nbsp;</span>这里还需要注意如下几点：</span></p> \n<p style=\"text-align:left\"></p> \n<ul><li><span style=\"font-family:'Microsoft YaHei'; font-size:14px; color:#ff00\">对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</span></li><li><span style=\"font-family:'Microsoft YaHei'; font-size:14px; color:#ff00\">对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</span></li><li><span style=\"font-family:'Microsoft YaHei'; font-size:14px; color:#ff00\">对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</span></li><li><span style=\"font-family:'Microsoft YaHei'; font-size:14px; color:#ff00\">如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</span></li></ul> \n<p></p> \n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&nbsp; &nbsp;&nbsp;<span style=\"color:#000099\">3</span><span style=\"font-family:'Microsoft YaHei'; font-size:14px; color:#0099\">、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</span></span></p> \n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp;</span>假设上面的类变量value被定义为：</span>&nbsp;</span></span></p> \n<p style=\"text-align:center\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">public static final int value = 3；</span></span></p> \n<p style=\"text-align:left\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&nbsp; &nbsp; 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆<a target=\"_blank\" href=\"http://blog.csdn.net/ns_code/article/details/17845821\" rel=\"noopener noreferrer\"><strong>上一篇博文</strong></a>中对象被动引用的第2个例子，便是这种情况。<span style=\"color:#ff0000\">我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。</span></span></span></p> \n<p style=\"text-align:left\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"color:#ff0000\"><br> </span></span></span></p> \n<p style=\"text-align:center\"></p> \n<h2 style=\"text-align:left; font-family:'Microsoft YaHei'; font-size:14px\"><a name=\"t4\"></a><a name=\"t4\"></a><span style=\"color:#0099\"><span style=\"font-size:14px\">&nbsp; &nbsp;<span style=\"color:#000099\">解析</span></span></span></h2> \n<div style=\"text-align:left; font-family:'Microsoft YaHei'; font-size:14px\">\n <span style=\"font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp;</span>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在<a target=\"_blank\" href=\"http://blog.csdn.net/ns_code/article/details/17675609\" rel=\"noopener noreferrer\"><strong>Class类文件结构</strong></a>一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</span>\n</div> \n<div style=\"text-align:left; font-family:'Microsoft YaHei'; font-size:14px\">\n <span style=\"font-size:14px\">&nbsp; &nbsp; 对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。</span>\n</div> \n<div style=\"text-align:left; font-family:'Microsoft YaHei'; font-size:14px\">\n <span style=\"font-size:14px\">&nbsp; &nbsp; 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、</span>CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。\n</div> \n<div style=\"text-align:left; font-family:'Microsoft YaHei'; font-size:14px\">\n <span style=\"font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"></span></span></span>\n</div> \n<div style=\"text-align:left; font-family:'Microsoft YaHei'; font-size:14px\">\n <span style=\"font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&nbsp; &nbsp; <strong>1、类或接口的解析：</strong>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</span></span></span></span>\n</div> \n<div style=\"text-align:left; font-family:'Microsoft YaHei'; font-size:14px\">\n <span style=\"font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&nbsp; &nbsp; <strong>2、字段解析：</strong>对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：</span></span></span></span>\n</div> \n<div style=\"text-align:center; font-family:'Microsoft YaHei'; font-size:14px\">\n <span style=\"font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><img alt=\"\" src=\"https://img-blog.csdn.net/20140105220608531\"><br> </span></span></span></span>\n</div> \n<div style=\"font-family:'Microsoft YaHei'; font-size:14px\">\n <span style=\"color:#0099\"><span style=\"font-size:14px\"><br> </span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px; color:#000099\">&nbsp;</span>\n <span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\">&nbsp;</span><span style=\"font-size:14px\"> 从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\"></span></span>\n <pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Super</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> m = <span class=\"hljs-number\">11</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">static</span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(<span class=\"hljs-string\">\"执行了super类静态语句块\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Super</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> m = <span class=\"hljs-number\">33</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">static</span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(<span class=\"hljs-string\">\"执行了父类静态语句块\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Child</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"17\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">static</span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"18\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(<span class=\"hljs-string\">\"执行了子类静态语句块\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"19\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"20\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"21\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"22\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StaticTest</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"23\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"24\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(Child.m);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"25\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"26\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li></ol></code><div class=\"hljs-button signin\" data-title=\"登录后复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.signin(event)\"></div></pre>&nbsp; &nbsp; 执行结果如下：\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\"><span style=\"color:#009900\">&nbsp; &nbsp; 执行了super类静态语句块<br> &nbsp; &nbsp; 执行了父类静态语句块<br> &nbsp; &nbsp; 33</span><br> &nbsp; &nbsp; 如果注释掉Father类中对m定义的那一行，则输出结果如下：</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px; color:#009900\">&nbsp; &nbsp; 执行了super类静态语句块<br> &nbsp; &nbsp; 11</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei\"><span style=\"font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp;</span>另外，很明显这就是<a target=\"_blank\" href=\"http://blog.csdn.net/ns_code/article/details/17845821\" rel=\"noopener noreferrer\"><strong>上篇博文</strong></a>中的第1个例子的情况，这里我们便可以分析如下：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp;</span>&nbsp;<span style=\"color:#ff0000\">最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。</span>如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：</span>\n</div> \n<div>\n <span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#009900\">StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m<br> 都匹配<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(Child.m);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br> 1 错误</span><br> </span>\n</div> \n<span style=\"font-family:Microsoft YaHei; font-size:14px\"></span> \n<div style=\"text-align:left\">\n <span style=\"color:#000099\">&nbsp; &nbsp;</span>\n <strong>&nbsp; &nbsp; &nbsp;3、类方法解析：</strong>对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。\n</div> \n<div style=\"text-align:left\"> \n <div style=\"font-family:'Microsoft YaHei'; font-size:14px\">\n  <span style=\"color:#000099\">&nbsp; &nbsp;</span>\n  <strong>&nbsp;4、接口方法解析：</strong>与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。\n </div> \n <br> \n <h2 style=\"font-family:'Microsoft YaHei'; font-size:14px\"><a name=\"t5\"></a><a name=\"t5\"></a>&nbsp; &nbsp; <span style=\"color:#000099\"> 初始化</span></h2> \n <span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp;&nbsp;</span>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。</span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei; font-size:14px\"><span style=\"color:#ff0000\">&nbsp; &nbsp;</span><span style=\"color:#ff0000\">这里简单说明下&lt;clinit&gt;（）方法的执行规则:</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp; 1、&lt;clinit&gt;（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"color:#000099\"><span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 2、<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法与实例构造器&lt;init&gt;（）方法（</span></span><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">类的构造函数</span><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法执行之前，父类的<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法已经执行完毕。因此，在虚拟机中第一个被执行的<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法的类肯定是java.lang.Object。</span></span></span></span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp; 3、<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;（）方法。</span></span></span></span></span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp; 4、接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法。但是接口鱼类不同的是：执行接口的<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法不需要先执行父接口的<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法。</span></span></span></span></span></span></span></span></span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"color:#000099\">&nbsp; &nbsp; 5、虚拟机会保证一个类的&lt;clinit&gt;（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法，其他线程都需要阻塞等待，直到活动线程执行<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法完毕。如果在一个类的&lt;clinit&gt;（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</span></span></span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><br> </span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&nbsp; &nbsp; 下面给出一个简单的例子，以便更清晰地说明如上规则：</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"></span></span>\n <pre><code class=\"language-java hljs\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Father</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">static</span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\ta = <span class=\"hljs-number\">2</span>;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Child</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Father</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> b = a;</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"> </div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ClinitTest</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>{</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(Child.b);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">}</div></div></li></ol></code><div class=\"hljs-button signin\" data-title=\"登录后复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.signin(event)\"></div></pre>&nbsp;\n <span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp;<span style=\"color:#33cc00\">&nbsp;</span><span style=\"color:#009900\">执行上面的代码，会打印出2，也就是说b的值被赋为了2。</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用&lt;clinit&gt;（）方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的&lt;clinit&gt;（）方法，根据规则2，在此之前，要先执行完其父类Father的&lt;clinit&gt;（）方法，又根据规则1，在执行&lt;clinit&gt;（）方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的&lt;clinit&gt;（）方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的&lt;clinit&gt;（）方法，这样便会将b的赋值为2.</span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp;<span style=\"color:#009900\"> 如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。</span>很明显是根据规则1，执行Father的&lt;clinit&gt;（）方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。</span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:Microsoft YaHei; font-size:14px\">&nbsp; &nbsp; 另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。</span>\n <br> \n <br> \n <br> \n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"></span></span></span> \n <h1><a name=\"t6\"></a><a name=\"t6\"></a><span style=\"font-family:'Microsoft YaHei'; font-size:18px; color:#0099\"><span style=\"color:#000099\">总结</span></span></h1> &nbsp;\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&nbsp; &nbsp; 整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于<span style=\"font-family:'Microsoft YaHei'; font-size:14px\">&lt;clinit&gt;（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。</span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><br> </span></span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><br> </span></span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><br> </span></span></span>\n</div> \n<div style=\"text-align:left\">\n <span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><span style=\"font-family:'Microsoft YaHei'; font-size:14px\"><br> </span></span></span>\n</div>\n                </div>"
  },
  {
    "category": "jvm",
    "qes": "双亲委派模型",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <h1 id=\"类加载器\"><span style=\"font-size: 18pt\">加载类的开放性</span></h1>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp; 我们在了解双亲委派模型之前，不得不先了解一下什么是类加载器。虚拟机设计团队之初是希望类加载过程“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作能放到虚拟机外部实现，以便于让程序自己决定如何获取该类，实现这个动作的代码的工具成为类加载器。</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp; 可能很多人觉得类加载器，顾名思义，就是个加载类的嘛，有啥大不了的，但是类加载这个过程是很严格的，对于任意一个类，我们都需要由加载他的类加载器和类的本身来决定该类在虚拟机之中的唯一性。什么意思呢？？</span><span style=\"font-size: 18px\">就是说我们的虚拟机要比较两个类是否相等，那前提条件是就是这两个类必须是在同一个类加载器加载的，如果两个类都不是由同一个加载器加载的，那么这俩类就一定不相等，所以就没有比较的意义！</span></p>\n<div class=\"cnblogs_Highlighter sh-gutter\">\n<div><div id=\"highlighter_968202\" class=\"syntaxhighlighter  java\"><div class=\"toolbar\"><span><a href=\"#\" class=\"toolbar_item command_help help\">?</a></span></div><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td class=\"gutter\"><div class=\"line number1 index0 alt2\">1</div><div class=\"line number2 index1 alt1\">2</div><div class=\"line number3 index2 alt2\">3</div><div class=\"line number4 index3 alt1\">4</div><div class=\"line number5 index4 alt2\">5</div><div class=\"line number6 index5 alt1\">6</div><div class=\"line number7 index6 alt2\">7</div><div class=\"line number8 index7 alt1\">8</div><div class=\"line number9 index8 alt2\">9</div><div class=\"line number10 index9 alt1\">10</div><div class=\"line number11 index10 alt2\">11</div><div class=\"line number12 index11 alt1\">12</div><div class=\"line number13 index12 alt2\">13</div><div class=\"line number14 index13 alt1\">14</div><div class=\"line number15 index14 alt2\">15</div><div class=\"line number16 index15 alt1\">16</div><div class=\"line number17 index16 alt2\">17</div><div class=\"line number18 index17 alt1\">18</div><div class=\"line number19 index18 alt2\">19</div><div class=\"line number20 index19 alt1\">20</div><div class=\"line number21 index20 alt2\">21</div><div class=\"line number22 index21 alt1\">22</div><div class=\"line number23 index22 alt2\">23</div><div class=\"line number24 index23 alt1\">24</div><div class=\"line number25 index24 alt2\">25</div><div class=\"line number26 index25 alt1\">26</div><div class=\"line number27 index26 alt2\">27</div><div class=\"line number28 index27 alt1\">28</div></td><td class=\"code\"><div class=\"container\"><div class=\"line number1 index0 alt2\"><code class=\"java keyword\">public</code> <code class=\"java keyword\">class</code> <code class=\"java plain\">ClassLoaderTest {</code></div><div class=\"line number2 index1 alt1\">&nbsp;</div><div class=\"line number3 index2 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">public</code> <code class=\"java keyword\">static</code> <code class=\"java keyword\">void</code> <code class=\"java plain\">main(String[] args) </code><code class=\"java keyword\">throws</code> <code class=\"java plain\">Exception {</code></div><div class=\"line number4 index3 alt1\">&nbsp;</div><div class=\"line number5 index4 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">ClassLoader myLoader = </code><code class=\"java keyword\">new</code> <code class=\"java plain\">ClassLoader() {</code></div><div class=\"line number6 index5 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java color1\">@Override</code></div><div class=\"line number7 index6 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">public</code> <code class=\"java plain\">Class&lt;?&gt; loadClass(String name) </code><code class=\"java keyword\">throws</code> <code class=\"java plain\">ClassNotFoundException {</code></div><div class=\"line number8 index7 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">try</code> <code class=\"java plain\">{</code></div><div class=\"line number9 index8 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">String fileName = name.substring(name.lastIndexOf(</code><code class=\"java string\">\".\"</code><code class=\"java plain\">) + </code><code class=\"java value\">1</code><code class=\"java plain\">) + </code><code class=\"java string\">\".class\"</code><code class=\"java plain\">;</code></div><div class=\"line number10 index9 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">InputStream is = getClass().getResourceAsStream(fileName);</code></div><div class=\"line number11 index10 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">if</code> <code class=\"java plain\">(is == </code><code class=\"java keyword\">null</code><code class=\"java plain\">) {</code></div><div class=\"line number12 index11 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">return</code> <code class=\"java keyword\">super</code><code class=\"java plain\">.loadClass(name);</code></div><div class=\"line number13 index12 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number14 index13 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">byte</code><code class=\"java plain\">[] b = </code><code class=\"java keyword\">new</code> <code class=\"java keyword\">byte</code><code class=\"java plain\">[is.available()];</code></div><div class=\"line number15 index14 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">is.read(b);</code></div><div class=\"line number16 index15 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">return</code> <code class=\"java plain\">defineClass(name, b, </code><code class=\"java value\">0</code><code class=\"java plain\">, b.length);</code></div><div class=\"line number17 index16 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">} </code><code class=\"java keyword\">catch</code> <code class=\"java plain\">(IOException e) {</code></div><div class=\"line number18 index17 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">throw</code> <code class=\"java keyword\">new</code> <code class=\"java plain\">ClassNotFoundException(name);</code></div><div class=\"line number19 index18 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number20 index19 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number21 index20 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">};</code></div><div class=\"line number22 index21 alt1\">&nbsp;</div><div class=\"line number23 index22 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">Object obj = myLoader.loadClass(</code><code class=\"java string\">\"org.fenixsoft.classloading.ClassLoaderTest\"</code><code class=\"java plain\">).newInstance();</code></div><div class=\"line number24 index23 alt1\">&nbsp;</div><div class=\"line number25 index24 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">System.out.println(obj.getClass());</code></div><div class=\"line number26 index25 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">System.out.println(obj </code><code class=\"java keyword\">instanceof</code> <code class=\"java plain\">org.fenixsoft.classloading.ClassLoaderTest);</code></div><div class=\"line number27 index26 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number28 index27 alt1\"><code class=\"java plain\">}</code></div></div></td></tr></tbody></table></div></div>\n</div>\n<p>　　<span style=\"font-size: 18px\">就比如上面这段代码，代码运行结果很令人失望，虽然打印出的类路径是相同的，但是比较后的结果却是false，这是为啥啊？好气啊，明明类路径一样，但是结果却不同？</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; 这是因为，我们自己实现了属于我们自己的类加载器，我们选择了我们自己的加载路径去加载该类，而另一个同类路径名的类却是由另一个加载器（<strong>应用程序类加载器</strong>）加载的，只要不是同一个类加载器加载的类，一定不是同一个类！！</span></p>\n<p>&nbsp;</p>\n<p><strong><span style=\"font-size: 18pt\">双亲委派模型</span></strong></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; 从java虚拟机角度来讲，只存在两种不同的类加载器：</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;（1）一种是启动类加载器，由C++语言实现的，属于虚拟机的一部分；</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;（2）一种是所有的其他类加载器，这些都是由Java实现的，独立于虚拟机外部，继承自java.lang.ClassLoader；</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; 但是从<strong>开发人员角度来讲</strong>，应该分的再细一些，绝大部分程序都使用到了以下三种系统提供的类加载器：</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;（1）启动类加载器，该加载器是C++实现的，它负责加载存放于&lt;JAVA_HOME&gt;\\lib目录下的类，它是仅仅按照文件的名字来识别的，名字不符合的类就算放到该目录下，也是毫无卵用的.....</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;（2）扩展类加载器，它是负责加载&lt;JAVA_HOME&gt;\\lib\\Ext目录下的；</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;（3）应用程序类加载器，这个类也被称为系统类加载器，它是负责用户类路径classpath上指定的类库，开发者可以直接使用这个加载器；</span></p>\n<p><span style=\"font-size: 18px\">应用程序都是由这三种加载器相互配合进行加载的，有必要的话，还可以实现属于自己的类加载器，这几种加载器关系如图：</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src=\"https://images2018.cnblogs.com/blog/1229366/201806/1229366-20180624145029820-870443098.png\" alt=\"\" width=\"847\" height=\"626\"></span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;这种层次结构我们就称之为双亲委派模型，可以很直观的看出除了顶层的启动类加载器外，其他的都有属于自己的父类加载器。但是我们在这里不要混淆一个概念，就是继承（Inheritance），这个结构图并不是继承关系而是通过组合的方式来实现向上委托的.......</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;双亲委派的工作流程就是：如果一个类加载器收到了类加载的请求，它是不会自己立马亲自动手去加载的（比较懒，哈哈！），而是把该请求委托给父类，每一层都是如此，到了顶层后，这时就无法再向上传递了，所有的请求都集中到了启动类加载器，当父类反馈自己无法满足这个请求时，这时就会再把请求一层层向下传递。</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;这样的好处是啥？？相信大家看这种层次结构应该很清晰，但是这有什么意义吗？比如java.lang.Object，他是存在rt.jar里的，不论哪种加载器，是系统自带的也好还是我们自己实现的也好，都会把请求一层层的往上委托，直到启动类加载器，而启动类加载器一看，自己是有这个类的，所以加载，因此Object在程序的各个类加载器的加载下永远都是同一个类。反之，没有双亲委派模型，任由各个类加载器自己去加载的话，比如我们开发者自己写了Object类，包名也是java.lang，那么系统中就会出现各种各样的Object，每一个层级的类加载器都加载了自己具有个性的Object，那么作为程序中这么基础这么重要的Object，他的唯一性得不到保证，应用程序就会杂乱不堪。</span></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;双亲委派模型的作用想必到这里很多人应该清楚了，觉得：“哇！这个模型还真的是很强大呢...”。他的实现也是非常简单的：</span></p>\n<div class=\"cnblogs_Highlighter sh-gutter\">\n<div><div id=\"highlighter_743271\" class=\"syntaxhighlighter  java\"><div class=\"toolbar\"><span><a href=\"#\" class=\"toolbar_item command_help help\">?</a></span></div><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><td class=\"gutter\"><div class=\"line number1 index0 alt2\">1</div><div class=\"line number2 index1 alt1\">2</div><div class=\"line number3 index2 alt2\">3</div><div class=\"line number4 index3 alt1\">4</div><div class=\"line number5 index4 alt2\">5</div><div class=\"line number6 index5 alt1\">6</div><div class=\"line number7 index6 alt2\">7</div><div class=\"line number8 index7 alt1\">8</div><div class=\"line number9 index8 alt2\">9</div><div class=\"line number10 index9 alt1\">10</div><div class=\"line number11 index10 alt2\">11</div><div class=\"line number12 index11 alt1\">12</div><div class=\"line number13 index12 alt2\">13</div><div class=\"line number14 index13 alt1\">14</div><div class=\"line number15 index14 alt2\">15</div><div class=\"line number16 index15 alt1\">16</div><div class=\"line number17 index16 alt2\">17</div><div class=\"line number18 index17 alt1\">18</div><div class=\"line number19 index18 alt2\">19</div><div class=\"line number20 index19 alt1\">20</div><div class=\"line number21 index20 alt2\">21</div><div class=\"line number22 index21 alt1\">22</div></td><td class=\"code\"><div class=\"container\"><div class=\"line number1 index0 alt2\"><code class=\"java keyword\">protected</code> <code class=\"java keyword\">synchronized</code> <code class=\"java plain\">Class&lt;?&gt; loadClass(String name,</code><code class=\"java keyword\">boolean</code> <code class=\"java plain\">resolve)</code><code class=\"java keyword\">throws</code> <code class=\"java plain\">ClassNotFoundException{</code></div><div class=\"line number2 index1 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java comments\">//check the class has been loaded or not</code></div><div class=\"line number3 index2 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">Class c = findLoadedClass(name);</code></div><div class=\"line number4 index3 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">if</code><code class=\"java plain\">(c == </code><code class=\"java keyword\">null</code><code class=\"java plain\">){</code></div><div class=\"line number5 index4 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">try</code><code class=\"java plain\">{</code></div><div class=\"line number6 index5 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">if</code><code class=\"java plain\">(parent != </code><code class=\"java keyword\">null</code><code class=\"java plain\">){</code></div><div class=\"line number7 index6 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">c = parent.loadClass(name,</code><code class=\"java keyword\">false</code><code class=\"java plain\">);</code></div><div class=\"line number8 index7 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code><code class=\"java keyword\">else</code><code class=\"java plain\">{</code></div><div class=\"line number9 index8 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">c = findBootstrapClassOrNull(name);</code></div><div class=\"line number10 index9 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number11 index10 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code><code class=\"java keyword\">catch</code><code class=\"java plain\">(ClassNotFoundException e){</code></div><div class=\"line number12 index11 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java comments\">//if throws the exception ,the father can not complete the load</code></div><div class=\"line number13 index12 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number14 index13 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">if</code><code class=\"java plain\">(c == </code><code class=\"java keyword\">null</code><code class=\"java plain\">){</code></div><div class=\"line number15 index14 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">c = findClass(name);</code></div><div class=\"line number16 index15 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number17 index16 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number18 index17 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">if</code><code class=\"java plain\">(resolve){</code></div><div class=\"line number19 index18 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">resolveClass(c);</code></div><div class=\"line number20 index19 alt1\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java plain\">}</code></div><div class=\"line number21 index20 alt2\"><code class=\"java spaces\">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class=\"java keyword\">return</code> <code class=\"java plain\">c;</code></div><div class=\"line number22 index21 alt1\"><code class=\"java plain\">}</code></div></div></td></tr></tbody></table></div></div>\n</div>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;从图中的代码，我们大致可以看出这个委托机制是如何实现的，当一个加载器收到请求后，首先会判断一下当前这个类是否已经被加载过，如果没有被加载的话，开始委托父类加载器了（就是这么懒，哈哈），如果没有父类的话，就默认使用启动类加载器。如果抛异常了，就代表当前类加载器的父类无法加载，满足不了请求，那么此时只能自己亲自出马了！！所以什么事还是自己来做的靠谱啊哈哈。</span></p>\n<p>&nbsp;</p>\n<p><strong><span style=\"font-size: 18pt\">总结</span></strong></p>\n<p><span style=\"font-size: 18px\">&nbsp; &nbsp; &nbsp; &nbsp;当然，这种模型一直都不是强制性的，而是推荐我们这么做的，往年就出现过打破该机制的事件，</span><span style=\"font-size: 18px\">典型的例子就是JNDI服务，他的代码是交给启动类加载器去实现的，但是当JNDI要对资源进行集中化管理时，他需要调用其他公司实现并部署在应用程序的classpath下的JNDI接口，因为这些代码是需要我们开发者自己来实现的，这时启动类加载器是无法识别这些类的，于是乎出现了一种线程上下文加载器，JNDI服务可以调用该加载器去加载所需要的代码，就是通过父类加载器去请求子类加载器来实现的，这已经很明显的违背了双亲委派模型。</span></p>\n</div>"
  }



]

