[
  {
    "category": "javaBasic",
    "qes": "重载overload和重写override的区别",
    "ans": "<div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h1>Java 重写(Override)与重载(Overload)</h1>\n<hr>\n<h2>重写(Override)</h2>\n<p> 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong>\n</p>\n\n<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。\n也就是说子类能够根据需要实现父类的方法。</p>\n<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如：\n父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n</p>\n<p>\n在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Animal 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 执行 Animal 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div>\n<p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">动物可以移动</span><span class=\"pln\">\n</span><span class=\"pun\">狗可以跑和走</span></pre>\n<p>在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。</p><p>\n这是由于在编译阶段，只是检查参数的引用类型。</p><p>\n然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。</p><p>\n因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。</p><p>\n思考以下例子：</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">bark</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以吠叫</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Animal 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 执行 Animal 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">bark</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div><p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">TestDog</span><span class=\"pun\">.</span><span class=\"pln\">java</span><span class=\"pun\">:</span><span class=\"lit\">30</span><span class=\"pun\">:</span><span class=\"pln\"> cannot find symbol\nsymbol  </span><span class=\"pun\">:</span><span class=\"pln\"> method bark</span><span class=\"pun\">()</span><span class=\"pln\">\nlocation</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Animal</span><span class=\"pln\">\n                b</span><span class=\"pun\">.</span><span class=\"pln\">bark</span><span class=\"pun\">();</span><span class=\"pln\">\n                 </span><span class=\"pun\">^</span></pre>\n<p>该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。</p>\n<hr>\n<h2>方法的重写规则</h2>\n<ul>\n\t<li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li>\n\t<li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li>\n\t<li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li>\n\t<li><p>父类的成员方法只能被它的子类重写。</p></li>\n\t<li><p>声明为 final 的方法不能被重写。</p></li>\n\t<li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li>\n\t\n\t<li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li>\n\t<li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li>\n\t<li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li>\n\t<li><p>构造方法不能被重写。</p></li>\n\t<li><p>如果不能继承一个类，则不能重写该类的方法。</p></li>\n</ul>\n<hr><h2>Super 关键字的使用</h2>\n<p>\n当需要在子类中调用父类的被重写方法时，要使用 super 关键字。\n</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-reserved\">super</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 应用super类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div><p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">动物可以移动</span><span class=\"pln\">\n</span><span class=\"pun\">狗可以跑和走</span></pre>\n\n<h2>重载(Overload)</h2>\n<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>\n<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>\n<p>最常用的地方就是构造器的重载。</p>\n<p><strong>重载规则:</strong></p>\n<ul>\n<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>\n<li>被重载的方法可以改变返回类型；</li>\n<li>被重载的方法可以改变访问修饰符；</li>\n<li>被重载的方法可以声明新的或更广的检查异常；</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n<li>无法以返回值类型作为重载函数的区分标准。\n</li>\n</ul>\n<h3>实例</h3>\n<div class=\"example\">\n<h2 class=\"example\">Overloading.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-code\"> </span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test1</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-number\">1</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test2</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">以下两个参数类型顺序不同</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">,</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">s</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">returntest3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">s</span><span class=\"hl-code\">,</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">returntest4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">o</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-number\">1</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-number\">1</span><span class=\"hl-code\">,</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">,</span><span class=\"hl-number\">1</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div>\n<hr><h2>重写与重载之间的区别</h2>\n<table class=\"reference\">\n<tbody>\n<tr>\n<th width=\"72\">\n区别点\n</th>\n<th width=\"80\">\n重载方法  \n</th>\n<th width=\"340\">\n重写方法\n</th>\n</tr>\n<tr>\n<td width=\"72\">\n参数列表\n</td>\n<td width=\"80\">\n必须修改\n</td>\n<td width=\"340\">\n一定不能修改\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n返回类型\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n一定不能修改\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n异常\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n可以减少或删除，一定不能抛出新的或者更广的异常\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n访问\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n一定不能做更严格的限制（可以降低限制）\n</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>总结</h2>\n<p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>\n<ul><li>\n(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li><li>\n(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li><li>\n(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2013/12/overloading-vs-overriding.png\"></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.png\"></p>\n\t\t\t<!-- 其他扩展 -->\n\t\t\t\t\t\t\n\t\t\t</div>\n\t\t\t\n\t\t</div>"
  },
  {
    "category": "javaBasic",
    "qes": "java中接口（interface）和虚基类（abstract class）的区别",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <p>在<a class=\"replace_word\" title=\"Java SE知识库\" href=\"http://lib.csdn.net/base/javase\" target=\"_blank\">Java</a>语言中，abstract class和interface是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p>\n<p>&nbsp;</p>\n<div>\n<table style=\"width: 100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"7%\">\n<p align=\"left\">&nbsp;</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">Abstract class</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">Interface</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">实例化</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">不能</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不能</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">类</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">一种继承关系，一个类只能使用一次继承关系。可以通过继承多个接口实现多重继承</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">一个类可以实现多个interface</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">数据成员</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可有自己的</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">静态的不能被修改即必须是static final，一般不在此定义</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">方法</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可以私有的，非abstract方法，必须实现</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不可有私有的，默认是public，abstract&nbsp;类型</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">变量</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可有私有的，默认是friendly&nbsp;型，其值可以在子类中重新定义，也可以重新赋值</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不可有私有的，默认是public static final&nbsp;型，且必须给其初值，实现类中不能重新定义，不能改变其值。</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">设计理念</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">表示的是“is-a”关系</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">表示的是“like-a”关系</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">实现</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">需要继承，要用extends</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">要用implements</p>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>abstract class和interface在Java语言中都是用来进行抽象类（本文中的抽象类并非从abstract class翻译而来，它表示的是一个抽象体，而abstract class为Java语言中用于定义抽象类的一种方法）定义的，那么什么是抽象类，使用抽象类能为我们带来什么好处呢？</p>\n<p>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</p>\n<p>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现 这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。 然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到 接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>\n<p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数。接口更关注“能实现什么功能”，而不管“怎么实现的”。</p>\n<p><strong>1.相同点</strong><br>&nbsp; A. 两者都是抽象类，都不能实例化。<br>&nbsp; B. interface实现类及abstrct class的子类都必须要实现已经声明的抽象方法。</p>\n<p><strong>2. 不同点</strong><br>&nbsp; A. interface需要实现，要用implements，而abstract class需要继承，要用extends。<br>&nbsp; B. 一个类可以实现多个interface，但一个类只能继承一个abstract class。<br>&nbsp; C. interface强调特定功能的实现，而abstract class强调所属关系。&nbsp;<br>&nbsp; D. 尽管interface实现类及abstrct class的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstract class的子类可以有选择地实现。<br>&nbsp;&nbsp;这个选择有两点含义：<br>&nbsp;&nbsp;&nbsp; 一是Abastract class中并非所有的方法都是抽象的，只有那些冠有abstract的方法才是抽象的，子类必须实现。那些没有abstract的方法，在Abstrct class中必须定义方法体。<br>&nbsp;&nbsp;&nbsp; 二是abstract class的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以通过再次声明其方法为抽象的方式，无需实现，留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。<br>&nbsp; E. abstract class是interface与Class的中介。<br>&nbsp; interface是完全抽象的，只能声明方法，而且只能声明pulic的方法，不能声明private及protected的方法，不能定义方法体，也 不能声明实例变量。然而，interface却可以声明常量变量，并且在JDK中不难找出这种例子。但将常量变量放在interface中违背了其作为接 口的作用而存在的宗旨，也混淆了interface与类的不同价值。如果的确需要，可以将其放在相应的abstract class或Class中。<br>&nbsp; abstract class在interface及Class中起到了承上启下的作用。一方面，abstract class是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己 的实例变量，以供子类通过继承来使用。</p>\n<p><strong>3. interface的应用场合</strong><br>&nbsp; A. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。<br>&nbsp; B. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。<br>&nbsp; C. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。<br>&nbsp; D. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。</p>\n<p><strong>4. abstract class的应用场合</strong><br>&nbsp; 一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：<br>&nbsp; A. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。<br>&nbsp; B. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。<br>&nbsp; C. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能。</p>\n<p>&nbsp;</p>\n<p>&nbsp; 注： 本文原作网址：http://blog.csdn.net/b271737818/article/details/3950245&nbsp;</p>\n<p>&nbsp; 原作者：<a class=\"user_name\" href=\"http://my.csdn.net/b271737818\" target=\"_blank\">moolf</a>&nbsp;&nbsp;</p>\n</div>"
  },
  {
    "category": "javaBasic",
    "qes": "Java 内部类详解",
    "ans": "<div class=\"article-body note-body\">\n\t\t\t\t<div class=\"article-intro\">\n\t\t\t\t\t<h2>一.内部类基础</h2>\n<p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p>\n\n<h3>1.成员内部类</h3>\n\n<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"drawshape\"</span><span class=\"pun\">);</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> count </span><span class=\"pun\">=</span><span class=\"lit\">1</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">radius</span><span class=\"pun\">);</span><span class=\"pln\">  </span><span class=\"com\">//外部类的private成员</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">count</span><span class=\"pun\">);</span><span class=\"pln\">   </span><span class=\"com\">//外部类的静态成员</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">外部类.</span><span class=\"kwd\">this</span><span class=\"pun\">.成员变量</span><span class=\"pln\">\n</span><span class=\"pun\">外部类.</span><span class=\"kwd\">this</span><span class=\"pun\">.成员方法</span></pre><p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n        getDrawInstance</span><span class=\"pun\">().</span><span class=\"pln\">drawSahpe</span><span class=\"pun\">();</span><span class=\"pln\">   </span><span class=\"com\">//必须先创建成员内部类的对象，再进行访问</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> getDrawInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">radius</span><span class=\"pun\">);</span><span class=\"pln\">  </span><span class=\"com\">//外部类的private成员</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">//第一种方式：</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pln\"> outter </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> outter</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">  </span><span class=\"com\">//必须通过Outter对象来创建</span><span class=\"pln\">\n         \n        </span><span class=\"com\">//第二种方式：</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner1 </span><span class=\"pun\">=</span><span class=\"pln\"> outter</span><span class=\"pun\">.</span><span class=\"pln\">getInnerInstance</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> getInnerInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">if</span><span class=\"pun\">(</span><span class=\"pln\">inner </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\">\n            inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> inner</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n      \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>\n<h3>2.局部内部类</h3>\n<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Man</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Man</span><span class=\"pun\">(){</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pln\"> getWoman</span><span class=\"pun\">(){</span><span class=\"pln\">\n        </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Woman</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">{</span><span class=\"pln\">   </span><span class=\"com\">//局部内部类</span><span class=\"pln\">\n            </span><span class=\"kwd\">int</span><span class=\"pln\"> age </span><span class=\"pun\">=</span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Woman</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>　<p><strong>注意</strong>: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p><h3>3.匿名内部类</h3>\n\n<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段 Android 事件监听代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">scan_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">});</span><span class=\"pln\">\n \nhistory_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n     \n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">});</span></pre><p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> setListener</span><span class=\"pun\">()</span><span class=\"pln\">\n</span><span class=\"pun\">{</span><span class=\"pln\">\n    scan_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Listener1</span><span class=\"pun\">());</span><span class=\"pln\">       \n    history_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Listener2</span><span class=\"pun\">());</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Listener1</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">View</span><span class=\"pun\">.</span><span class=\"typ\">OnClickListener</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n             \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Listener2</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">View</span><span class=\"pun\">.</span><span class=\"typ\">OnClickListener</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n             \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和 static 修饰符的。</p>\n\n<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>\n<h3>4.静态内部类</h3>\n<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p><img src=\"/wp-content/uploads/2018/04/021558444183591.jpg\"></p><hr>\n<h2>二.深入理解内部类</h2>\n<p><strong>1.为什么成员内部类可以无条件访问外部类的成员？</strong></p>\n\n<p>在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是 Outter.java 的代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> getInnerInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">if</span><span class=\"pun\">(</span><span class=\"pln\">inner </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\">\n            inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> inner</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n      \n    </span><span class=\"kwd\">protected</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>编译之后，出现了两个字节码文件：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021630063402064.jpg\"></p>\n<p>反编译 Outter$Inner.class 文件得到下面信息：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">E</span><span class=\"pun\">:</span><span class=\"pln\">\\Workspace\\Test\\b</span><span class=\"kwd\">in</span><span class=\"pln\">\\com\\cxh\\test2</span><span class=\"pun\">&gt;</span><span class=\"pln\">javap </span><span class=\"pun\">-</span><span class=\"pln\">v </span><span class=\"typ\">Outter$Inner</span><span class=\"pln\">\n</span><span class=\"typ\">Compiled</span><span class=\"pln\"> </span><span class=\"kwd\">from</span><span class=\"pln\"> </span><span class=\"str\">\"Outter.java\"</span><span class=\"pln\">\n</span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter$Inner</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> java</span><span class=\"pun\">.</span><span class=\"pln\">lang</span><span class=\"pun\">.</span><span class=\"typ\">Object</span><span class=\"pln\">\n  </span><span class=\"typ\">SourceFile</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"str\">\"Outter.java\"</span><span class=\"pln\">\n  </span><span class=\"typ\">InnerClass</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"com\">#24= #1 of #22; //Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes</span><span class=\"pln\">\nt2</span><span class=\"pun\">/</span><span class=\"typ\">Outter</span><span class=\"pln\">\n  minor version</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pln\">\n  major version</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">50</span><span class=\"pln\">\n  </span><span class=\"typ\">Constant</span><span class=\"pln\"> pool</span><span class=\"pun\">:</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#1 = class        #2;     //  com/cxh/test2/Outter$Inner</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#2 = Asciz        com/cxh/test2/Outter$Inner;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#3 = class        #4;     //  java/lang/Object</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#4 = Asciz        java/lang/Object;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#5 = Asciz        this$0;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#6 = Asciz        Lcom/cxh/test2/Outter;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#7 = Asciz        &lt;init&gt;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#8 = Asciz        (Lcom/cxh/test2/Outter;)V;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#9 = Asciz        Code;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#10 = Field       #1.#11; //  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t</span><span class=\"pln\">\nest2</span><span class=\"pun\">/</span><span class=\"typ\">Outter</span><span class=\"pun\">;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#11 = NameAndType #5:#6;//  this$0:Lcom/cxh/test2/Outter;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#12 = Method      #3.#13; //  java/lang/Object.\"&lt;init&gt;\":()V</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#13 = NameAndType #7:#14;//  \"&lt;init&gt;\":()V</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#14 = Asciz       ()V;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#15 = Asciz       LineNumberTable;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#16 = Asciz       LocalVariableTable;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#17 = Asciz       this;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#18 = Asciz       Lcom/cxh/test2/Outter$Inner;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#19 = Asciz       SourceFile;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#20 = Asciz       Outter.java;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#21 = Asciz       InnerClasses;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#22 = class       #23;    //  com/cxh/test2/Outter</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#23 = Asciz       com/cxh/test2/Outter;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#24 = Asciz       Inner;</span><span class=\"pln\">\n \n</span><span class=\"pun\">{</span><span class=\"pln\">\n</span><span class=\"kwd\">final</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pln\">$0</span><span class=\"pun\">;</span><span class=\"pln\">\n \n</span><span class=\"kwd\">public</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter$Inner</span><span class=\"pun\">(</span><span class=\"pln\">com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pun\">);</span><span class=\"pln\">\n  </span><span class=\"typ\">Code</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"typ\">Stack</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pun\">,</span><span class=\"pln\"> </span><span class=\"typ\">Locals</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pun\">,</span><span class=\"pln\"> </span><span class=\"typ\">Args_size</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pln\">\n   </span><span class=\"lit\">0</span><span class=\"pun\">:</span><span class=\"pln\">   aload_0\n   </span><span class=\"lit\">1</span><span class=\"pun\">:</span><span class=\"pln\">   aload_1\n   </span><span class=\"lit\">2</span><span class=\"pun\">:</span><span class=\"pln\">   putfield        </span><span class=\"com\">#10; //Field this$0:Lcom/cxh/test2/Outter;</span><span class=\"pln\">\n   </span><span class=\"lit\">5</span><span class=\"pun\">:</span><span class=\"pln\">   aload_0\n   </span><span class=\"lit\">6</span><span class=\"pun\">:</span><span class=\"pln\">   invokespecial   </span><span class=\"com\">#12; //Method java/lang/Object.\"&lt;init&gt;\":()V</span><span class=\"pln\">\n   </span><span class=\"lit\">9</span><span class=\"pun\">:</span><span class=\"pln\">   </span><span class=\"kwd\">return</span><span class=\"pln\">\n  </span><span class=\"typ\">LineNumberTable</span><span class=\"pun\">:</span><span class=\"pln\">\n   line </span><span class=\"lit\">16</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pln\">\n   line </span><span class=\"lit\">18</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">9</span><span class=\"pln\">\n \n  </span><span class=\"typ\">LocalVariableTable</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"typ\">Start</span><span class=\"pln\">  </span><span class=\"typ\">Length</span><span class=\"pln\">  </span><span class=\"typ\">Slot</span><span class=\"pln\">  </span><span class=\"typ\">Name</span><span class=\"pln\">   </span><span class=\"typ\">Signature</span><span class=\"pln\">\n   </span><span class=\"lit\">0</span><span class=\"pln\">      </span><span class=\"lit\">10</span><span class=\"pln\">      </span><span class=\"lit\">0</span><span class=\"pln\">    </span><span class=\"kwd\">this</span><span class=\"pln\">       </span><span class=\"typ\">Lcom</span><span class=\"pun\">/</span><span class=\"pln\">cxh</span><span class=\"pun\">/</span><span class=\"pln\">test2</span><span class=\"pun\">/</span><span class=\"typ\">Outter$Inner</span><span class=\"pun\">;</span><span class=\"pln\">\n \n \n</span><span class=\"pun\">}</span></pre><p>第11行到35行是常量池的内容，下面逐一第38行的内容：</p><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">final</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pln\">$0</span><span class=\"pun\">;</span></pre>\n<p>这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：</p><p>public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</p>\n\n<p>从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的 Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对 Outter this&amp;0 引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>\n\n<p><strong>2.为什么局部内部类和匿名内部类只能访问局部final变量？</strong></p>\n\n<p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> test</span><span class=\"pun\">(</span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> b</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">10</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Thread</span><span class=\"pun\">(){</span><span class=\"pln\">\n            </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> run</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">b</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"pun\">};</span><span class=\"pln\">\n        </span><span class=\"pun\">}.</span><span class=\"pln\">start</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>　<p>这段代码会被编译成两个class文件：Test.class和Test1.class。<strong>默认情况下，编译器会为匿名内部类和局部内部类起名为<span class=\"marked\">Outterx.class</span>（x为正整数）</strong>。</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021900556994393.jpg\"></p>\n<p>根据上图可知，test 方法中的匿名内部类的名字被起为 Test$1。</p>\n\n<p>上段代码中，如果把变量 a 和 b 前面的任一个 final 去掉，这段代码都编译不过。我们先考虑这样一个问题：</p>\n\n<p>当 test 方法执行完毕之后，变量a的生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束，那么在 Thread 的 run 方法中继续访问变量 a 就变成不可能了，但是又要实现这样的效果，怎么办呢？Java 采用了复制的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021939271846598.jpg\"></p>\n<p>我们看到在 run 方法中有一条指令：</p><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">bipush </span><span class=\"lit\">10</span></pre><p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p><p>下面再看一个例子：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> test</span><span class=\"pun\">(</span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Thread</span><span class=\"pun\">(){</span><span class=\"pln\">\n            </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> run</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"pun\">};</span><span class=\"pln\">\n        </span><span class=\"pun\">}.</span><span class=\"pln\">start</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>反编译得到：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021950384493440.jpg\"></p>\n<p>我们看到匿名内部类 Test$1 的构造器含有两个参数，一个是指向外部类对象的引用，一个是 int 型变量，很显然，这里是将变量 test 方法中的形参 a 以参数的形式传进来对匿名内部类中的拷贝（变量 a 的拷贝）进行赋值初始化。</p>\n\n<p>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p>\n\n<p>从上面可以看出，在 run 方法中访问的变量 a 根本就不是 test 方法中的局部变量 a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在 run 方法中访问的变量 a 和 test 方法中的变量 a 不是同一个变量，当在 run 方法中改变变量 a 的值的话，会出现什么情况？</p>\n\n<p>对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java 编译器就限定必须将变量 a 限制为 final 变量，不允许对变量 a 进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>\n\n<p>到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用 final 进行限定了。</p>\n<p><strong>3.静态内部类有特殊的地方吗？</strong></p><p>从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译 class 文件看一下就知道了，是没有 <span class=\"marked\">Outter this&amp;0</span> 引用的。</p>\n<hr>\n<h2>三.内部类的使用场景和好处</h2><p>为什么在 Java 中需要内部类？总结一下主要有以下四点：</p>\n<ul><li>\n1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整。\n</li><li>2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。\n</li><li>3.方便编写事件驱动程序。\n</li><li>4.方便编写线程代码。</li></ul><p>个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p>\n<p><strong>四.常见的与内部类相关的笔试面试题</strong></p>\n <p>1.根据注释填写(1)，(2)，(3)处的代码</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">){</span><span class=\"pln\">\n           </span><span class=\"com\">// 初始化Bean1</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean1</span><span class=\"pun\">.</span><span class=\"pln\">I</span><span class=\"pun\">++;</span><span class=\"pln\">\n           </span><span class=\"com\">// 初始化Bean2</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">2</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean2</span><span class=\"pun\">.</span><span class=\"pln\">J</span><span class=\"pun\">++;</span><span class=\"pln\">\n           </span><span class=\"com\">//初始化Bean3</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">3</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean3</span><span class=\"pun\">.</span><span class=\"pln\">k</span><span class=\"pun\">++;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean1</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> I </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n \n    </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean2</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> J </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean3</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> k </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>\n\n<p>创建静态内部类对象的一般形式为：  <span class=\"marked\">外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</span></p>\n\n<p>创建成员内部类对象的一般形式为：  <span class=\"marked\">外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</span></p>\n<p>因此，（1），（2），（3）处的代码分别为：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Test</span><span class=\"pln\"> test </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">();</span><span class=\"pln\">    \n</span><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean1</span><span class=\"pln\"> bean1 </span><span class=\"pun\">=</span><span class=\"pln\"> test</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean1</span><span class=\"pun\">();</span></pre>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean2</span><span class=\"pln\"> b2 </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean2</span><span class=\"pun\">();</span></pre>  \n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Bean</span><span class=\"pln\"> bean </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean</span><span class=\"pun\">();</span><span class=\"pln\">     \n\n</span><span class=\"typ\">Bean</span><span class=\"pun\">.</span><span class=\"typ\">Bean3</span><span class=\"pln\"> bean3 </span><span class=\"pun\">=</span><span class=\"pln\">  bean</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean3</span><span class=\"pun\">();</span></pre>\n<p>2.下面这段代码的输出结果是什么？</p> \n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pln\"> outter </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">();</span><span class=\"pln\">\n        outter</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">().</span><span class=\"kwd\">print</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\">\n</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">1</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> </span><span class=\"kwd\">print</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"局部变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"内部类变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"外部类变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"lit\">3</span><span class=\"pln\">\n</span><span class=\"lit\">2</span><span class=\"pln\">\n</span><span class=\"lit\">1</span></pre><p>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>\n\n<ul><li>1）成员内部类的引用方式必须为 Outter.Inner \n</li><li>2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》    </li></ul>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">InheritInner</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n      \n    </span><span class=\"com\">// InheritInner() 是不能通过编译的，一定要加上形参</span><span class=\"pln\">\n    </span><span class=\"typ\">InheritInner</span><span class=\"pun\">(</span><span class=\"typ\">WithInner</span><span class=\"pln\"> wi</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        wi</span><span class=\"pun\">.</span><span class=\"kwd\">super</span><span class=\"pun\">();</span><span class=\"pln\"> </span><span class=\"com\">//必须有这句调用</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n  \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">WithInner</span><span class=\"pln\"> wi </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"typ\">InheritInner</span><span class=\"pln\"> obj </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">InheritInner</span><span class=\"pun\">(</span><span class=\"pln\">wi</span><span class=\"pun\">);</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n\n\n<blockquote><p>原文出处：https://www.cnblogs.com/dolphin0520/p/3811445.html</p></blockquote>\n\n\t\t\t\t</div>\n\t\t\t</div>"
  },
  {
    "category": "javaBasic",
    "qes": "内部类和静态内部类的区别",
    "ans": "<div class=\"RichText ztext Post-RichText\"><p><b>内部类和静态内部类的区别</b></p><p><b>内部类：</b></p><p>1、内部类中的变量和方法不能声明为静态的。<br>2、内部类实例化：B是A的内部类，实例化B：A.B b = new A().new B()。<br>3、内部类可以引用外部类的静态或者非静态属性及方法。</p><p><b>静态内部类：</b></p><p>1、静态内部类属性和方法可以声明为静态的或者非静态的。<br>2、实例化静态内部类：B是A的静态内部类，A.B b = new A.B()。<br>3、静态内部类只能引用外部类的静态的属性及方法。</p><blockquote>inner classes——内部类<br>static nested classes——静态嵌套类</blockquote><p>其实人家不叫静态内部类，只是叫习惯了，从字面就很容易理解了。</p><p>内部类依靠外部类的存在为前提，而静态嵌套类则可以完全独立，明白了这点就很好理解了。</p><p><b>非静态内部类中的变量和方法不能声明为静态的原因</b></p><p>静态类型的属性和方法，在类加载的时候就会存在于内存中。使用某个类的静态属性和方法，那么这个类必须要加载到虚拟机中。但是非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。</p><p>我们设想一个场景：在外部类并没有实例化，内部类还没有加载的时候如果调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内部类的静态成员，就会产生冲突。所以非静态内部类不能有静态成员变量或静态方法。</p><p><b>String，StringBuilder，StringBuffer的区别</b></p><ul><li>String 字符串常量</li><li>StringBuffer 字符串变量（线程安全）</li><li>StringBuilder 字符串变量（非线程安全）</li></ul><p>性能上通常StringBuilder &gt; StringBuffer &gt; String。</p><p>String是不可变对象，每次对String类型进行改变的时候都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以性能最差，对于要经常改变内容的字符串不用String。</p><p>StringBuffer是字符串变量，对它操作时，并不会生成新的对象，而是直接对该对象进行更改，所以性能较好。</p><p>StringBuilder和StringBuffer一样，是字符串变量，但是他不带有synchronized关键字，不保证线程安全，所以性能最好。在单线程的情况下，建议使用StringBuilder。</p><p><b>总体来说：</b></p><ul><li>String：适用于少量的字符串操作的情况。</li><li>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况。</li><li>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。</li></ul><p><b>来一些问题：</b></p><p>下面这段代码的输出结果是什么？</p><div class=\"highlight\"><pre><code class=\"language-text\">String a = \"helloworld\";\nString b = \"hello\" + \"world\";\nSystem.out.println((a == b));\njava中高端架构师交流群：603619042</code></pre></div><p><b>输出结果为：True。</b></p><p>原因是String对字符串的直接相加，会在编译期进行优化。即hello+world在编译时期，被优化为helloworld，所以在运行时期，他们指向了同一个对象。我们也可以推理，对于直接字符串的相加，String不一定比其余两个慢。</p><p>下面这段代码的输出结果是什么？</p><div class=\"highlight\"><pre><code class=\"language-text\">String a = \"helloworld\";\nString b = \"hello\";      \nString c = b + \"world\";      \nSystem.out.println((a == c));</code></pre></div><p><b>输出结果为：False。</b></p><p>原因是c并非两个字符串直接相加，包含了一个字符串引用，这时不会做编译期的优化。所以a、c最终生成了两个对象，这时他的效率低。</p><p>集合和数组之间的相互转换</p><p><b>数组变集合：</b></p><p>通常我们会回答的是以下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;String&gt; list = Arrays.asList(array);</code></pre></div><p>但这并不是很好的答案，此时组合成的list是Arrays里面的一个静态内部类，该类并未实现add、remove方法，因此在使用时存在问题。</p><p><b>可以这样：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">String array[]= {\"hello\",\"world\",\"java\",\"zhiyin\"};\nList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array));</code></pre></div><p>集合变数组：</p><div class=\"highlight\"><pre><code class=\"language-text\">String[] array=list.toArray(new String[list.size()]);</code></pre></div><p><b>面向对象的特征有哪些方面?</b></p><p><b>抽象</b>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p><b>继承</b>：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类；得到继承信息的类被称为子类。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p><p><b>封装</b>：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</p><p><b>多态性</b>：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载实现的是编译时的多态性，而方法重写实现的是运行时的多态性。</p><p><b>概括的解释下线程的几种状态</b></p><p>1.就绪(Runnable):线程准备运行，不一定立马就能开始执行。</p><p>2.运行中(Running)：进程正在执行线程的代码。</p><p>3.等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。</p><p>4.睡眠中(Sleeping)：线程被强制睡眠。</p><p>5.I/O阻塞(Blocked on I/O)：等待I/O操作完成。</p><p>6.同步阻塞(Blocked on Synchronization)：等待获取锁。</p><p>7.死亡(Dead)：线程完成了执行。</p><p><b>Java集合类里面基本的接口有哪些</b></p><p>1.Collection：代表一组对象，每一个对象都是它的子元素。</p><p>2.Set：不包含重复元素的Collection。</p><p>3.List：有顺序的collection，并且可以包含重复元素。</p><p>4.Map：可以把键(key)映射到值(value)的对象，键不能重复。</p><p><b>Iterator和ListIterator的区别</b></p><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向遍历也可以后向遍历。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加、替换元素，获取前一个和后一个元素的索引等等。</li></ul><p><b>Enumeration和Iterator的区别</b></p><ul><li>java中的集合类都提供了返回Iterator的方法，就是迭代器，它和Enumeration（枚举）的主要区别其实就是Iterator可以删除元素，但是Enumration却不能。</li><li>使用Iterator来遍历集合时，应使用Iterator的remove()方法来删除集合中的元素，使用集合的remove()方法将抛出ConcurrentModificationException异常。</li><li>Enumeration接口的功能和Iterator接口的功能是重复的。此外，Iterator 接口添加了一个可选的移除操作，并使用较短的方法名。新的实现应该优先考虑使用Iterator接口而不是Enumeration接口。</li><li>Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。</li></ul><p><b>介绍一下HTTP的响应结构</b></p><ul><li>请求报文的组成：</li><li>请求方法。</li><li>请求的资源的URI。</li><li>协议版本。</li><li>可选的请求首部字段。</li><li>内容实体。</li></ul><p><b>响应报文的组成：</b></p><ul><li>协议版本。</li><li>状态码。</li><li>用于解释状态码的原因短语。</li><li>可选的响应首部字段。</li><li>实体主体。</li></ul><p>**响应: **</p><ul><li>响应码：回应客户端此次响应是否成功。如：404(找不到请求的资源)，500(服务器内部错误)，200(成功响应)等。</li><li>消息头：服务器与客户端通信的暗码，告诉客户端该怎么执行某些操作。</li><li>响应正文：传递服务器响应给客户端要显示的内容，可以是下载文件或者显示界面。</li></ul><p><b>final、finalize和finally各自的作用</b></p><ul><li>final是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。</li><li>finalize方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。</li><li>finally是一个关键字，与try和catch一起用于异常的处理。finally块一定会被执行，无论在try块中是否有发生异常。</li></ul><p><b>说一下你了解的几种进程间的通信方式</b></p><p>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>高级管道popen：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><p>有名管道named pipe ：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><p>信号sinal： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></div>"
  },
  {
    "category": "javaBasic",
    "qes": "谨用ArrayList中的subList方法",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <h3><a name=\"t0\"></a><a name=\"t0\"></a>0、subList方法api：</h3> \n<p>Parameters:</p> \n<ul><li>fromIndex low endpoint (inclusive) of the subList</li><li>toIndex high endpoint (exclusive) of the subList</li></ul>\n<p>Returns:</p> \n<ul><li>a view of the specified range within this list</li></ul>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a>1、规范一：</h3> \n<p>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs php\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">static</span> <span class=\"hljs-keyword\">void</span> test7() {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList = <span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList);<span class=\"hljs-comment\">//2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tArrayList&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList1 = (ArrayList&lt;<span class=\"hljs-keyword\">Integer</span>&gt;)<span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-comment\">//java.lang.ClassCastException: java.util.ArrayList$SubList cannot be cast to java.util.ArrayList</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList1);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>分析：</p> \n<ol><li>SubList 继承 AbstractList ，所以具有List接口的所有方法。</li><li><span style=\"color:#f33b45;\">SubList 是ArrayList 的一个内部类。SubList并没有重新创建一个List,而是直接引用原有的List，只不过对原来List做截取而已</span>。</li><li>ArrayList 也是继承AbstractList，但是 SubList 和 ArrayList 没有继承关系，所以不能强转换。</li></ol>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a>2、规范二：</h3> \n<p>在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs php\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">static</span> <span class=\"hljs-keyword\">void</span> test8() {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList = <span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">4</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-comment\">//java.util.ConcurrentModificationException</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>&nbsp;分析：</p> \n<p>1）调用subList方法返回的集合保存了ArrayList的modCount</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143247490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<p>2）当对原list进行add/remove时，导致modCount++；</p> \n<p>3）访问子集合时，加了checkForComodification();校验</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143314312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<h3><a name=\"t3\"></a><a name=\"t3\"></a>3、对subList返回的子集合进行add/remove操作会如何？</h3> \n<p>我们来看一段代码</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs csharp\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test9</span>(<span class=\"hljs-params\"></span>)</span> {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tList&lt;Integer&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tList&lt;Integer&gt; subList = list.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"------------------------\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tsubList.<span class=\"hljs-keyword\">remove</span>(<span class=\"hljs-number\">0</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"------------------------\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tsubList.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">4</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,3,4</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"17\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//3,4</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"18\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>运行正常，分析：</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143158727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<p>subList返回的集合在调用add/remove方法时，会将modCount进行更新。注：更新操作只更新原集合，因为subList不会重新创建新集合。</p> \n<p><strong>总结：</strong></p> \n<p>1、subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p> \n<p>2、在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p> \n<p>&nbsp;</p> \n<p></p> \n<p></p> \n<p></p> \n<p></p> \n<p></p>\n                </div><div><div></div></div>\n        </div>"
  },
  {
    "category": "javaBasic",
    "qes": "详解Map集合体系及方法entrySet、keySet、values",
    "ans": "<div class=\"postBody\">\n                \n<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <h3>简单回顾Map集合：</h3>\n<p>&nbsp;</p>\n<p>Map表示映射关系，以键值对的方式来保存数据。key和value一一对应。key是唯一的，不可重复，而value是可重复的，可以被多个key关联。虽然Map是放入两个数据，但是却以key作为操作对象，value只是作为key的关联值。</p>\n<p>通过查看，会发现Set与Map的实现类很相似，Set实现类的底层操作就是用Map来实现的，Set集的特性就来自于Map。唯一不同的就是Map表示一种映射关系，一次存储2个数据，Set只能存储单一数据。</p>\n<h3>Map体系中的主要类：</h3>\n<ul>\n<li>HashMap：Map的典型实现，元素是无序且不可重复，这里的元素指的是key。</li>\n<li>LinkedHashMap：以插入的次序作为排序状态，其他的和HashMap一致。</li>\n<li>TreeMap：元素处于排序状态，可以使用自然排序也可以使用自定义排序，但key的类型必须一致，不然无法进行比较。</li>\n<li>Properties：Key-Value都是String类型，用于加载属性文件。后续会说到。</li>\n</ul>\n<div>\n<h3>Map的重要方法和特点：</h3>\n<div>常用方法就不概述，关于Map中方法的使用细节，例如replace()和remove()方法，如果返回值是Object，则会返回以前的value，返回值boolean，代表是否执行成功。重点需要了解entrySet()、keySet()&nbsp;和values()的使用。</div>\n<div>\n<ul>\n<li>entrySet()___返回一个包含所有映射关系的Set集合，该Set集合的类型为Map.Entry，一般用于迭代键值对。Map.Entry是一个内部接口。</li>\n<li>keySet()__..._返回该映射中所有key组成的Set集合。通过key获取键值对。</li>\n<li>values()___._返回该映射中所有value值。</li>\n<li>这三个方法主要用于遍历键值对或直接获取value值，非常方便。但使用返回对象的方法时，会引发错误。代码示例和解析在最下面。</li>\n</ul>\n</div>\n</div>\n<h3>HashMap的代码示例</h3>\n<div>\n<pre name=\"code\" class=\"java\">\t\tHashMap hm = new HashMap();\n\t\t//放入键值对\n\t\thm.put(\"cn\", \"中国\");\n\t\thm.put(1, 100);\t\t\n\t\thm.put(\"us\", \"美国\");\n\t\thm.put(\"Ja\", \"日本\");\n\t\thm.put(\"时间\", new Date());\n\t\thm.put(1, 200);//用同一个key关联别的value\n\t\tSystem.out.println(hm);\t//等同于hm.toString()\n\t\t\n\t\tSystem.out.println(\"----根据key获取关联的值------\");\n\t\tSystem.out.println(hm.get(\"Ja\"));\n\t\tSystem.out.println(hm.get(1));\n\t\t\t\n\t\tSystem.out.println(\"----替换指定的键值对-------\");\n\t\tSystem.out.println(hm.replace(1, \"100\"));//返回被替换的value\n\t\tSystem.out.println(hm.replace(\"us\", \"美国\",\"FuckYou\"));//返回boolean，表示是否替换成功\n\t\t\n\t\tSystem.out.println(\"----删除指定键值对----\");\n\t\tSystem.out.println(hm.remove(\"Ja\"));//返回被删除的value\n\t\tSystem.out.println(hm.remove(\"Ja\",\"日本\"));//返回是否成功删除</pre>\n<div>典型的Map实现，查看打印结果：元素是无序且不可重复的。在代码中放入两个相同的键值对，key只能有一个，如果value也不同，后来添加的value会覆盖原来的value。</div>\n<div>&nbsp;</div>\n<h3>LinkedHashMap简单示例</h3>\n</div>\n<div>\n<pre name=\"code\" class=\"java\">\t\tLinkedHashMap lhm = new LinkedHashMap();\n\t\tlhm.put(1,\"B\");\n\t\tlhm.put(4,\"A\");\n\t\tlhm.put(3,\"C\");\n\t\tlhm.put(2,\"D\");\n\t\tSystem.out.println(lhm);\n\t\t//输出：{1=B, 4=A, 3=C, 2=D}</pre>\nLinkedHashMap就是以插入次序作为排序状态，别的和HashMap一致。非常类似于HashSet与LinkedHashSet的关系。</div>\n<div>&nbsp;</div>\n<h2>entrySet() 和 keySet()&nbsp;和 values()的代码示例</h2>\n<h4>以TreeMap为例，演示entrySet()</h4>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\t\n\t\t//使用迭代器来遍历元素\n\t\tSet entrys = tm.entrySet();\n\t\tIterator it = entrys.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry)it.next();//转换成Map.Entry类型\n\t\t\tSystem.out.println(entry.getKey() +\"-\" + entry.getValue());\t\t\t\n\t\t}</pre>\n</div>\n<h4>以TreeMap为例，演示keySet()</h4>\n<div>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\t\n\t\tSet k = tm.keySet();\n\t\tIterator it = k.iterator();\n\t\t//mode 1\n\t\twhile(it.hasNext()) {\n\t\t\tObject key = it.next();//获取key\n\t\t\tSystem.out.println(key + \"-&gt;\" + tm.get(key));\n\t\t}\n\t\t//mode 2\n\t\tfor(Object key : k) {\n\t\t\tSystem.out.println(key +\"-&gt;\" + tm.get(key));\n\t\t}</pre>\n</div>\n<div>\n<h4>以TreeMap为例，演示values()</h4>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\tCollection value = tm.values();\t\n\t\tfor(Object v : value) {\n\t\t\tSystem.out.println(v);\n\t\t}</pre>\n<div>&nbsp;</div>\n<h3>entrySet() keySet() 和 values()返回对象中的操作方法</h3>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\tSet entry = tm.entrySet();\t\n\t\tSet key = tm.keySet();\n\t\tCollection value = tm.values();\t\t\n\n//\t\tentry.add(\"A\");引发不支持的操作异常\n\t\tSystem.out.println(entry.remove(1));//false\n\t\tSystem.out.println(entry.contains(3));//false\n\t\t\n\t\tSystem.out.println(key.remove(1));//true\n\t\tSystem.out.println(key.contains(3));//true\n\t\t\n\t\tSystem.out.println(value.remove(\"壹\"));//false</pre>\n上面代码中，可以看出无论是返回Set对象还是Collection，添加元素都会引发不支持的操作异常。这是因为返回的集合对象本质上依然是对键值对操作。它们的不同之处：</div>\n<div>entrySet()中有key和value，所以直接加入元素或者删除元素的方法都是无效的。keySet()中有key，可以对key进行操作，所以能使用remove()和equals()，所以返回true。</div>\nvalues()中只有value值，没有key，value值是没什么用的，所以values()方法也仅仅是获取所有value值方便。</div>\n<div>相同之处：<br>方法中如果没有参数，不涉及到对键值对进行的操作，都是可以使用的。例如Iterator()、clear()、size()和isEmpty()等。</div>\n\n</div>\n<div>&nbsp;</div>\n<h3>entrySet() 和 keySet()&nbsp;和 values()的使用总结：</h3>\n<div>\n<ul>\n<li>一般只使用它们的迭代器，用于获取所有键值对。</li>\n<li>除了迭代器，对元素进行操作的方法不建议使用，容易出错。</li>\n<li>如果要高效遍历key-value，建议使用entrySet()，keySet()也可以做到，但需要通过key来获取value，多增加了一步。</li>\n<li>获取所有key就使用keySet()，获取所有value就使用values()</li>\n\n</ul>\n\n</div>\n\n</div>\n</div>\n<div id=\"MySignature\"></div>\n<div class=\"clear\"></div>\n<div id=\"blog_post_info_block\"><div id=\"BlogPostCategory\">\n    分类: \n            <a href=\"https://www.cnblogs.com/fwnboke/category/977503.html\" target=\"_blank\">Java基础总结</a></div>\n\n\n    <div id=\"blog_post_info\">\n<div id=\"green_channel\">\n        <a href=\"javascript:void(0);\" id=\"green_channel_digg\" onclick=\"DiggIt(8529656,cb_blogId,1);green_channel_success(this,'谢谢推荐！');\">好文要顶</a>\n        <a id=\"green_channel_follow\" onclick=\"follow('5c46ef51-7228-e611-9fc1-ac853d9f53cc');\" href=\"javascript:void(0);\">关注我</a>\n    <a id=\"green_channel_favorite\" onclick=\"AddToWz(cb_entryId);return false;\" href=\"javascript:void(0);\">收藏该文</a>\n    <a id=\"green_channel_weibo\" href=\"javascript:void(0);\" title=\"分享至新浪微博\" onclick=\"ShareToTsina()\"><img src=\"https://common.cnblogs.com/images/icon_weibo_24.png\" alt=\"\"></a>\n    <a id=\"green_channel_wechat\" href=\"javascript:void(0);\" title=\"分享至微信\" onclick=\"shareOnWechat()\"><img src=\"https://common.cnblogs.com/images/wechat.png\" alt=\"\"></a>\n</div>\n<div id=\"author_profile\">\n    <div id=\"author_profile_info\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/fwnboke/\" target=\"_blank\"><img src=\"https://pic.cnblogs.com/face/969690/20170402132941.png\" class=\"author_avatar\" alt=\"\"></a>\n        <div id=\"author_profile_detail\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/fwnboke/\">乘风起</a><br>\n            <a href=\"https://home.cnblogs.com/u/fwnboke/followees/\">关注 - 0</a><br>\n            <a href=\"https://home.cnblogs.com/u/fwnboke/followers/\">粉丝 - 21</a>\n        </div>\n    </div>\n    <div class=\"clear\"></div>\n    <div id=\"author_profile_honor\"></div>\n    <div id=\"author_profile_follow\">\n                <a href=\"javascript:void(0);\" onclick=\"follow('5c46ef51-7228-e611-9fc1-ac853d9f53cc');return false;\">+加关注</a>\n    </div>\n</div>\n<div id=\"div_digg\">\n    <div class=\"diggit\" onclick=\"votePost(8529656,'Digg')\">\n        <span class=\"diggnum\" id=\"digg_count\">1</span>\n    </div>\n    <div class=\"buryit\" onclick=\"votePost(8529656,'Bury')\">\n        <span class=\"burynum\" id=\"bury_count\">0</span>\n    </div>\n    <div class=\"clear\"></div>\n    <div class=\"diggword\" id=\"digg_tips\">\n    </div>\n</div>\n\n<script type=\"text/javascript\">\n    currentDiggType = 0;\n</script></div>\n    <div class=\"clear\"></div>\n    <div id=\"post_next_prev\">\n\n    <a href=\"https://www.cnblogs.com/fwnboke/p/8529647.html\" class=\"p_n_p_prefix\">« </a> 上一篇：    <a href=\"https://www.cnblogs.com/fwnboke/p/8529647.html\" title=\"发布于 2018-03-08 17:19\">Java集合框架体系</a>\n    <br>\n    <a href=\"https://www.cnblogs.com/fwnboke/p/8529670.html\" class=\"p_n_p_prefix\">» </a> 下一篇：    <a href=\"https://www.cnblogs.com/fwnboke/p/8529670.html\" title=\"发布于 2018-03-08 17:23\">泛型的定义、用法与类型通配符的使用方式</a>\n\n</div>\n</div>\n            </div>"
  },
  {
    "category": "javaBasic",
    "qes": "String类为什么是final的。",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body blogpost-body-html\">\n<p><strong>最佳答案：</strong></p>\n<p>主要是为了“效率”&nbsp;和&nbsp;“安全性”&nbsp;的缘故。若&nbsp;String允许被继承,&nbsp;由于它的高度被使用率,&nbsp;可能会降低程序的性能，所以String被定义成final。</p>\n<p><strong>其它答案一：</strong></p>\n<p align=\"left\">String和其他基本类型不同,他是个对象类型.既然是对象类型,如果是在静态方法下是必须调用静态方法或值的,如果是非静态的方法,就必须要实例化.&nbsp;<br>main函数是个static的.所以String要能像其他的基本类型一样直接被调用.这也是为什么在main函数下使用String类型不会报告错误的原因..&nbsp;<br>一下就解释了两个心里的疑问..&nbsp;<br>以前一直觉得奇怪,为什么String是对象类型在main函数下却是不需要实例化的.再次佩服java设计人员想得真周到.</p>\n<p>&nbsp;</p>\n<p><strong>其它答案二：</strong></p>\n<p>当定义String类型的静态字段（也成类字段），可以用静态变量（非final）代替常量（final）加快程序速度。反之，对于原始数据类型，例如int，也成立。&nbsp;<br><br>例如，你可能创建一个如下的String对象：&nbsp;<br><br>private static final String x = \"example\";&nbsp;<br><br>对于这个静态常量（由final关键字标识），你使用常量的每个时候都会创建一个临时的String对象。在字节代码中，编译器去掉”x”，代替它的是字符串“example”,以致每次引用”x”时VM都会进行一次哈希表查询。&nbsp;<br><br>相比之下，度于静态变量(非final关键字)，字符串只创建一次。仅当初始化“x”时，VM才进行哈希表查询。&nbsp;<br><br>还有另一个解释:&nbsp;<br>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了人们覆盖length()方法。&nbsp;<br><br>　　另外，如果指定一个类为final，则该类所有的方法都是final。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>\n<p><strong>示例：</strong></p>\n<p>public class Test {&nbsp;<br>public static void main(String[] args)&nbsp; {&nbsp;<br>//&nbsp;&nbsp;<br>}&nbsp;<br>}&nbsp;<br><br>如果String&nbsp;不是final&nbsp;那么就可以继承&nbsp;<br>public class String2 extends String{&nbsp;<br>&nbsp;&nbsp; // ..&nbsp;<br>&nbsp;&nbsp; // ...&nbsp;<br>}&nbsp;<br><br>那我们的&nbsp;main也就可以写成&nbsp;<br>public class Test {&nbsp;<br>public static void main(String2[] args)&nbsp; { //&nbsp;注意此处&nbsp;<br>//&nbsp;&nbsp;<br>}&nbsp;<br>}</p>\n<p><strong>英文参考：</strong><a href=\"http://forums.sun.com/thread.jspa?threadID=636414\">http://forums.sun.com/thread.jspa?threadID=636414</a></p>\n<p>=============================================================</p>\n<p>另外补充一点：</p>\n<p>引用：<a href=\"http://zhidao.baidu.com/question/94324055.html\">http://zhidao.baidu.com/question/94324055.html</a><br>作用就是 final的类不能被继承，不能让别人继承有什么好处?&nbsp;<br>意义就在于，安全性，如此这般：&nbsp;<br>Java自出生那天起就是“为人民服务”，这也就是为什么Java做不了病毒，也不一定非得是病毒，反正总之就是为了安全，人家Java的开发者目的就是不想让Java干这类危险的事儿，Java并不是操作系统本地语言，换句话说Java必须借助操作系统本身的力量才能做事，JDK中提供的好多核心类比如String，这类的类的内部好多方法的实现都不是Java编程语言本身编写的，好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的，和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的，这不就成了核心病毒了么？&nbsp;<br>---&nbsp;<br>上面所述是最重要的，另外一个方面，上面2位老兄说的也都很对，就是不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了，就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性，如果随便能改了，那么Java编写的程序肯定就很不稳定，你可以保证自己不乱改，但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的，所以这个安全性是很重要的，Java和C++相比，优点之一就包括这一点；<br>---<br>原因绝对不只有这么多，因为如果这些个核心的类都能被随便操作的话，那是很恐怖的，会出现好多好多未知的错误，莫名其妙的错误....&nbsp;</p>\n<p>【转载】<a href=\"http://blog.csdn.net/fenglibing/article/details/5486449\">http://blog.csdn.net/fenglibing/article/details/5486449</a></p>\n</div>"
  },
  {
    "category": "javaBasic",
    "qes": "HashMap合集",
    "ans": "<div class=\"RichText ztext Post-RichText\"><h2><b>HashMap面试小抄</b></h2><blockquote> 本篇内容：4500+字<br> 建议阅读时间：9分钟<br> </blockquote><p>对于JAVA求职者来说，HashMap 可谓是重中之重，是面试必考点。然而 HashMap 的知识点非常多，复习起来花费精力很大，库森当年校招面试时就经历过这种痛苦，结合自己的面试经验，斗胆写一篇关于 HashMap 的面试专题文章，希望对小伙伴有所帮助!</p><h2><b>1. 存储结构</b> </h2><blockquote> HashMap的底层数据结构是什么？<br> </blockquote><p>在JDK1.7 和JDK1.8 中有所差别：</p><p>在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>在JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：</p><ul><li>当链表超过 8 且数据总量超过 64 才会转红黑树。<br> </li><li>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。<br> </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-acb81d194c6f522f26e4e798e776bda4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"815\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb\" width=\"815\" data-original=\"https://pic1.zhimg.com/v2-acb81d194c6f522f26e4e798e776bda4_r.jpg\"/></noscript><img src=\"https://pic1.zhimg.com/80/v2-acb81d194c6f522f26e4e798e776bda4_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"815\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"815\" data-original=\"https://pic1.zhimg.com/v2-acb81d194c6f522f26e4e798e776bda4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-acb81d194c6f522f26e4e798e776bda4_b.jpg\" data-lazy-status=\"ok\"></figure><p>更深入的面试问题，</p><blockquote> 为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?<br> </blockquote><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p><p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p><blockquote><i>不用红黑树，用二叉查找树可以么?</i><br> </blockquote><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><blockquote> 为什么链表改为红黑树的阈值是 8?<br> </blockquote><p>是因为泊松分布，我们来看作者在源码中的注释：</p><div class=\"highlight\"><pre><code class=\"language-text\"> Because TreeNodes are about twice the size of regular nodes, we\n use them only when bins contain enough nodes to warrant use\n (see TREEIFY_THRESHOLD). And when they become too small (due to\n removal or resizing) they are converted back to plain bins.  In\n usages with well-distributed user hashCodes, tree bins are\n rarely used.  Ideally, under random hashCodes, the frequency of\n nodes in bins follows a Poisson distribution\n (http://en.wikipedia.org/wiki/Poisson_distribution) with a\n parameter of about 0.5 on average for the default resizing\n threshold of 0.75, although with a large variance because of\n resizing granularity. Ignoring variance, the expected\n occurrences of list size k are (exp(-0.5) pow(0.5, k) /\n factorial(k)). The first values are:\n 0:    0.60653066\n 1:    0.30326533\n 2:    0.07581633\n 3:    0.01263606\n 4:    0.00157952\n 5:    0.00015795\n 6:    0.00001316\n 7:    0.00000094\n 8:    0.00000006\n more: less than 1 in ten million\n</code></pre></div><p>翻译过来大概的意思是：理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循<b><a href=\"https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Poisson_distribution\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">泊松分布</a></b>，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为 8 时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了 8，是根据概率统计而选择的。</p><h3><b>字段结构</b></h3><blockquote> 默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？<br> </blockquote><p>回答这个问题前，我们来先看下HashMap的默认构造函数：</p><div class=\"highlight\"><pre><code class=\"language-text\">     int threshold;             // 容纳键值对的最大值\n     final float loadFactor;    // 负载因子\n     int modCount;  \n     int size;  \n</code></pre></div><p>Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下 ：</p><ul><li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。<br> </li><li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。<br> </li></ul><p>我们来追溯下作者在源码中的注释（JDK1.7）：</p><div class=\"highlight\"><pre><code class=\"language-text\">As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.\n</code></pre></div><p>翻译过来大概的意思是：作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生。</p><h2><b>2. 索引计算</b> </h2><blockquote> HashMap 中  key 的存储索引是怎么计算的？<br> </blockquote><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&amp;（length-1）计算得到存储的位置。看看源码的实现：</p><div class=\"highlight\"><pre><code class=\"language-text\">// jdk1.7\n方法一：\nstatic int hash(int h) {\n    int h = hashSeed;\n        if (0 != h &amp;&amp; k instanceof String) {\n            return sun.misc.Hashing.stringHash32((String) k);\n        }\n\n    h ^= k.hashCode(); // 为第一步：取hashCode值\n    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); \n    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n}\n方法二：\nstatic int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样\n     return h &amp; (length-1);  //第三步：取模运算\n}\n\n// jdk1.8\nstatic final int hash(Object key) {   \n     int h;\n     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    /* \n     h = key.hashCode() 为第一步：取hashCode值\n     h ^ (h &gt;&gt;&gt; 16)  为第二步：高位参与运算\n    */\n}\n\n</code></pre></div><p>这里的 Hash 算法本质上就是三步：<b>取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标</b>。其中，JDK1.7和1.8的不同之处，就在于第二步。我们来看下详细过程，以JDK1.8为例，n为table的长度。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1198\" data-rawheight=\"684\" class=\"origin_image zh-lightbox-thumb\" width=\"1198\" data-original=\"https://pic2.zhimg.com/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_r.jpg\"/></noscript><img src=\"https://pic2.zhimg.com/80/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1198\" data-rawheight=\"684\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1198\" data-original=\"https://pic2.zhimg.com/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b4ee6bf7f5218e79a2a1c3a8dedc9c81_b.jpg\" data-lazy-status=\"ok\"></figure><p>扩展出以下几个问题，</p><blockquote> JDK1.8 为什么要 hashcode 异或其右移十六位的值？<br> </blockquote><p>因为在JDK 1.7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。 从速度、功效、质量来考虑，JDK1.8 优化了高位运算的算法，通过hashCode()的高16位异或低16位实现：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)。这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><blockquote> 为什么 hash 值要与length-1相与？<br> </blockquote><ul><li>把 hash 值对数组长度取模运算，模运算的消耗很大，没有位运算快。</li><li>当 length 总是 2 的n次方时，h&amp; (length-1) 运算等价于对length取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。</li></ul><blockquote> HashMap数组的长度为什么是 2 的幂次方？<br> </blockquote><p>这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外，2 的 N 次幂有助于减少碰撞的几率。如果 length 为2的幂次方，则 length-1 转化为二进制必定是11111……的形式，在与h的二进制与操作效率会非常的快，而且空间不浪费。我们来举个例子，看下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b30292aac94653d2b89cad181ca074e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"383\" data-rawheight=\"425\" class=\"content_image\" width=\"383\"/></noscript><img src=\"https://pic1.zhimg.com/80/v2-b30292aac94653d2b89cad181ca074e0_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"383\" data-rawheight=\"425\" class=\"content_image lazy\" width=\"383\" data-actualsrc=\"https://pic1.zhimg.com/v2-b30292aac94653d2b89cad181ca074e0_b.jpg\" data-lazy-status=\"ok\"></figure><p>当 length =15时，6 和 7 的结果一样，这样表示他们在 table 存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，4和5的结果也是一样，这样就会导致查询速度降低。</p><p>如果我们进一步分析，还会发现空间浪费非常大，以 length=15 为例，在 1、3、5、7、9、11、13、15 这八处没有存放数据。因为hash值在与14（即 1110）进行&amp;运算时，得到的结果最后一位永远都是0，即 0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的。</p><p><b>补充数组容量计算的小奥秘</b></p><p>HashMap 构造函数允许用户传入的容量不是  2  的  n  次方，因为它可以自动地将传入的容量转换为  2  的  n 次方。会取大于或等于这个数的 且最近的2次幂作为 table 数组的初始容量，使用<code>tableSizeFor(int)</code>方法，如 tableSizeFor(10) = 16（2 的 4 次幂），tableSizeFor(20) = 32（2 的 5 次幂），也就是说 table 数组的长度总是 2 的次幂。JDK1.8 源码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">static final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n &gt;&gt;&gt; 1;\n        n |= n &gt;&gt;&gt; 2;\n        n |= n &gt;&gt;&gt; 4;\n        n |= n &gt;&gt;&gt; 8;\n        n |= n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n/*\n解释：位或( | )\nint n = cap - 1; 让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。\n*/\n</code></pre></div><h2><b>3. put方法</b> </h2><blockquote> HashMap 的put方法流程？<br> </blockquote><p>简要流程如下：</p><ol><li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；<br> </li><li>如果数组是空的，则调用 resize 进行初始化；<br> </li><li>如果没有哈希冲突直接放在对应的数组下标里；<br> </li><li>如果冲突了，且 key 已经存在，就覆盖掉 value；<br> </li><li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；<br> </li><li>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。<br> </li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-22ad271660f124de749950ca1916fbb5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"695\" class=\"origin_image zh-lightbox-thumb\" width=\"665\" data-original=\"https://pic2.zhimg.com/v2-22ad271660f124de749950ca1916fbb5_r.jpg\"/></noscript><img src=\"https://pic2.zhimg.com/80/v2-22ad271660f124de749950ca1916fbb5_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"695\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"665\" data-original=\"https://pic2.zhimg.com/v2-22ad271660f124de749950ca1916fbb5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-22ad271660f124de749950ca1916fbb5_b.jpg\" data-lazy-status=\"ok\"></figure><p>详细分析，见JDK1.8HashMap 的 put 方法源码:</p><div class=\"highlight\"><pre><code class=\"language-text\"> public V put(K key, V value) {\n     // 对key的hashCode()做hash\n        return putVal(hash(key), key, value, false, true);\n    }\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n     // 步骤1：tab为空则创建\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n     // 步骤2：计算index，并对null做处理 \n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node&lt;K,V&gt; e; K k;\n            // 步骤3：节点key存在，直接覆盖value\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n            // 步骤4：判断该链为红黑树\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            // 步骤5：该链为链表\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        //链表长度大于8转换为红黑树进行处理\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    // key已经存在直接覆盖value\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n     // 步骤6：超过最大容量 就扩容\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n\n// 第31行treeifyBin方法部分代码\nfinal void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {\n        int n, index; Node&lt;K,V&gt; e;\n     // static final int MIN_TREEIFY_CAPACITY = 64;\n     // 如果大于8但是数组容量小于64，就进行扩容\n        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)\n            resize();\n    \n }\n        \n        \n\n</code></pre></div><h3><b>扩展的问题</b></h3><blockquote> JDK1.7 和1.8 的put方法区别是什么？<br> </blockquote><p>区别在两处：</p><p>解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定条件，链表会转换为红黑树。</p><p>链表插入元素时，JDK1.7 使用头插法插入元素，在多线程的环境下有可能导致环形链表的出现，扩容的时候会导致死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是线程不安全的，具体原因会在另一篇文章分析。</p><h2><b>4. 扩容机制</b> </h2><blockquote> HashMap 的扩容方式？<br> </blockquote><p>Hashmap 在容量超过负载因子所定义的容量之后，就会扩容。Java 里的数组是无法自动扩容的，方法是将 Hashmap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。</p><p>那扩容的具体步骤是什么？让我们看看源码。</p><p>先来看下JDK1.7 的代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">void resize(int newCapacity) {   //传入新的容量\n        Entry[] oldTable = table;    //引用扩容前的Entry数组\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {  //扩容前的数组大小如果已经达到最大(2^30)了\n            threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了\n            return;\n        }\n\n        Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组\n        transfer(newTable);                         //！！将数据转移到新的Entry数组里\n        table = newTable;                           //HashMap的table属性引用新的Entry数组\n        threshold = (int)(newCapacity * loadFactor);//修改阈值\n    }\n</code></pre></div><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><div class=\"highlight\"><pre><code class=\"language-text\">void transfer(Entry[] newTable) {\n        Entry[] src = table;                   //src引用了旧的Entry数组\n        int newCapacity = newTable.length;\n        for (int j = 0; j &lt; src.length; j++) { //遍历旧的Entry数组\n            Entry&lt;K,V&gt; e = src[j];             //取得旧Entry数组的每个元素\n            if (e != null) {\n                src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）\n                do {\n                    Entry&lt;K,V&gt; next = e.next;\n                    int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置\n                    e.next = newTable[i]; //标记[1]\n                    newTable[i] = e;      //将元素放在数组上\n                    e = next;             //访问下一个Entry链上的元素\n                } while (e != null);\n            }\n        }\n    }\n</code></pre></div><p>newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。</p><h3><b>JDK1.8的优化</b></h3><blockquote> 扩容在JDK1.8中有什么不一样？<br> </blockquote><p>JDK1.8做了两处优化：</p><ol><li>resize 之后，元素的位置在原来的位置，或者原来的位置 +oldCap (原来哈希表的长度）。不需要像 JDK1.7 的实现那样重新计算hash ，只需要看看原来的 hash 值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引 + oldCap ”。这个设计非常的巧妙，省去了重新计算 hash 值的时间。<br> 如下图所示，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。<br> </li></ol><p class=\"ztext-empty-paragraph\"><br></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c3b1ff00a544dc87d5b1be3acc8381db_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1632\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb\" width=\"1632\" data-original=\"https://pic4.zhimg.com/v2-c3b1ff00a544dc87d5b1be3acc8381db_r.jpg\"/></noscript><img src=\"https://pic4.zhimg.com/80/v2-c3b1ff00a544dc87d5b1be3acc8381db_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1632\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1632\" data-original=\"https://pic4.zhimg.com/v2-c3b1ff00a544dc87d5b1be3acc8381db_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c3b1ff00a544dc87d5b1be3acc8381db_b.jpg\" data-lazy-status=\"ok\"></figure><p>元素在重新计算 hash 之后，因为 n 变为 2倍，那么 n-1 的 mask 范围在高位多 1 bit(红色)，因此新的index就会发生这样的变化：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-832a4b53734c40500304945f2d8f6b85_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1064\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb\" width=\"1064\" data-original=\"https://pic2.zhimg.com/v2-832a4b53734c40500304945f2d8f6b85_r.jpg\"/></noscript><img src=\"https://pic2.zhimg.com/80/v2-832a4b53734c40500304945f2d8f6b85_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1064\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1064\" data-original=\"https://pic2.zhimg.com/v2-832a4b53734c40500304945f2d8f6b85_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-832a4b53734c40500304945f2d8f6b85_b.jpg\" data-lazy-status=\"ok\"></figure><ol><li>JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置（头插法）。JDK1.8 不会倒置，使用尾插法。</li></ol><p>下图为 16扩充为 32 的 resize 示意图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-42064a0899ee6ccf20e57880ab9b7592_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1268\" data-rawheight=\"730\" class=\"origin_image zh-lightbox-thumb\" width=\"1268\" data-original=\"https://pic3.zhimg.com/v2-42064a0899ee6ccf20e57880ab9b7592_r.jpg\"/></noscript><img src=\"https://pic3.zhimg.com/80/v2-42064a0899ee6ccf20e57880ab9b7592_720w.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1268\" data-rawheight=\"730\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1268\" data-original=\"https://pic3.zhimg.com/v2-42064a0899ee6ccf20e57880ab9b7592_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-42064a0899ee6ccf20e57880ab9b7592_b.jpg\" data-lazy-status=\"ok\"></figure><p>感兴趣的小伙伴可以看下 JDK1.8 的 resize 源码：</p><div class=\"highlight\"><pre><code class=\"language-text\">final Node&lt;K,V&gt;[] resize() {\n        Node&lt;K,V&gt;[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap &gt; 0) {\n   // 超过最大值就不再扩充了，就只好随你碰撞去吧\n            if (oldCap &gt;= MAXIMUM_CAPACITY) {\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n   // 没超过最大值，就扩充为原来的2倍\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr &lt;&lt; 1; // double threshold\n        }\n        else if (oldThr &gt; 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        else {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n  // 计算新的resize上限\n        if (newThr == 0) {\n\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                    (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\"，\"unchecked\"})\n        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n   // 把每个bucket都移动到新的buckets中\n            for (int j = 0; j &lt; oldCap; ++j) {\n                Node&lt;K,V&gt; e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash &amp; (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else { // 链表优化重hash的代码块\n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do {\n                            next = e.next;\n       // 原索引\n                            if ((e.hash &amp; oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n       // 原索引+oldCap\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n      // 原索引放到bucket里\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n      // 原索引+oldCap放到bucket里\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n</code></pre></div><h2><b>5. 其他</b> </h2><blockquote> 还知道哪些hash算法？<br> </blockquote><p>Hash函数是指把一个大范围映射到一个小范围，目的往往是为了节省空间，使得数据容易保存。 比较出名的有MurmurHash、MD4、MD5等等。</p><blockquote> key 可以为 Null 吗?<br> </blockquote><p>可以，key 为 Null 的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</p><blockquote> 一般用什么作为HashMap的key?<br> </blockquote><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p><ul><li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</li><li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li></ul><blockquote> 用可变类当 HashMap 的 key 有什么问题?<br> </blockquote><p>hashcode 可能发生改变，导致 put 进去的值，无法 get 出。如下所示</p><div class=\"highlight\"><pre><code class=\"language-text\">HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = new HashMap&lt;&gt;();\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"hello\");\nObject objectValue = new Object();\nchangeMap.put(list, objectValue);\nSystem.out.println(changeMap.get(list));\nlist.add(\"hello world\");//hashcode发生了改变\nSystem.out.println(changeMap.get(list));\n</code></pre></div><p>输出值如下</p><div class=\"highlight\"><pre><code class=\"language-text\">java.lang.Object@74a14482\nnull\n</code></pre></div><h2><b>最后</b> </h2><p>以上便是 HashMap 的核心面试题了，限于篇幅原因，本文并没有讲到 HashMap 的线程不安全问题，后面会专门写一篇文章讲解，敬请期待呦！</p><h2><b>参考</b> </h2><p><b><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/2016/06/24/java-hashmap.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">Java 8系列之重新认识HashMap</a></b></p><p><b><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/64f6de3ffcc1\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">HashMap的loadFactor为什么是0.75？</a></b></p><p><b><a href=\"https://link.zhihu.com/?target=https%3A//juejin.cn/post/6844903588779524110\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">HashMap扩容拾遗</a></b></p><p>[<b><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chenssy/p/3521565.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\">HashMap</a></b>](<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chenssy/p/3521565.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\" data-za-detail-view-id=\"1043\"><span class=\"invisible\">https://www.</span><span class=\"visible\">cnblogs.com/chenssy/p/3</span><span class=\"invisible\">521565.html</span><span class=\"ellipsis\"></span></a>)</p><p><b><a href=\"https://zhuanlan.zhihu.com/p/76735726\" class=\"internal\" data-za-detail-view-id=\"1043\">HashMap面试指南</a></b></p></div>"
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  }

]