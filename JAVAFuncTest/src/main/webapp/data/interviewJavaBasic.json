[
  {
    "category": "javaBasic",
    "qes": "重载overload和重写override的区别",
    "ans": "<div class=\"article-body\">\n\t\t\n\t\t\t<div class=\"article-intro\" id=\"content\">\n\t\t\t\n\t\t\t<h1>Java 重写(Override)与重载(Overload)</h1>\n<hr>\n<h2>重写(Override)</h2>\n<p> 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong>\n</p>\n\n<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。\n也就是说子类能够根据需要实现父类的方法。</p>\n<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如：\n父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n</p>\n<p>\n在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Animal 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 执行 Animal 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div>\n<p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">动物可以移动</span><span class=\"pln\">\n</span><span class=\"pun\">狗可以跑和走</span></pre>\n<p>在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。</p><p>\n这是由于在编译阶段，只是检查参数的引用类型。</p><p>\n然而在运行时，Java 虚拟机(JVM)指定对象的类型并且运行该对象的方法。</p><p>\n因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，运行的是特定对象的方法。</p><p>\n思考以下例子：</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">bark</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以吠叫</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Animal 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 执行 Animal 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;</span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog 类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">bark</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div><p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">TestDog</span><span class=\"pun\">.</span><span class=\"pln\">java</span><span class=\"pun\">:</span><span class=\"lit\">30</span><span class=\"pun\">:</span><span class=\"pln\"> cannot find symbol\nsymbol  </span><span class=\"pun\">:</span><span class=\"pln\"> method bark</span><span class=\"pun\">()</span><span class=\"pln\">\nlocation</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Animal</span><span class=\"pln\">\n                b</span><span class=\"pun\">.</span><span class=\"pln\">bark</span><span class=\"pun\">();</span><span class=\"pln\">\n                 </span><span class=\"pun\">^</span></pre>\n<p>该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。</p>\n<hr>\n<h2>方法的重写规则</h2>\n<ul>\n\t<li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li>\n\t<li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li>\n\t<li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li>\n\t<li><p>父类的成员方法只能被它的子类重写。</p></li>\n\t<li><p>声明为 final 的方法不能被重写。</p></li>\n\t<li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li>\n\t\n\t<li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li>\n\t<li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li>\n\t<li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li>\n\t<li><p>构造方法不能被重写。</p></li>\n\t<li><p>如果不能继承一个类，则不能重写该类的方法。</p></li>\n</ul>\n<hr><h2>Super 关键字的使用</h2>\n<p>\n当需要在子类中调用父类的被重写方法时，要使用 super 关键字。\n</p>\n<div class=\"example\">\n<h2 class=\"example\">TestDog.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">动物可以移动</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">extends</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n      </span><span class=\"hl-reserved\">super</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> 应用super类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">狗可以跑和走</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n</span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">TestDog</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n   </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n \n      </span><span class=\"hl-identifier\">Animal</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Dog</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\"> Dog 对象</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n      </span><span class=\"hl-identifier\">b</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">move</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">; </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">执行 Dog类的方法</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n \n   </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div><p>以上实例编译运行结果如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">动物可以移动</span><span class=\"pln\">\n</span><span class=\"pun\">狗可以跑和走</span></pre>\n\n<h2>重载(Overload)</h2>\n<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>\n<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>\n<p>最常用的地方就是构造器的重载。</p>\n<p><strong>重载规则:</strong></p>\n<ul>\n<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>\n<li>被重载的方法可以改变返回类型；</li>\n<li>被重载的方法可以改变访问修饰符；</li>\n<li>被重载的方法可以声明新的或更广的检查异常；</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n<li>无法以返回值类型作为重载函数的区分标准。\n</li>\n</ul>\n<h3>实例</h3>\n<div class=\"example\">\n<h2 class=\"example\">Overloading.java 文件代码：</h2>\n<div class=\"example_code\">\n<div class=\"hl-main\"><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-reserved\">class</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-code\"> </span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test1</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-number\">1</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test2</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-comment\">//</span><span class=\"hl-comment\">以下两个参数类型顺序不同</span><span class=\"hl-comment\"></span><span class=\"hl-code\">\n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-code\">,</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">s</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">returntest3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">s</span><span class=\"hl-code\">,</span><span class=\"hl-types\">int</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">a</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-reserved\">return</span><span class=\"hl-code\"> </span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">returntest4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">   \n \n    </span><span class=\"hl-reserved\">public</span><span class=\"hl-code\"> </span><span class=\"hl-types\">static</span><span class=\"hl-code\"> </span><span class=\"hl-types\">void</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">main</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">String</span><span class=\"hl-brackets\">[</span><span class=\"hl-brackets\">]</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">args</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">{</span><span class=\"hl-code\">\n        </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">o</span><span class=\"hl-code\"> = </span><span class=\"hl-reserved\">new</span><span class=\"hl-code\"> </span><span class=\"hl-identifier\">Overloading</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-number\">1</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-number\">1</span><span class=\"hl-code\">,</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test3</span><span class=\"hl-quotes\">\"</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n        </span><span class=\"hl-identifier\">System</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">out</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">println</span><span class=\"hl-brackets\">(</span><span class=\"hl-identifier\">o</span><span class=\"hl-code\">.</span><span class=\"hl-identifier\">test</span><span class=\"hl-brackets\">(</span><span class=\"hl-quotes\">\"</span><span class=\"hl-string\">test4</span><span class=\"hl-quotes\">\"</span><span class=\"hl-code\">,</span><span class=\"hl-number\">1</span><span class=\"hl-brackets\">)</span><span class=\"hl-brackets\">)</span><span class=\"hl-code\">;\n    </span><span class=\"hl-brackets\">}</span><span class=\"hl-code\">\n</span><span class=\"hl-brackets\">}</span></div>\n</div>\n</div>\n<hr><h2>重写与重载之间的区别</h2>\n<table class=\"reference\">\n<tbody>\n<tr>\n<th width=\"72\">\n区别点\n</th>\n<th width=\"80\">\n重载方法  \n</th>\n<th width=\"340\">\n重写方法\n</th>\n</tr>\n<tr>\n<td width=\"72\">\n参数列表\n</td>\n<td width=\"80\">\n必须修改\n</td>\n<td width=\"340\">\n一定不能修改\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n返回类型\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n一定不能修改\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n异常\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n可以减少或删除，一定不能抛出新的或者更广的异常\n</td>\n</tr>\n<tr>\n<td width=\"72\">\n访问\n</td>\n<td width=\"80\">\n可以修改\n</td>\n<td width=\"340\">\n一定不能做更严格的限制（可以降低限制）\n</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>总结</h2>\n<p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>\n<ul><li>\n(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li><li>\n(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li><li>\n(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2013/12/overloading-vs-overriding.png\"></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.png\"></p>\n\t\t\t<!-- 其他扩展 -->\n\t\t\t\t\t\t\n\t\t\t</div>\n\t\t\t\n\t\t</div>"
  },
  {
    "category": "javaBasic",
    "qes": "java中接口（interface）和虚基类（abstract class）的区别",
    "ans": "<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <p>在<a class=\"replace_word\" title=\"Java SE知识库\" href=\"http://lib.csdn.net/base/javase\" target=\"_blank\">Java</a>语言中，abstract class和interface是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于abstract class和interface的选择显得比较随意。其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。</p>\n<p>&nbsp;</p>\n<div>\n<table style=\"width: 100%\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"7%\">\n<p align=\"left\">&nbsp;</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">Abstract class</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">Interface</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">实例化</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">不能</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不能</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">类</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">一种继承关系，一个类只能使用一次继承关系。可以通过继承多个接口实现多重继承</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">一个类可以实现多个interface</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">数据成员</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可有自己的</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">静态的不能被修改即必须是static final，一般不在此定义</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">方法</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可以私有的，非abstract方法，必须实现</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不可有私有的，默认是public，abstract&nbsp;类型</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">变量</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">可有私有的，默认是friendly&nbsp;型，其值可以在子类中重新定义，也可以重新赋值</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">不可有私有的，默认是public static final&nbsp;型，且必须给其初值，实现类中不能重新定义，不能改变其值。</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">设计理念</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">表示的是“is-a”关系</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">表示的是“like-a”关系</p>\n</td>\n</tr>\n<tr>\n<td width=\"7%\">\n<p align=\"center\">实现</p>\n</td>\n<td width=\"41%\">\n<p align=\"center\">需要继承，要用extends</p>\n</td>\n<td width=\"51%\">\n<p align=\"center\">要用implements</p>\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>abstract class和interface在Java语言中都是用来进行抽象类（本文中的抽象类并非从abstract class翻译而来，它表示的是一个抽象体，而abstract class为Java语言中用于定义抽象类的一种方法）定义的，那么什么是抽象类，使用抽象类能为我们带来什么好处呢？</p>\n<p>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</p>\n<p>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现 这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。 然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到 接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>\n<p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数。接口更关注“能实现什么功能”，而不管“怎么实现的”。</p>\n<p><strong>1.相同点</strong><br>&nbsp; A. 两者都是抽象类，都不能实例化。<br>&nbsp; B. interface实现类及abstrct class的子类都必须要实现已经声明的抽象方法。</p>\n<p><strong>2. 不同点</strong><br>&nbsp; A. interface需要实现，要用implements，而abstract class需要继承，要用extends。<br>&nbsp; B. 一个类可以实现多个interface，但一个类只能继承一个abstract class。<br>&nbsp; C. interface强调特定功能的实现，而abstract class强调所属关系。&nbsp;<br>&nbsp; D. 尽管interface实现类及abstrct class的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstract class的子类可以有选择地实现。<br>&nbsp;&nbsp;这个选择有两点含义：<br>&nbsp;&nbsp;&nbsp; 一是Abastract class中并非所有的方法都是抽象的，只有那些冠有abstract的方法才是抽象的，子类必须实现。那些没有abstract的方法，在Abstrct class中必须定义方法体。<br>&nbsp;&nbsp;&nbsp; 二是abstract class的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以通过再次声明其方法为抽象的方式，无需实现，留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。<br>&nbsp; E. abstract class是interface与Class的中介。<br>&nbsp; interface是完全抽象的，只能声明方法，而且只能声明pulic的方法，不能声明private及protected的方法，不能定义方法体，也 不能声明实例变量。然而，interface却可以声明常量变量，并且在JDK中不难找出这种例子。但将常量变量放在interface中违背了其作为接 口的作用而存在的宗旨，也混淆了interface与类的不同价值。如果的确需要，可以将其放在相应的abstract class或Class中。<br>&nbsp; abstract class在interface及Class中起到了承上启下的作用。一方面，abstract class是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己 的实例变量，以供子类通过继承来使用。</p>\n<p><strong>3. interface的应用场合</strong><br>&nbsp; A. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。<br>&nbsp; B. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。<br>&nbsp; C. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。<br>&nbsp; D. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。</p>\n<p><strong>4. abstract class的应用场合</strong><br>&nbsp; 一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：<br>&nbsp; A. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。<br>&nbsp; B. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。<br>&nbsp; C. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能。</p>\n<p>&nbsp;</p>\n<p>&nbsp; 注： 本文原作网址：http://blog.csdn.net/b271737818/article/details/3950245&nbsp;</p>\n<p>&nbsp; 原作者：<a class=\"user_name\" href=\"http://my.csdn.net/b271737818\" target=\"_blank\">moolf</a>&nbsp;&nbsp;</p>\n</div>"
  },
  {
    "category": "javaBasic",
    "qes": "Java 内部类详解",
    "ans": "<div class=\"article-body note-body\">\n\t\t\t\t<div class=\"article-intro\">\n\t\t\t\t\t<h2>一.内部类基础</h2>\n<p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p>\n\n<h3>1.成员内部类</h3>\n\n<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"drawshape\"</span><span class=\"pun\">);</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> count </span><span class=\"pun\">=</span><span class=\"lit\">1</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">radius</span><span class=\"pun\">);</span><span class=\"pln\">  </span><span class=\"com\">//外部类的private成员</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">count</span><span class=\"pun\">);</span><span class=\"pln\">   </span><span class=\"com\">//外部类的静态成员</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pun\">外部类.</span><span class=\"kwd\">this</span><span class=\"pun\">.成员变量</span><span class=\"pln\">\n</span><span class=\"pun\">外部类.</span><span class=\"kwd\">this</span><span class=\"pun\">.成员方法</span></pre><p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">double</span><span class=\"pln\"> radius </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Circle</span><span class=\"pun\">(</span><span class=\"kwd\">double</span><span class=\"pln\"> radius</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">radius </span><span class=\"pun\">=</span><span class=\"pln\"> radius</span><span class=\"pun\">;</span><span class=\"pln\">\n        getDrawInstance</span><span class=\"pun\">().</span><span class=\"pln\">drawSahpe</span><span class=\"pun\">();</span><span class=\"pln\">   </span><span class=\"com\">//必须先创建成员内部类的对象，再进行访问</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> getDrawInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Draw</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">     </span><span class=\"com\">//内部类</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> drawSahpe</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">radius</span><span class=\"pun\">);</span><span class=\"pln\">  </span><span class=\"com\">//外部类的private成员</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">//第一种方式：</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pln\"> outter </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> outter</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">  </span><span class=\"com\">//必须通过Outter对象来创建</span><span class=\"pln\">\n         \n        </span><span class=\"com\">//第二种方式：</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner1 </span><span class=\"pun\">=</span><span class=\"pln\"> outter</span><span class=\"pun\">.</span><span class=\"pln\">getInnerInstance</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> getInnerInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">if</span><span class=\"pun\">(</span><span class=\"pln\">inner </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\">\n            inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> inner</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n      \n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>\n<h3>2.局部内部类</h3>\n<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Man</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Man</span><span class=\"pun\">(){</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pln\"> getWoman</span><span class=\"pun\">(){</span><span class=\"pln\">\n        </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Woman</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> </span><span class=\"typ\">People</span><span class=\"pun\">{</span><span class=\"pln\">   </span><span class=\"com\">//局部内部类</span><span class=\"pln\">\n            </span><span class=\"kwd\">int</span><span class=\"pln\"> age </span><span class=\"pun\">=</span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Woman</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>　<p><strong>注意</strong>: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p><h3>3.匿名内部类</h3>\n\n<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段 Android 事件监听代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">scan_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">});</span><span class=\"pln\">\n \nhistory_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n     \n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">});</span></pre><p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">OnClickListener</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> setListener</span><span class=\"pun\">()</span><span class=\"pln\">\n</span><span class=\"pun\">{</span><span class=\"pln\">\n    scan_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Listener1</span><span class=\"pun\">());</span><span class=\"pln\">       \n    history_bt</span><span class=\"pun\">.</span><span class=\"pln\">setOnClickListener</span><span class=\"pun\">(</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Listener2</span><span class=\"pun\">());</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Listener1</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">View</span><span class=\"pun\">.</span><span class=\"typ\">OnClickListener</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n             \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Listener2</span><span class=\"pln\"> </span><span class=\"kwd\">implements</span><span class=\"pln\"> </span><span class=\"typ\">View</span><span class=\"pun\">.</span><span class=\"typ\">OnClickListener</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"lit\">@Override</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> onClick</span><span class=\"pun\">(</span><span class=\"typ\">View</span><span class=\"pln\"> v</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"com\">// TODO Auto-generated method stub</span><span class=\"pln\">\n             \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和 static 修饰符的。</p>\n\n<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>\n<h3>4.静态内部类</h3>\n<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p><img src=\"/wp-content/uploads/2018/04/021558444183591.jpg\"></p><hr>\n<h2>二.深入理解内部类</h2>\n<p><strong>1.为什么成员内部类可以无条件访问外部类的成员？</strong></p>\n\n<p>在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是 Outter.java 的代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> getInnerInstance</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">if</span><span class=\"pun\">(</span><span class=\"pln\">inner </span><span class=\"pun\">==</span><span class=\"pln\"> </span><span class=\"kwd\">null</span><span class=\"pun\">)</span><span class=\"pln\">\n            inner </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"kwd\">return</span><span class=\"pln\"> inner</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n      \n    </span><span class=\"kwd\">protected</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n             \n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>编译之后，出现了两个字节码文件：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021630063402064.jpg\"></p>\n<p>反编译 Outter$Inner.class 文件得到下面信息：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">E</span><span class=\"pun\">:</span><span class=\"pln\">\\Workspace\\Test\\b</span><span class=\"kwd\">in</span><span class=\"pln\">\\com\\cxh\\test2</span><span class=\"pun\">&gt;</span><span class=\"pln\">javap </span><span class=\"pun\">-</span><span class=\"pln\">v </span><span class=\"typ\">Outter$Inner</span><span class=\"pln\">\n</span><span class=\"typ\">Compiled</span><span class=\"pln\"> </span><span class=\"kwd\">from</span><span class=\"pln\"> </span><span class=\"str\">\"Outter.java\"</span><span class=\"pln\">\n</span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter$Inner</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> java</span><span class=\"pun\">.</span><span class=\"pln\">lang</span><span class=\"pun\">.</span><span class=\"typ\">Object</span><span class=\"pln\">\n  </span><span class=\"typ\">SourceFile</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"str\">\"Outter.java\"</span><span class=\"pln\">\n  </span><span class=\"typ\">InnerClass</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"com\">#24= #1 of #22; //Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes</span><span class=\"pln\">\nt2</span><span class=\"pun\">/</span><span class=\"typ\">Outter</span><span class=\"pln\">\n  minor version</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pln\">\n  major version</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">50</span><span class=\"pln\">\n  </span><span class=\"typ\">Constant</span><span class=\"pln\"> pool</span><span class=\"pun\">:</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#1 = class        #2;     //  com/cxh/test2/Outter$Inner</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#2 = Asciz        com/cxh/test2/Outter$Inner;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#3 = class        #4;     //  java/lang/Object</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#4 = Asciz        java/lang/Object;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#5 = Asciz        this$0;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#6 = Asciz        Lcom/cxh/test2/Outter;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#7 = Asciz        &lt;init&gt;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#8 = Asciz        (Lcom/cxh/test2/Outter;)V;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#9 = Asciz        Code;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#10 = Field       #1.#11; //  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t</span><span class=\"pln\">\nest2</span><span class=\"pun\">/</span><span class=\"typ\">Outter</span><span class=\"pun\">;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#11 = NameAndType #5:#6;//  this$0:Lcom/cxh/test2/Outter;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#12 = Method      #3.#13; //  java/lang/Object.\"&lt;init&gt;\":()V</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#13 = NameAndType #7:#14;//  \"&lt;init&gt;\":()V</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#14 = Asciz       ()V;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#15 = Asciz       LineNumberTable;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#16 = Asciz       LocalVariableTable;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#17 = Asciz       this;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#18 = Asciz       Lcom/cxh/test2/Outter$Inner;;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#19 = Asciz       SourceFile;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#20 = Asciz       Outter.java;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#21 = Asciz       InnerClasses;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#22 = class       #23;    //  com/cxh/test2/Outter</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#23 = Asciz       com/cxh/test2/Outter;</span><span class=\"pln\">\n</span><span class=\"kwd\">const</span><span class=\"pln\"> </span><span class=\"com\">#24 = Asciz       Inner;</span><span class=\"pln\">\n \n</span><span class=\"pun\">{</span><span class=\"pln\">\n</span><span class=\"kwd\">final</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pln\">$0</span><span class=\"pun\">;</span><span class=\"pln\">\n \n</span><span class=\"kwd\">public</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter$Inner</span><span class=\"pun\">(</span><span class=\"pln\">com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pun\">);</span><span class=\"pln\">\n  </span><span class=\"typ\">Code</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"typ\">Stack</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pun\">,</span><span class=\"pln\"> </span><span class=\"typ\">Locals</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pun\">,</span><span class=\"pln\"> </span><span class=\"typ\">Args_size</span><span class=\"pun\">=</span><span class=\"lit\">2</span><span class=\"pln\">\n   </span><span class=\"lit\">0</span><span class=\"pun\">:</span><span class=\"pln\">   aload_0\n   </span><span class=\"lit\">1</span><span class=\"pun\">:</span><span class=\"pln\">   aload_1\n   </span><span class=\"lit\">2</span><span class=\"pun\">:</span><span class=\"pln\">   putfield        </span><span class=\"com\">#10; //Field this$0:Lcom/cxh/test2/Outter;</span><span class=\"pln\">\n   </span><span class=\"lit\">5</span><span class=\"pun\">:</span><span class=\"pln\">   aload_0\n   </span><span class=\"lit\">6</span><span class=\"pun\">:</span><span class=\"pln\">   invokespecial   </span><span class=\"com\">#12; //Method java/lang/Object.\"&lt;init&gt;\":()V</span><span class=\"pln\">\n   </span><span class=\"lit\">9</span><span class=\"pun\">:</span><span class=\"pln\">   </span><span class=\"kwd\">return</span><span class=\"pln\">\n  </span><span class=\"typ\">LineNumberTable</span><span class=\"pun\">:</span><span class=\"pln\">\n   line </span><span class=\"lit\">16</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pln\">\n   line </span><span class=\"lit\">18</span><span class=\"pun\">:</span><span class=\"pln\"> </span><span class=\"lit\">9</span><span class=\"pln\">\n \n  </span><span class=\"typ\">LocalVariableTable</span><span class=\"pun\">:</span><span class=\"pln\">\n   </span><span class=\"typ\">Start</span><span class=\"pln\">  </span><span class=\"typ\">Length</span><span class=\"pln\">  </span><span class=\"typ\">Slot</span><span class=\"pln\">  </span><span class=\"typ\">Name</span><span class=\"pln\">   </span><span class=\"typ\">Signature</span><span class=\"pln\">\n   </span><span class=\"lit\">0</span><span class=\"pln\">      </span><span class=\"lit\">10</span><span class=\"pln\">      </span><span class=\"lit\">0</span><span class=\"pln\">    </span><span class=\"kwd\">this</span><span class=\"pln\">       </span><span class=\"typ\">Lcom</span><span class=\"pun\">/</span><span class=\"pln\">cxh</span><span class=\"pun\">/</span><span class=\"pln\">test2</span><span class=\"pun\">/</span><span class=\"typ\">Outter$Inner</span><span class=\"pun\">;</span><span class=\"pln\">\n \n \n</span><span class=\"pun\">}</span></pre><p>第11行到35行是常量池的内容，下面逐一第38行的内容：</p><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">final</span><span class=\"pln\"> com</span><span class=\"pun\">.</span><span class=\"pln\">cxh</span><span class=\"pun\">.</span><span class=\"pln\">test2</span><span class=\"pun\">.</span><span class=\"typ\">Outter</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pln\">$0</span><span class=\"pun\">;</span></pre>\n<p>这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说编译器会默认为成员内部类添加了一个指向外部类对象的引用，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：</p><p>public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</p>\n\n<p>从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的 Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对 Outter this&amp;0 引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>\n\n<p><strong>2.为什么局部内部类和匿名内部类只能访问局部final变量？</strong></p>\n\n<p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> test</span><span class=\"pun\">(</span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> b</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">10</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Thread</span><span class=\"pun\">(){</span><span class=\"pln\">\n            </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> run</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">b</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"pun\">};</span><span class=\"pln\">\n        </span><span class=\"pun\">}.</span><span class=\"pln\">start</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>　<p>这段代码会被编译成两个class文件：Test.class和Test1.class。<strong>默认情况下，编译器会为匿名内部类和局部内部类起名为<span class=\"marked\">Outterx.class</span>（x为正整数）</strong>。</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021900556994393.jpg\"></p>\n<p>根据上图可知，test 方法中的匿名内部类的名字被起为 Test$1。</p>\n\n<p>上段代码中，如果把变量 a 和 b 前面的任一个 final 去掉，这段代码都编译不过。我们先考虑这样一个问题：</p>\n\n<p>当 test 方法执行完毕之后，变量a的生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束，那么在 Thread 的 run 方法中继续访问变量 a 就变成不可能了，但是又要实现这样的效果，怎么办呢？Java 采用了复制的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021939271846598.jpg\"></p>\n<p>我们看到在 run 方法中有一条指令：</p><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"pln\">bipush </span><span class=\"lit\">10</span></pre><p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p><p>下面再看一个例子：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n     \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> test</span><span class=\"pun\">(</span><span class=\"kwd\">final</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Thread</span><span class=\"pun\">(){</span><span class=\"pln\">\n            </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> run</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n                </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"pun\">};</span><span class=\"pln\">\n        </span><span class=\"pun\">}.</span><span class=\"pln\">start</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><p>反编译得到：</p>\n<p><img src=\"//www.runoob.com/wp-content/uploads/2018/04/021950384493440.jpg\"></p>\n<p>我们看到匿名内部类 Test$1 的构造器含有两个参数，一个是指向外部类对象的引用，一个是 int 型变量，很显然，这里是将变量 test 方法中的形参 a 以参数的形式传进来对匿名内部类中的拷贝（变量 a 的拷贝）进行赋值初始化。</p>\n\n<p>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p>\n\n<p>从上面可以看出，在 run 方法中访问的变量 a 根本就不是 test 方法中的局部变量 a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在 run 方法中访问的变量 a 和 test 方法中的变量 a 不是同一个变量，当在 run 方法中改变变量 a 的值的话，会出现什么情况？</p>\n\n<p>对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java 编译器就限定必须将变量 a 限制为 final 变量，不允许对变量 a 进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>\n\n<p>到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用 final 进行限定了。</p>\n<p><strong>3.静态内部类有特殊的地方吗？</strong></p><p>从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译 class 文件看一下就知道了，是没有 <span class=\"marked\">Outter this&amp;0</span> 引用的。</p>\n<hr>\n<h2>三.内部类的使用场景和好处</h2><p>为什么在 Java 中需要内部类？总结一下主要有以下四点：</p>\n<ul><li>\n1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整。\n</li><li>2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。\n</li><li>3.方便编写事件驱动程序。\n</li><li>4.方便编写线程代码。</li></ul><p>个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p>\n<p><strong>四.常见的与内部类相关的笔试面试题</strong></p>\n <p>1.根据注释填写(1)，(2)，(3)处的代码</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">){</span><span class=\"pln\">\n           </span><span class=\"com\">// 初始化Bean1</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">1</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean1</span><span class=\"pun\">.</span><span class=\"pln\">I</span><span class=\"pun\">++;</span><span class=\"pln\">\n           </span><span class=\"com\">// 初始化Bean2</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">2</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean2</span><span class=\"pun\">.</span><span class=\"pln\">J</span><span class=\"pun\">++;</span><span class=\"pln\">\n           </span><span class=\"com\">//初始化Bean3</span><span class=\"pln\">\n           </span><span class=\"pun\">(</span><span class=\"lit\">3</span><span class=\"pun\">)</span><span class=\"pln\">\n           bean3</span><span class=\"pun\">.</span><span class=\"pln\">k</span><span class=\"pun\">++;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean1</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> I </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n \n    </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean2</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> J </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Bean3</span><span class=\"pun\">{</span><span class=\"pln\">\n           </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> k </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">0</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>\n\n<p>创建静态内部类对象的一般形式为：  <span class=\"marked\">外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</span></p>\n\n<p>创建成员内部类对象的一般形式为：  <span class=\"marked\">外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</span></p>\n<p>因此，（1），（2），（3）处的代码分别为：</p>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Test</span><span class=\"pln\"> test </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">();</span><span class=\"pln\">    \n</span><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean1</span><span class=\"pln\"> bean1 </span><span class=\"pun\">=</span><span class=\"pln\"> test</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean1</span><span class=\"pun\">();</span></pre>\n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean2</span><span class=\"pln\"> b2 </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pun\">.</span><span class=\"typ\">Bean2</span><span class=\"pun\">();</span></pre>  \n\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"typ\">Bean</span><span class=\"pln\"> bean </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean</span><span class=\"pun\">();</span><span class=\"pln\">     \n\n</span><span class=\"typ\">Bean</span><span class=\"pun\">.</span><span class=\"typ\">Bean3</span><span class=\"pln\"> bean3 </span><span class=\"pun\">=</span><span class=\"pln\">  bean</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Bean3</span><span class=\"pun\">();</span></pre>\n<p>2.下面这段代码的输出结果是什么？</p> \n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Test</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\">  </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">Outter</span><span class=\"pln\"> outter </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">();</span><span class=\"pln\">\n        outter</span><span class=\"pun\">.</span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">().</span><span class=\"kwd\">print</span><span class=\"pun\">();</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n \n \n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pln\">\n</span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">1</span><span class=\"pun\">;</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"kwd\">private</span><span class=\"pln\"> </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">2</span><span class=\"pun\">;</span><span class=\"pln\">\n        </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> </span><span class=\"kwd\">print</span><span class=\"pun\">()</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n            </span><span class=\"kwd\">int</span><span class=\"pln\"> a </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"lit\">3</span><span class=\"pun\">;</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"局部变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"内部类变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> </span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n            </span><span class=\"typ\">System</span><span class=\"pun\">.</span><span class=\"kwd\">out</span><span class=\"pun\">.</span><span class=\"pln\">println</span><span class=\"pun\">(</span><span class=\"str\">\"外部类变量：\"</span><span class=\"pln\"> </span><span class=\"pun\">+</span><span class=\"pln\"> </span><span class=\"typ\">Outter</span><span class=\"pun\">.</span><span class=\"kwd\">this</span><span class=\"pun\">.</span><span class=\"pln\">a</span><span class=\"pun\">);</span><span class=\"pln\">\n        </span><span class=\"pun\">}</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre><pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"lit\">3</span><span class=\"pln\">\n</span><span class=\"lit\">2</span><span class=\"pln\">\n</span><span class=\"lit\">1</span></pre><p>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>\n\n<ul><li>1）成员内部类的引用方式必须为 Outter.Inner \n</li><li>2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》    </li></ul>\n<pre class=\"prettyprint prettyprinted\" style=\"\"><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n    </span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">Inner</span><span class=\"pun\">{</span><span class=\"pln\">\n         \n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"kwd\">class</span><span class=\"pln\"> </span><span class=\"typ\">InheritInner</span><span class=\"pln\"> </span><span class=\"kwd\">extends</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pun\">.</span><span class=\"typ\">Inner</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n      \n    </span><span class=\"com\">// InheritInner() 是不能通过编译的，一定要加上形参</span><span class=\"pln\">\n    </span><span class=\"typ\">InheritInner</span><span class=\"pun\">(</span><span class=\"typ\">WithInner</span><span class=\"pln\"> wi</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        wi</span><span class=\"pun\">.</span><span class=\"kwd\">super</span><span class=\"pun\">();</span><span class=\"pln\"> </span><span class=\"com\">//必须有这句调用</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n  \n    </span><span class=\"kwd\">public</span><span class=\"pln\"> </span><span class=\"kwd\">static</span><span class=\"pln\"> </span><span class=\"kwd\">void</span><span class=\"pln\"> main</span><span class=\"pun\">(</span><span class=\"typ\">String</span><span class=\"pun\">[]</span><span class=\"pln\"> args</span><span class=\"pun\">)</span><span class=\"pln\"> </span><span class=\"pun\">{</span><span class=\"pln\">\n        </span><span class=\"typ\">WithInner</span><span class=\"pln\"> wi </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">WithInner</span><span class=\"pun\">();</span><span class=\"pln\">\n        </span><span class=\"typ\">InheritInner</span><span class=\"pln\"> obj </span><span class=\"pun\">=</span><span class=\"pln\"> </span><span class=\"kwd\">new</span><span class=\"pln\"> </span><span class=\"typ\">InheritInner</span><span class=\"pun\">(</span><span class=\"pln\">wi</span><span class=\"pun\">);</span><span class=\"pln\">\n    </span><span class=\"pun\">}</span><span class=\"pln\">\n</span><span class=\"pun\">}</span></pre>\n\n\n<blockquote><p>原文出处：https://www.cnblogs.com/dolphin0520/p/3811445.html</p></blockquote>\n\n\t\t\t\t</div>\n\t\t\t</div>"
  },
  {
    "category": "javaBasic",
    "qes": "内部类和静态内部类的区别",
    "ans": "<div class=\"RichText ztext Post-RichText\"><p><b>内部类和静态内部类的区别</b></p><p><b>内部类：</b></p><p>1、内部类中的变量和方法不能声明为静态的。<br>2、内部类实例化：B是A的内部类，实例化B：A.B b = new A().new B()。<br>3、内部类可以引用外部类的静态或者非静态属性及方法。</p><p><b>静态内部类：</b></p><p>1、静态内部类属性和方法可以声明为静态的或者非静态的。<br>2、实例化静态内部类：B是A的静态内部类，A.B b = new A.B()。<br>3、静态内部类只能引用外部类的静态的属性及方法。</p><blockquote>inner classes——内部类<br>static nested classes——静态嵌套类</blockquote><p>其实人家不叫静态内部类，只是叫习惯了，从字面就很容易理解了。</p><p>内部类依靠外部类的存在为前提，而静态嵌套类则可以完全独立，明白了这点就很好理解了。</p><p><b>非静态内部类中的变量和方法不能声明为静态的原因</b></p><p>静态类型的属性和方法，在类加载的时候就会存在于内存中。使用某个类的静态属性和方法，那么这个类必须要加载到虚拟机中。但是非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。</p><p>我们设想一个场景：在外部类并没有实例化，内部类还没有加载的时候如果调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内部类的静态成员，就会产生冲突。所以非静态内部类不能有静态成员变量或静态方法。</p><p><b>String，StringBuilder，StringBuffer的区别</b></p><ul><li>String 字符串常量</li><li>StringBuffer 字符串变量（线程安全）</li><li>StringBuilder 字符串变量（非线程安全）</li></ul><p>性能上通常StringBuilder &gt; StringBuffer &gt; String。</p><p>String是不可变对象，每次对String类型进行改变的时候都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以性能最差，对于要经常改变内容的字符串不用String。</p><p>StringBuffer是字符串变量，对它操作时，并不会生成新的对象，而是直接对该对象进行更改，所以性能较好。</p><p>StringBuilder和StringBuffer一样，是字符串变量，但是他不带有synchronized关键字，不保证线程安全，所以性能最好。在单线程的情况下，建议使用StringBuilder。</p><p><b>总体来说：</b></p><ul><li>String：适用于少量的字符串操作的情况。</li><li>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况。</li><li>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。</li></ul><p><b>来一些问题：</b></p><p>下面这段代码的输出结果是什么？</p><div class=\"highlight\"><pre><code class=\"language-text\">String a = \"helloworld\";\nString b = \"hello\" + \"world\";\nSystem.out.println((a == b));\njava中高端架构师交流群：603619042</code></pre></div><p><b>输出结果为：True。</b></p><p>原因是String对字符串的直接相加，会在编译期进行优化。即hello+world在编译时期，被优化为helloworld，所以在运行时期，他们指向了同一个对象。我们也可以推理，对于直接字符串的相加，String不一定比其余两个慢。</p><p>下面这段代码的输出结果是什么？</p><div class=\"highlight\"><pre><code class=\"language-text\">String a = \"helloworld\";\nString b = \"hello\";      \nString c = b + \"world\";      \nSystem.out.println((a == c));</code></pre></div><p><b>输出结果为：False。</b></p><p>原因是c并非两个字符串直接相加，包含了一个字符串引用，这时不会做编译期的优化。所以a、c最终生成了两个对象，这时他的效率低。</p><p>集合和数组之间的相互转换</p><p><b>数组变集合：</b></p><p>通常我们会回答的是以下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">List&lt;String&gt; list = Arrays.asList(array);</code></pre></div><p>但这并不是很好的答案，此时组合成的list是Arrays里面的一个静态内部类，该类并未实现add、remove方法，因此在使用时存在问题。</p><p><b>可以这样：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">String array[]= {\"hello\",\"world\",\"java\",\"zhiyin\"};\nList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array));</code></pre></div><p>集合变数组：</p><div class=\"highlight\"><pre><code class=\"language-text\">String[] array=list.toArray(new String[list.size()]);</code></pre></div><p><b>面向对象的特征有哪些方面?</b></p><p><b>抽象</b>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><p><b>继承</b>：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类；得到继承信息的类被称为子类。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p><p><b>封装</b>：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</p><p><b>多态性</b>：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。方法重载实现的是编译时的多态性，而方法重写实现的是运行时的多态性。</p><p><b>概括的解释下线程的几种状态</b></p><p>1.就绪(Runnable):线程准备运行，不一定立马就能开始执行。</p><p>2.运行中(Running)：进程正在执行线程的代码。</p><p>3.等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。</p><p>4.睡眠中(Sleeping)：线程被强制睡眠。</p><p>5.I/O阻塞(Blocked on I/O)：等待I/O操作完成。</p><p>6.同步阻塞(Blocked on Synchronization)：等待获取锁。</p><p>7.死亡(Dead)：线程完成了执行。</p><p><b>Java集合类里面基本的接口有哪些</b></p><p>1.Collection：代表一组对象，每一个对象都是它的子元素。</p><p>2.Set：不包含重复元素的Collection。</p><p>3.List：有顺序的collection，并且可以包含重复元素。</p><p>4.Map：可以把键(key)映射到值(value)的对象，键不能重复。</p><p><b>Iterator和ListIterator的区别</b></p><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向遍历也可以后向遍历。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加、替换元素，获取前一个和后一个元素的索引等等。</li></ul><p><b>Enumeration和Iterator的区别</b></p><ul><li>java中的集合类都提供了返回Iterator的方法，就是迭代器，它和Enumeration（枚举）的主要区别其实就是Iterator可以删除元素，但是Enumration却不能。</li><li>使用Iterator来遍历集合时，应使用Iterator的remove()方法来删除集合中的元素，使用集合的remove()方法将抛出ConcurrentModificationException异常。</li><li>Enumeration接口的功能和Iterator接口的功能是重复的。此外，Iterator 接口添加了一个可选的移除操作，并使用较短的方法名。新的实现应该优先考虑使用Iterator接口而不是Enumeration接口。</li><li>Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。</li></ul><p><b>介绍一下HTTP的响应结构</b></p><ul><li>请求报文的组成：</li><li>请求方法。</li><li>请求的资源的URI。</li><li>协议版本。</li><li>可选的请求首部字段。</li><li>内容实体。</li></ul><p><b>响应报文的组成：</b></p><ul><li>协议版本。</li><li>状态码。</li><li>用于解释状态码的原因短语。</li><li>可选的响应首部字段。</li><li>实体主体。</li></ul><p>**响应: **</p><ul><li>响应码：回应客户端此次响应是否成功。如：404(找不到请求的资源)，500(服务器内部错误)，200(成功响应)等。</li><li>消息头：服务器与客户端通信的暗码，告诉客户端该怎么执行某些操作。</li><li>响应正文：传递服务器响应给客户端要显示的内容，可以是下载文件或者显示界面。</li></ul><p><b>final、finalize和finally各自的作用</b></p><ul><li>final是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。</li><li>finalize方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。</li><li>finally是一个关键字，与try和catch一起用于异常的处理。finally块一定会被执行，无论在try块中是否有发生异常。</li></ul><p><b>说一下你了解的几种进程间的通信方式</b></p><p>管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>高级管道popen：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p><p>有名管道named pipe ：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p><p>信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><p>信号sinal： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></div>"
  },
  {
    "category": "javaBasic",
    "qes": "谨用ArrayList中的subList方法",
    "ans": "<div id=\"article_content\" class=\"article_content clearfix\">\n        <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css\">\n                <div id=\"content_views\" class=\"htmledit_views\">\n                    <h3><a name=\"t0\"></a><a name=\"t0\"></a>0、subList方法api：</h3> \n<p>Parameters:</p> \n<ul><li>fromIndex low endpoint (inclusive) of the subList</li><li>toIndex high endpoint (exclusive) of the subList</li></ul>\n<p>Returns:</p> \n<ul><li>a view of the specified range within this list</li></ul>\n<h3><a name=\"t1\"></a><a name=\"t1\"></a>1、规范一：</h3> \n<p>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs php\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">static</span> <span class=\"hljs-keyword\">void</span> test7() {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList = <span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList);<span class=\"hljs-comment\">//2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tArrayList&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList1 = (ArrayList&lt;<span class=\"hljs-keyword\">Integer</span>&gt;)<span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-comment\">//java.lang.ClassCastException: java.util.ArrayList$SubList cannot be cast to java.util.ArrayList</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList1);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>分析：</p> \n<ol><li>SubList 继承 AbstractList ，所以具有List接口的所有方法。</li><li><span style=\"color:#f33b45;\">SubList 是ArrayList 的一个内部类。SubList并没有重新创建一个List,而是直接引用原有的List，只不过对原来List做截取而已</span>。</li><li>ArrayList 也是继承AbstractList，但是 SubList 和 ArrayList 没有继承关系，所以不能强转换。</li></ol>\n<h3><a name=\"t2\"></a><a name=\"t2\"></a>2、规范二：</h3> \n<p>在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs php\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">static</span> <span class=\"hljs-keyword\">void</span> test8() {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; <span class=\"hljs-keyword\">list</span> = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">List</span>&lt;<span class=\"hljs-keyword\">Integer</span>&gt; subList = <span class=\"hljs-keyword\">list</span>.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-keyword\">list</span>.add(<span class=\"hljs-number\">4</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t<span class=\"hljs-comment\">//java.util.ConcurrentModificationException</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.out.println(subList);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>&nbsp;分析：</p> \n<p>1）调用subList方法返回的集合保存了ArrayList的modCount</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143247490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<p>2）当对原list进行add/remove时，导致modCount++；</p> \n<p>3）访问子集合时，加了checkForComodification();校验</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143314312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<h3><a name=\"t3\"></a><a name=\"t3\"></a>3、对subList返回的子集合进行add/remove操作会如何？</h3> \n<p>我们来看一段代码</p> \n<pre class=\"has\" name=\"code\"><code class=\"hljs csharp\"><ol class=\"hljs-ln\"><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"1\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test9</span>(<span class=\"hljs-params\"></span>)</span> {</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"2\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tList&lt;Integer&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"3\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">1</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"4\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">2</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"5\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tlist.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"6\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\t</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"7\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tList&lt;Integer&gt; subList = list.subList(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"8\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"9\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//2,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"10\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"------------------------\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"11\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tsubList.<span class=\"hljs-keyword\">remove</span>(<span class=\"hljs-number\">0</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"12\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"13\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//3</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"14\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">\"------------------------\"</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"15\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tsubList.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">4</span>);</div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"16\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(list);<span class=\"hljs-comment\">//1,3,4</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"17\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(subList);<span class=\"hljs-comment\">//3,4</span></div></div></li><li><div class=\"hljs-ln-numbers\"><div class=\"hljs-ln-line hljs-ln-n\" data-line-number=\"18\"></div></div><div class=\"hljs-ln-code\"><div class=\"hljs-ln-line\">\t}</div></div></li></ol></code><div class=\"hljs-button {2}\" data-title=\"复制\" data-report-click=\"{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}\" onclick=\"hljs.copyCode(event)\"></div></pre> \n<p>运行正常，分析：</p> \n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20200123143158727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXhpYW83MjM4NDY=,size_16,color_FFFFFF,t_70\"></p> \n<p>subList返回的集合在调用add/remove方法时，会将modCount进行更新。注：更新操作只更新原集合，因为subList不会重新创建新集合。</p> \n<p><strong>总结：</strong></p> \n<p>1、subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p> \n<p>2、在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p> \n<p>&nbsp;</p> \n<p></p> \n<p></p> \n<p></p> \n<p></p> \n<p></p>\n                </div><div><div></div></div>\n        </div>"
  },
  {
    "category": "javaBasic",
    "qes": "详解Map集合体系及方法entrySet、keySet、values",
    "ans": "<div class=\"postBody\">\n                \n<div id=\"cnblogs_post_body\" class=\"blogpost-body\">\n    <h3>简单回顾Map集合：</h3>\n<p>&nbsp;</p>\n<p>Map表示映射关系，以键值对的方式来保存数据。key和value一一对应。key是唯一的，不可重复，而value是可重复的，可以被多个key关联。虽然Map是放入两个数据，但是却以key作为操作对象，value只是作为key的关联值。</p>\n<p>通过查看，会发现Set与Map的实现类很相似，Set实现类的底层操作就是用Map来实现的，Set集的特性就来自于Map。唯一不同的就是Map表示一种映射关系，一次存储2个数据，Set只能存储单一数据。</p>\n<h3>Map体系中的主要类：</h3>\n<ul>\n<li>HashMap：Map的典型实现，元素是无序且不可重复，这里的元素指的是key。</li>\n<li>LinkedHashMap：以插入的次序作为排序状态，其他的和HashMap一致。</li>\n<li>TreeMap：元素处于排序状态，可以使用自然排序也可以使用自定义排序，但key的类型必须一致，不然无法进行比较。</li>\n<li>Properties：Key-Value都是String类型，用于加载属性文件。后续会说到。</li>\n</ul>\n<div>\n<h3>Map的重要方法和特点：</h3>\n<div>常用方法就不概述，关于Map中方法的使用细节，例如replace()和remove()方法，如果返回值是Object，则会返回以前的value，返回值boolean，代表是否执行成功。重点需要了解entrySet()、keySet()&nbsp;和values()的使用。</div>\n<div>\n<ul>\n<li>entrySet()___返回一个包含所有映射关系的Set集合，该Set集合的类型为Map.Entry，一般用于迭代键值对。Map.Entry是一个内部接口。</li>\n<li>keySet()__..._返回该映射中所有key组成的Set集合。通过key获取键值对。</li>\n<li>values()___._返回该映射中所有value值。</li>\n<li>这三个方法主要用于遍历键值对或直接获取value值，非常方便。但使用返回对象的方法时，会引发错误。代码示例和解析在最下面。</li>\n</ul>\n</div>\n</div>\n<h3>HashMap的代码示例</h3>\n<div>\n<pre name=\"code\" class=\"java\">\t\tHashMap hm = new HashMap();\n\t\t//放入键值对\n\t\thm.put(\"cn\", \"中国\");\n\t\thm.put(1, 100);\t\t\n\t\thm.put(\"us\", \"美国\");\n\t\thm.put(\"Ja\", \"日本\");\n\t\thm.put(\"时间\", new Date());\n\t\thm.put(1, 200);//用同一个key关联别的value\n\t\tSystem.out.println(hm);\t//等同于hm.toString()\n\t\t\n\t\tSystem.out.println(\"----根据key获取关联的值------\");\n\t\tSystem.out.println(hm.get(\"Ja\"));\n\t\tSystem.out.println(hm.get(1));\n\t\t\t\n\t\tSystem.out.println(\"----替换指定的键值对-------\");\n\t\tSystem.out.println(hm.replace(1, \"100\"));//返回被替换的value\n\t\tSystem.out.println(hm.replace(\"us\", \"美国\",\"FuckYou\"));//返回boolean，表示是否替换成功\n\t\t\n\t\tSystem.out.println(\"----删除指定键值对----\");\n\t\tSystem.out.println(hm.remove(\"Ja\"));//返回被删除的value\n\t\tSystem.out.println(hm.remove(\"Ja\",\"日本\"));//返回是否成功删除</pre>\n<div>典型的Map实现，查看打印结果：元素是无序且不可重复的。在代码中放入两个相同的键值对，key只能有一个，如果value也不同，后来添加的value会覆盖原来的value。</div>\n<div>&nbsp;</div>\n<h3>LinkedHashMap简单示例</h3>\n</div>\n<div>\n<pre name=\"code\" class=\"java\">\t\tLinkedHashMap lhm = new LinkedHashMap();\n\t\tlhm.put(1,\"B\");\n\t\tlhm.put(4,\"A\");\n\t\tlhm.put(3,\"C\");\n\t\tlhm.put(2,\"D\");\n\t\tSystem.out.println(lhm);\n\t\t//输出：{1=B, 4=A, 3=C, 2=D}</pre>\nLinkedHashMap就是以插入次序作为排序状态，别的和HashMap一致。非常类似于HashSet与LinkedHashSet的关系。</div>\n<div>&nbsp;</div>\n<h2>entrySet() 和 keySet()&nbsp;和 values()的代码示例</h2>\n<h4>以TreeMap为例，演示entrySet()</h4>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\t\n\t\t//使用迭代器来遍历元素\n\t\tSet entrys = tm.entrySet();\n\t\tIterator it = entrys.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tMap.Entry entry = (Map.Entry)it.next();//转换成Map.Entry类型\n\t\t\tSystem.out.println(entry.getKey() +\"-\" + entry.getValue());\t\t\t\n\t\t}</pre>\n</div>\n<h4>以TreeMap为例，演示keySet()</h4>\n<div>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\t\n\t\tSet k = tm.keySet();\n\t\tIterator it = k.iterator();\n\t\t//mode 1\n\t\twhile(it.hasNext()) {\n\t\t\tObject key = it.next();//获取key\n\t\t\tSystem.out.println(key + \"-&gt;\" + tm.get(key));\n\t\t}\n\t\t//mode 2\n\t\tfor(Object key : k) {\n\t\t\tSystem.out.println(key +\"-&gt;\" + tm.get(key));\n\t\t}</pre>\n</div>\n<div>\n<h4>以TreeMap为例，演示values()</h4>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\tCollection value = tm.values();\t\n\t\tfor(Object v : value) {\n\t\t\tSystem.out.println(v);\n\t\t}</pre>\n<div>&nbsp;</div>\n<h3>entrySet() keySet() 和 values()返回对象中的操作方法</h3>\n<div>\n<pre name=\"code\" class=\"java\">\t\tTreeMap tm = new TreeMap();\t\n\t\ttm.put(1, \"壹\");\t\t\n\t\ttm.put(3, \"叁\");\n\t\ttm.put(6, \"陆\");\n\t\ttm.put(7, \"柒\");\n\t\tSet entry = tm.entrySet();\t\n\t\tSet key = tm.keySet();\n\t\tCollection value = tm.values();\t\t\n\n//\t\tentry.add(\"A\");引发不支持的操作异常\n\t\tSystem.out.println(entry.remove(1));//false\n\t\tSystem.out.println(entry.contains(3));//false\n\t\t\n\t\tSystem.out.println(key.remove(1));//true\n\t\tSystem.out.println(key.contains(3));//true\n\t\t\n\t\tSystem.out.println(value.remove(\"壹\"));//false</pre>\n上面代码中，可以看出无论是返回Set对象还是Collection，添加元素都会引发不支持的操作异常。这是因为返回的集合对象本质上依然是对键值对操作。它们的不同之处：</div>\n<div>entrySet()中有key和value，所以直接加入元素或者删除元素的方法都是无效的。keySet()中有key，可以对key进行操作，所以能使用remove()和equals()，所以返回true。</div>\nvalues()中只有value值，没有key，value值是没什么用的，所以values()方法也仅仅是获取所有value值方便。</div>\n<div>相同之处：<br>方法中如果没有参数，不涉及到对键值对进行的操作，都是可以使用的。例如Iterator()、clear()、size()和isEmpty()等。</div>\n\n</div>\n<div>&nbsp;</div>\n<h3>entrySet() 和 keySet()&nbsp;和 values()的使用总结：</h3>\n<div>\n<ul>\n<li>一般只使用它们的迭代器，用于获取所有键值对。</li>\n<li>除了迭代器，对元素进行操作的方法不建议使用，容易出错。</li>\n<li>如果要高效遍历key-value，建议使用entrySet()，keySet()也可以做到，但需要通过key来获取value，多增加了一步。</li>\n<li>获取所有key就使用keySet()，获取所有value就使用values()</li>\n\n</ul>\n\n</div>\n\n</div>\n</div>\n<div id=\"MySignature\"></div>\n<div class=\"clear\"></div>\n<div id=\"blog_post_info_block\"><div id=\"BlogPostCategory\">\n    分类: \n            <a href=\"https://www.cnblogs.com/fwnboke/category/977503.html\" target=\"_blank\">Java基础总结</a></div>\n\n\n    <div id=\"blog_post_info\">\n<div id=\"green_channel\">\n        <a href=\"javascript:void(0);\" id=\"green_channel_digg\" onclick=\"DiggIt(8529656,cb_blogId,1);green_channel_success(this,'谢谢推荐！');\">好文要顶</a>\n        <a id=\"green_channel_follow\" onclick=\"follow('5c46ef51-7228-e611-9fc1-ac853d9f53cc');\" href=\"javascript:void(0);\">关注我</a>\n    <a id=\"green_channel_favorite\" onclick=\"AddToWz(cb_entryId);return false;\" href=\"javascript:void(0);\">收藏该文</a>\n    <a id=\"green_channel_weibo\" href=\"javascript:void(0);\" title=\"分享至新浪微博\" onclick=\"ShareToTsina()\"><img src=\"https://common.cnblogs.com/images/icon_weibo_24.png\" alt=\"\"></a>\n    <a id=\"green_channel_wechat\" href=\"javascript:void(0);\" title=\"分享至微信\" onclick=\"shareOnWechat()\"><img src=\"https://common.cnblogs.com/images/wechat.png\" alt=\"\"></a>\n</div>\n<div id=\"author_profile\">\n    <div id=\"author_profile_info\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/fwnboke/\" target=\"_blank\"><img src=\"https://pic.cnblogs.com/face/969690/20170402132941.png\" class=\"author_avatar\" alt=\"\"></a>\n        <div id=\"author_profile_detail\" class=\"author_profile_info\">\n            <a href=\"https://home.cnblogs.com/u/fwnboke/\">乘风起</a><br>\n            <a href=\"https://home.cnblogs.com/u/fwnboke/followees/\">关注 - 0</a><br>\n            <a href=\"https://home.cnblogs.com/u/fwnboke/followers/\">粉丝 - 21</a>\n        </div>\n    </div>\n    <div class=\"clear\"></div>\n    <div id=\"author_profile_honor\"></div>\n    <div id=\"author_profile_follow\">\n                <a href=\"javascript:void(0);\" onclick=\"follow('5c46ef51-7228-e611-9fc1-ac853d9f53cc');return false;\">+加关注</a>\n    </div>\n</div>\n<div id=\"div_digg\">\n    <div class=\"diggit\" onclick=\"votePost(8529656,'Digg')\">\n        <span class=\"diggnum\" id=\"digg_count\">1</span>\n    </div>\n    <div class=\"buryit\" onclick=\"votePost(8529656,'Bury')\">\n        <span class=\"burynum\" id=\"bury_count\">0</span>\n    </div>\n    <div class=\"clear\"></div>\n    <div class=\"diggword\" id=\"digg_tips\">\n    </div>\n</div>\n\n<script type=\"text/javascript\">\n    currentDiggType = 0;\n</script></div>\n    <div class=\"clear\"></div>\n    <div id=\"post_next_prev\">\n\n    <a href=\"https://www.cnblogs.com/fwnboke/p/8529647.html\" class=\"p_n_p_prefix\">« </a> 上一篇：    <a href=\"https://www.cnblogs.com/fwnboke/p/8529647.html\" title=\"发布于 2018-03-08 17:19\">Java集合框架体系</a>\n    <br>\n    <a href=\"https://www.cnblogs.com/fwnboke/p/8529670.html\" class=\"p_n_p_prefix\">» </a> 下一篇：    <a href=\"https://www.cnblogs.com/fwnboke/p/8529670.html\" title=\"发布于 2018-03-08 17:23\">泛型的定义、用法与类型通配符的使用方式</a>\n\n</div>\n</div>\n            </div>"
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  },
  {
    "category": "javaBasic",
    "qes": "",
    "ans": ""
  }

]